<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+Github Pages博客搭建手册</title>
    <url>/2021/11/09/Hexo-Github-Pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>花了几天时间，终于搭建了心满意足的个人网站，欢迎来访：<a href="https://benkoons.github.io/">笨小康的个人网站</a>。本文主要介绍如何使用 Hexo + Github Pages 搭建个人网站，并发布自己的第一篇文章。</p>
<h1 id="1-Hexo-Github-Pages介绍"><a href="#1-Hexo-Github-Pages介绍" class="headerlink" title="1. Hexo/Github Pages介绍"></a>1. Hexo/Github Pages介绍</h1><p>Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。大家可以进入 <a href="https://hexo.io/zh-cn/docs/">Hexo</a> 官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p>
<p>Github Pages 是 Github 提供的一个静态站点托管服务，旨在直接从 GitHub 仓库中直接托管您的个人、组织或项目页面。</p>
<h1 id="2-Hexo搭建博客"><a href="#2-Hexo搭建博客" class="headerlink" title="2. Hexo搭建博客"></a>2. Hexo搭建博客</h1><p>本博客搭建文档主要是针对 mac 电脑。</p>
<h2 id="2-1-安装Homebrew"><a href="#2-1-安装Homebrew" class="headerlink" title="2.1 安装Homebrew"></a>2.1 安装Homebrew</h2><p>mac 系统和 Linux 比较类似，安装软件也可以通过 shell 命令来完成，和 Linux 的 yum install 命令类似，mac 提供了 brew install 的方式安装软件，brew 命令使用需要安装 Homebrew。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-安装git"><a href="#2-2-安装git" class="headerlink" title="2.2 安装git"></a>2.2 安装git</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装命令</span></span><br><span class="line">brew install git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">git -v</span><br></pre></td></tr></table></figure>

<h2 id="2-3-安装nodejs"><a href="#2-3-安装nodejs" class="headerlink" title="2.3 安装nodejs"></a>2.3 安装nodejs</h2><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装命令</span></span><br><span class="line">brew install node</span><br><span class="line">brew install npm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h2 id="2-4-安装Hexo"><a href="#2-4-安装Hexo" class="headerlink" title="2.4 安装Hexo"></a>2.4 安装Hexo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装命令</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<h2 id="2-5-初始化Hexo"><a href="#2-5-初始化Hexo" class="headerlink" title="2.5 初始化Hexo"></a>2.5 初始化Hexo</h2><p>首先，对 Hexo 目录（目录名自定义，作为本地博客存储仓库）进行初始化，并安装相关依赖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化 Hexo，blog 名字自定义</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入到 blog 文件夹</span></span><br><span class="line">cd blog</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>文件夹下包括一些文件和目录：</p>
<ul>
<li><p>node_modules: 依赖包</p>
</li>
<li><p>public：存放生成的页面</p>
</li>
<li><p>scaffolds：生成文章的一些模板</p>
</li>
<li><p>source：用来存放你的文章</p>
</li>
<li><p>themes：主题，Hexo可以扩展其他主题风格</p>
</li>
<li><p>_config.yml: 博客的全局配置文件</p>
</li>
</ul>
<p>其次，部署 Hexo 文件，并在本地启动服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 部署形成的文件</span></span><br><span class="line">hexo g（hexo generate 简写）</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务器</span></span><br><span class="line">hexo s (hexo server 简写）</span><br></pre></td></tr></table></figure>

<p>最后，查看本地部署结果，可以在浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看，效果如下（这里只表明在本地部署成功，无法在外网访问，还需要绑定 Github）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/09/df2e38dca622ea00495961e453bdfaac-1635943805021-e4322cfd-6908-4805-b52c-e8d10a3bca2f-1678db.png" alt="img"></p>
<h2 id="2-6-Github创建个人仓库"><a href="#2-6-Github创建个人仓库" class="headerlink" title="2.6 Github创建个人仓库"></a>2.6 Github创建个人仓库</h2><p>在 GitHub.com 中通过 New repository 创建一个仓库，创建一个和你用户名相同的仓库，后面加 .github.io。只有这样，将 Hexo 部署到GitHub page 时才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名，<strong>其他信息保持默认即可，也可以勾选创建 README 文件。</strong>仓库创建如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/09/9cede1d05042f66fd3056045501f434d-1636388333521-0cc72286-84e4-4617-9d37-f06c5917e18f-d9afa4.png" alt="img"></p>
<h2 id="2-7-生成SSH添加到Github"><a href="#2-7-生成SSH添加到Github" class="headerlink" title="2.7 生成SSH添加到Github"></a>2.7 生成SSH添加到Github</h2><h3 id="2-7-1-配置个人信息"><a href="#2-7-1-配置个人信息" class="headerlink" title="2.7.1 配置个人信息"></a>2.7.1 配置个人信息</h3><p>回到 git bash 中，配置用户名和邮箱，用户名为 Github 用户名，邮箱为 Github 使用的邮箱，主要用于 Github 验证你的账号信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>

<p>check 用户名和邮箱是否正确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-创建SSH-Token"><a href="#2-7-2-创建SSH-Token" class="headerlink" title="2.7.2 创建SSH Token"></a>2.7.2 创建SSH Token</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>

<p>.ssh 目录是你电脑生成的公钥 id_rsa.pub 和私钥 id_rsa，公钥 id_rsa.pub 是公开的，可以对外给别人看，Github 也正是使用这个公钥来允许来自你电脑的访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">benkoonsMacBook-Pro:_posts benkoons$ ls -l ~/.ssh/</span><br><span class="line">total 32</span><br><span class="line">-rw-------  1 sshull  staff  1876 10 30 22:51 id_rsa</span><br><span class="line">-rw-r--r--  1 sshull  staff   401 10 30 22:51 id_rsa.pub</span><br><span class="line">-rw-------  1 sshull  staff   671 10 31 02:00 known_hosts</span><br></pre></td></tr></table></figure>

<h3 id="2-7-3-Github配置公钥"><a href="#2-7-3-Github配置公钥" class="headerlink" title="2.7.3 Github配置公钥"></a>2.7.3 Github配置公钥</h3><p>在GitHub的setting中，找到SSH keys的设置选项，点击 <code>New SSH key</code>把你的 <code>id_rsa_pub</code>里面的信息复制进去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/09/74f3e883cee1c34c22324cfd0671ffda-1636389388364-21b0b065-c70d-40be-b2b9-3a78d54177ad-99de59.png" alt="img"></p>
<h3 id="2-7-4-测试连接"><a href="#2-7-4-测试连接" class="headerlink" title="2.7.4 测试连接"></a>2.7.4 测试连接</h3><p>使用如下命令测试连接 Github 是否成功，命令不需要修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com   // 不修改</span><br></pre></td></tr></table></figure>

<h2 id="2-8-将Hexo部署到Github"><a href="#2-8-将Hexo部署到Github" class="headerlink" title="2.8 将Hexo部署到Github"></a>2.8 将Hexo部署到Github</h2><p>部署前先安装 deployer-git 依赖，然后才能用命令将 Hexo 部署到 Github。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，需改 deploy 信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:benkoons/benkoons.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>部署之后发布站点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean	<span class="comment"># 清除之前生成的东西，可不加</span></span><br><span class="line">hexo g  		<span class="comment"># 生成静态文章</span></span><br><span class="line">hexo d			<span class="comment"># 部署网站</span></span><br></pre></td></tr></table></figure>

<p>部署时可能需要输入 ssh 密码（即电脑密码），发布成功后可通过 <a href="https://benkoons.github.io/">https://benkoons.github.io/</a> 查看网站。</p>
<h1 id="3-Hexo常用命令"><a href="#3-Hexo常用命令" class="headerlink" title="3. Hexo常用命令"></a>3. Hexo常用命令</h1><p>常见命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> 	<span class="comment"># 新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> 	<span class="comment"># 新建页面</span></span><br><span class="line">hexo generate 		<span class="comment"># 生成静态页面至public目录</span></span><br><span class="line">hexo server 			<span class="comment"># 开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy 			<span class="comment"># 部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  				<span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  		<span class="comment"># 查看Hexo的版本</span></span><br></pre></td></tr></table></figure>

<p>缩写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<p>组合命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s -g 	<span class="comment"># 生成并本地预览</span></span><br><span class="line">hexo d -g 	<span class="comment"># 生成并上传</span></span><br></pre></td></tr></table></figure>

<h1 id="4-发布第一篇文章"><a href="#4-发布第一篇文章" class="headerlink" title="4. 发布第一篇文章"></a>4. 发布第一篇文章</h1><p>在 blog 目录下通过 Hexo 命令新建一篇文章。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;笨小康的第一篇文章&quot;</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，文章的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 笨小康的第一篇文章</span><br><span class="line">date: 2021-11-09 00:51:07</span><br><span class="line">tags:</span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">categories:</span><br><span class="line">- 分类1</span><br><span class="line">- 分类2</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下是正文内容～～</span><br></pre></td></tr></table></figure>

<p>发布查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s		<span class="comment"># 发布本地预览</span></span><br><span class="line">hexo d -g	<span class="comment"># 发布Githuh查看</span></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029/">hexo史上最全搭建教程</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法手册</title>
    <url>/2021/11/08/Markdown%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>介绍 Markdown 写文章的一些常见用法。</p>
<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> 一级标题</span><br><span class="line"><span class="params">##</span> 二级标题</span><br><span class="line"><span class="params">###</span> 三级标题</span><br><span class="line"><span class="params">####</span> 四级标题</span><br><span class="line"><span class="params">#####</span> 五级标题</span><br><span class="line"><span class="params">######</span> 六级标题</span><br></pre></td></tr></table></figure>

<h1 id="2-段落格式"><a href="#2-段落格式" class="headerlink" title="2. 段落格式"></a>2. 段落格式</h1><h2 id="2-1-字体"><a href="#2-1-字体" class="headerlink" title="2.1 字体"></a>2.1 字体</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">*斜体文本*  </span><br><span class="line">**粗体文本**  </span><br><span class="line">***斜粗体文本***</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><em>斜体文本</em><br><strong>粗体文本</strong><br><em><strong>斜粗体文本</strong></em></p>
<h2 id="2-2-分割线"><a href="#2-2-分割线" class="headerlink" title="2.2 分割线"></a>2.2 分割线</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">或者</span><br><span class="line">****</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<hr>
<hr>
<h2 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">~~google.com~~</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><del>delete baidu.com</del></p>
<h2 id="2-4-下划线"><a href="#2-4-下划线" class="headerlink" title="2.4 下划线"></a>2.4 下划线</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;我是下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><u>我是下划线</u></p>
<h2 id="2-5-文本居中"><a href="#2-5-文本居中" class="headerlink" title="2.5 文本居中"></a>2.5 文本居中</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;我是居中文本&lt;/center&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<center>我是居中文本</center>

<h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h1><h2 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- 一级列表</span><br><span class="line">  - 二级列表</span><br><span class="line">  - 二级列表</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>一级列表<ul>
<li>二级列表</li>
<li>二级列表</li>
</ul>
</li>
</ul>
<h2 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 一级列表</span><br><span class="line">   1. 二级列表</span><br><span class="line">   2. 二级列表</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ol>
<li>一级列表<ol>
<li>二级列表</li>
<li>二级列表</li>
</ol>
</li>
</ol>
<h2 id="3-3-todo列表"><a href="#3-3-todo列表" class="headerlink" title="3.3 todo列表"></a>3.3 todo列表</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- [ ] 事项1 </span><br><span class="line">  - [x] 子事项1（已完成）</span><br><span class="line">  - [ ] 子事项2（未完成）</span><br><span class="line">- [ ] 事项2</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p><input disabled="" type="checkbox">  事项1</p>
<ul>
<li><input disabled="" type="checkbox"> 子事项1（已完成）</li>
<li><input disabled="" type="checkbox"> 子事项2（未完成）</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  事项2</p>
</li>
</ul>
<h1 id="4-区块"><a href="#4-区块" class="headerlink" title="4. 区块"></a>4. 区块</h1><h2 id="4-1-嵌套区块"><a href="#4-1-嵌套区块" class="headerlink" title="4.1 嵌套区块"></a>4.1 嵌套区块</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt; 区块1</span><br><span class="line">&gt;&gt; 区块11  </span><br><span class="line">&gt;&gt; 区块12 </span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>区块1</p>
<blockquote>
<p>区块11<br>区块12 </p>
</blockquote>
</blockquote>
<h2 id="4-2-多行序列区块"><a href="#4-2-多行序列区块" class="headerlink" title="4.2 多行序列区块"></a>4.2 多行序列区块</h2><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&gt; 区块2</span><br><span class="line">&gt; - 区块21</span><br><span class="line">&gt; 1. 区块22</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>区块2</p>
<ul>
<li>区块21</li>
</ul>
<ol>
<li>区块22</li>
</ol>
</blockquote>
<h1 id="4-3-行内引用"><a href="#4-3-行内引用" class="headerlink" title="4.3 行内引用"></a>4.3 行内引用</h1><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">你说`我就是个傻子`，对不对</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p>你说<code>我就是个傻子</code>，对不对</p>
<h1 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h1><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line">System.out.print(&quot;hello world&quot;)</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6. 链接"></a>6. 链接</h1><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">方式一：[链接名称](链接地址)</span><br><span class="line">1. 这是一个链接 [谷歌搜索](https://www.google.com)  </span><br><span class="line"></span><br><span class="line">方式二：&lt;链接地址&gt;</span><br><span class="line">2. &lt;https://www.google.com&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ol>
<li>这是一个链接 <a href="https://www.google.com/">谷歌搜索</a>  </li>
<li><a href="https://www.google.com/">https://www.google.com</a></li>
</ol>
<h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7. 图片"></a>7. 图片</h1><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">方式：![属性文本](图片地址 &quot;可选标题&quot;)</span><br><span class="line"></span><br><span class="line">![面具防护](https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/08/2fb74afdc4483015dddd039aa2189fe5-mask-5932015<span class="built_in">_</span><span class="built_in">_</span>340-39f087.png &quot;good idea&quot;)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/08/2fb74afdc4483015dddd039aa2189fe5-mask-5932015__340-39f087.png" alt="面具防护" title="good idea"></p>
<h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h1><p>语法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN NodeManager总体架构</title>
    <url>/2021/11/06/YARN-NodeManager%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>NodeManager（NM）是 YARN 中单个节点上的代理，它管理 Hadoop 集群中单个计算节点，功能包括与 ResourceManager 保持通信、管理 Container 的生命周期、监控每个 Container 的资源使用情况、追踪节点健康状况、管理日志和不同应用程序用到的附属服务（auxiliary service）</p>
<h2 id="1-NodeManager-基本职能"><a href="#1-NodeManager-基本职能" class="headerlink" title="1. NodeManager 基本职能"></a>1. NodeManager 基本职能</h2><p>整体上讲，NodeManager 需要通过两个 RPC 协议与 ResourceManager 服务和各个应用程序的 ApplicationMaster 交互，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/07/9aa367bbb1f16e341ca9aa315f6961d2-1372882-20200902212501158-334281140-0f82f8.png" alt="img"></p>
<center>NodeManager 相关 RPC 协议</center>

<p><strong>ResourceTrackerProtocol 协议</strong>：NodeManager 通过该 RPC 协议向 ResourceManager 注册、汇报节点健康状况和 Container 运行状态，并领取 ResourceManager 下达的命令，包括重新初始化、清理 Container 占用资源等。在该协议中，ResourceManager 扮演 RPC server 的角色，而 NodeManager 扮演 RPC Client 的角色（由内部组件 NodeStatusUpdater 实现），换句话说，NodeManager 与 ResourceManager 之间采用 “pull 模型”，NodeManager 总是周期性地主动向 ResourceManager 发起请求，并领取下达给自己的命令。</p>
<p><strong>ContainerManagementProtocol 协议：</strong>应用程序的 ApplicationMaster 通过该 RPC 协议向 NodeManager 发起针对 Container 的相关操作，包括启动 Container、杀死 Container、获取 Container 执行状态等。在该协议中，ApplicationMaster 扮演 RPC Client 的角色，而 NodeManager 扮演 RPC Server 的角色（由内部组件 ContainerManager 实现），换句话说，NodeManager 与 ApplicationMaster 之间采用了 “push 模型”，ApplicationMaster 可以将 Container 相关操作的第一时间告诉 NodeManager，相比于 “pull 模型”，可以大大降低时间延迟。</p>
<h2 id="2-NodeManager-内部结构"><a href="#2-NodeManager-内部结构" class="headerlink" title="2. NodeManager 内部结构"></a>2. NodeManager 内部结构</h2><p>这部分主要深入介绍 NodeManager 内部组织结构和主要模块，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/07/3cb960ba925a2316cbadd27f46fa7edf-1372882-20200902212423701-381786426-f639fd.png" alt="img"></p>
<center>NodeManager 内部结构</center>

<p><strong>NodeStatusUpdate：</strong>NodeStatusUpdater 是 NodeManager 与 ResourceManager 通信的唯一通道。当 NodeManager 启动是，该组件负责向 ResourceManager 注册，并汇报节点上总的可用资源。之后，该组件周期性与 ResourceManager 通信，汇报各个 Container 的状态更新，包括节点上正在运行的 Container、已经完成的 Container 等信息，同时 ResourceManager 会为之返回待清理的 Container 列表、待清理的应用程序列表、诊断信息、各种 Token 等信息。</p>
<p><strong>ContainerManager：</strong>ContainerManager 是 NodeManager 中最核心的组件之一，它由多个子组件组成，每个子组件负责一部分功能，协同管理运行在该节点上的所有 Container，各个子组件如下：</p>
<ul>
<li><strong>RPC Server：</strong>该 RPC Server 实现了 ContainerManagementProtocol 协议，是 ApplicationMaster 与 NodeManager 通信的唯一通道。ContainerManager 从各个 ApplicationMaster 上接收 RPC 请求以启动新的 Container 或者挺直正在运行的 Container。需要注意的是，任何 Container 操作均会经 ContainerTokenSecretManager 合法性验证，以防止 ApplicationMaster 伪造启动或停止 Container 的命令。</li>
<li><strong>ResourceLocalizationService：</strong>负责 Container 所需资源的本地化，它能够按照描述从 HDFS 上下载 Container 所需的文件资源，并尽量将它们分摊到各个磁盘上以防止出现热点访问。此外，它会为下载的文件添加访问控制限制，并为之施加合适的磁盘空间使用份额。</li>
<li><strong>ContianersLauncher：</strong>维护了一个线程池以并行完成 Container 相关操作，比如启动或者杀死 Container，其中启动 Container 请求是由 ApplicationMaster 发起的，而杀死 Container 请求则可能来自 ApplicationMaster 或者 ResourceManager。</li>
<li><strong>AuxService：</strong>NodeManager 允许用户通过配置附属服务的方式扩展自己的功能，这使得每个节点可以定制一些特定框架的服务。附属服务需要在 NodeManager 启动之前配置好，并由 NodeManager 统一启动与关闭。</li>
<li><strong>ContainersMonitor：</strong>ContainersMonitor 负责监控 Container 的资源使用量，为了实现资源隔离和公平共享，ResourceManager 为每个 Container 分配了一定量的资源。而 ContainersMonitor 周期性探测它在运行过程中的资源利用量，一旦发生 Container 超出了它的允许使用份额上线，就向 Container 发送信号将其杀掉，这可以避免资源密集型的 Container 影响同节点上其他正在运行的 Container。</li>
<li><strong>LogHandler：</strong>一个可插拔组件，用户可通过它控制 Container 日志的保存方式，即是写到本地磁盘上还是将其打包后上传到一个文件系统中。</li>
<li><strong>ContainerEventDispatcher：</strong>Container 事件调度器，负责将 ContainerEvent 类型的事件调度给对应 Container 的状态机 ContainerImpl。</li>
<li><strong>ApplicationEventDispatcher：</strong>Application 事件调度器，负责将 ApplicationEvent 类型的事件调度给对应 Application 的状态机 ApplicationImpl。</li>
</ul>
<p><strong>ContainerExecutor：</strong>ContainerExecutor 可与底层操作系统交互，安全存放 Container 需要的文件和目录，进而以一种安全的方式启动和清除 Container 对应的进程。目前 YARN 提供了 DefaultContainerExecutor、LinuxContainerExecutor 和 DockerContainerExecutor 三种实现。</p>
<p><strong>NodeHealthCheckerService：</strong>NodeHealthCheckerService 通过周期性地运行一个自定义脚本（由组件 NodeHealthScriptRunner 完成）和向磁盘写文件（由服务 LocalDirsHandlerService 完成）检查节点的健康状况，并将之通过 NodeStatusUpdater 传递给 ResourceManager。一旦 ResourceManager 发现一个节点处于不健康状态，则会将它加入黑名单，此后不再为它分配资源，直到再次转为健康状态。需要注意的是，节点被加入黑名单时，正在运行的 Container 仍会正常运行，不会被杀死。</p>
<p><strong>DeletionService：</strong>NodeManager 将文件删除功能服务化，即提供一个专门的文件删除服务，异步删除失效文件，这样可避免删除文件带来的性能开销。</p>
<p><strong>Security：</strong>安全模块是 NodeManager 中的一个重要模块，它包含两部分，分别是 ApplicationACLsManager 和 ContainerTokenSecretManager，ApplicationACLsManager 确保访问 NodeManager 的用户是合法的，ContainerTokenSecretManager 确保用户请求的资源被 ResourceManager 授权过。具体如下：</p>
<ul>
<li><strong>ApplicationACLsManager：</strong>NodeManager 需要为所有面向用户的 API 提供安全检查，如在 Web UI 上只能将 Container 日志显示给授权用户。该组件为每个应用程序维护了一个 ACL 列表，一旦收到类似请求后会利用该列表对其进行验证。</li>
<li><strong>ContainerTokenSecretManager：</strong>检查收到的各种访问请求的合法性，确保这些请求操作已被 ResourceManager 授权。</li>
</ul>
<p><strong>WebServer：</strong>通过 Web 界面向用户展示该节点上所有应用程序运行状态、Container 列表、节点健康状况和 Container 产生的日志等信息。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>董西成.《Hadoop技术内幕：深入解析YARN架构设计与实现原理》</li>
</ul>
]]></content>
      <categories>
        <category>YARN</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>YARN</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN ResourceManager总体架构</title>
    <url>/2021/11/06/YARN-ResourceManager%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>ResourceManager(简称 RM) 是 YARN 组件的核心服务，主要负责 Hadoop 集群中资源的集中管理和统一调度。</p>
<h2 id="1-ResourceManager基本职能"><a href="#1-ResourceManager基本职能" class="headerlink" title="1. ResourceManager基本职能"></a>1. ResourceManager基本职能</h2><p>在YARN中，ResourceManager负责集群中所有资源的统一管理和分配，它接收来自各个节点（NodeManager）的资源汇报信息，并把这些信息按照一定的策略分配给各个应用程序（实际上是ApplicationMaster）。整体上讲，ResourceManager需通过两个RPC协议与NodeManager和（各个应用程序的）ApplicationMaster交互，如图所示，具体如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/08/06c906d90643b0318e2737d79bcc34b2-1636344037002-d29d9c88-e285-4acd-8db0-63d036b7f8ef-40200f.png" alt="RM rpc调用.png"></p>
<center>ResourceManager相关RPC协议</center>

<p><strong>ResourceTrackerProtocol：</strong>NodeManager通过该RPC协议向ResourceManager注册、汇报节点健康状况和Container运行状态，并领取ResourceManager下达的命令，这些命令包括重新初始化、清理Container等，在该RPC协议中，ResourceManager扮演RPC Server的角色（由内部组件ResourceTrackerService实现），而NodeManager扮演RPC Client的角色，换句话说，NodeManager与ResourceManager之间采用了“pull模型”（与MRv1类似），NodeManager 总是周期性地主动向ResourceManager发起请求，并通过领取下达给自己的命令。 </p>
<p><strong>ApplicationMasterProtocol：</strong>应用程序的ApplicationMaster通过该RPC协议向ResourceManager注册、申请资源和释放资源。在该协议中，ApplicationMaster扮演RPCClient的角色，而ResourceManager扮演RPC Server的角色，换句话说，ResourceManager与ApplicationMaster之间也采用了“pull模型”。</p>
<p><strong>ApplicationClientProtocol：</strong>应用程序的客户端通过该RPC协议向ResourceManager提交应用程序、查询应用程序状态和控制应用程序（比如杀死应用程序）等。在该协议中，应用工程序客户端扮演RPC Client的角色，而ResourceManager扮演RPC Server的角色。</p>
<p>概括起来，ResourceManager主要完成以下几个功能：</p>
<ul>
<li>与客户端交互，处理来自客户端的请求；</li>
<li>启动和管理ApplicationMaster，并在它运行失败时重新启动它；</li>
<li>管理NodeManager，接收来自NodeManager的资源汇报信息，并向NodeManager下达管理指令（比如杀死Container等）；</li>
<li>资源管理与调度，接收来自ApplicationMaster的资源申请请求，并为之分配资源。</li>
</ul>
<h2 id="2-ResourceManager内部架构"><a href="#2-ResourceManager内部架构" class="headerlink" title="2. ResourceManager内部架构"></a>2. ResourceManager内部架构</h2><p>这部分主要介绍ResourceManager的内部组织结构和主要模块，如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/08/8fe952fed3089589fb0d146b0e01ca29-1636344037139-e1372801-a1af-4c3f-a04b-989a1388280a-1963ce.png" alt="img"></p>
<center>ResourceManager内部架构图</center>

<p>ResourceManager主要由以下几个部分组成：</p>
<h3 id="2-1-用户交互模块"><a href="#2-1-用户交互模块" class="headerlink" title="2.1 用户交互模块"></a>2.1 用户交互模块</h3><p>ResourceManager分别针对普通用户、管理员和Web提供了三种对外服务，具体实现分别对应ClientRMService、AdminService和WebApp。</p>
<p><strong>ClientRMService。</strong>ClientRMService是为普通用户提供的服务，它处理来自客户端各种RPC请求，比如提交应用程序、终止应用程序、获取应用程序运行状态等。</p>
<p><strong>AdminService。</strong>ResourceManager为管理员提供了一套独立的服务接口，以防止大量的普通用户请求使管理员发送的管理命令饿死，管理员可通过这些接口管理集群，比如动态更新节点列表、更新ACL列表、更新队列信息等。　</p>
<p><strong>WebApp。</strong>为了更加友好地展示集群资源使用情况和应用程序运行状态等信息，YARN对外提供了一个Web 界面，这一部分是YARN仿照Haml。</p>
<h3 id="2-2-NM管理模块"><a href="#2-2-NM管理模块" class="headerlink" title="2.2 NM管理模块"></a>2.2 NM管理模块</h3><p>该模块主要涉及以下组件：　</p>
<p><strong>NMLivelinessMonitor。</strong>监控NM是否活着，如果一个NodeManager在一定时间（默认为10min）内未汇报心跳信息，则认为它死掉了，需将其从集群中移除。　</p>
<p><strong>NodesListManager。</strong>维护正常节点和异常节点列表，管理exclude（类似于黑名单）和include（类似于白名单）节点列表，这两个列表均是在配置文件中设置的，可以动态加载。</p>
<p><strong>ResourceTrackerService。</strong>处理来自NodeManager的请求，主要包括注册和心跳两种请求，其中，注册是NodeManager启动时发生的行为，请求包中包含节点ID、可用的资源上限等信息；而心跳是周期性行为，包含各个Container运行状态，运行的Application列表、节点健康状况（可通过一个脚本设置）等信息，作为请求的应答，ResourceTrackerService可为NodeManager返回待释放的Container列表、Application列表等信息。</p>
<h3 id="2-3-AM管理模块"><a href="#2-3-AM管理模块" class="headerlink" title="2.3 AM管理模块"></a>2.3 AM管理模块</h3><p>该模块主要涉及以下组件： </p>
<p><strong>AMLivelinessMonitor</strong>。监控AM是否活着，如果一个ApplicationMaster在一定时间（默认为10min）内未汇报心跳信息，则认为它死掉了，它上面所有正在运行的Container将被置为失败状态，而AM本身会被重新分配到另外一个节点上（用户可指定每个ApplicationMaster的尝试次数，默认是2）执行。　</p>
<p><strong>ApplicationMasterLauncher。</strong>与某个NodeManager通信，要求它为某个应用程序启动ApplicationMaster。　</p>
<p><strong>ApplicationMasterService（AMS）。</strong>处理来自ApplicationMaster的请求，主要包括注册和心跳两种请求，其中，注册是ApplicationMaster启动时发生的行为，注册请求包中包含ApplicationMaster启动节点；对外RPC端口号和tracking URL等信息；而心跳则是周期性行为，汇报信息包含所需资源描述、待释放的Container列表、黑名单列表等，而AMS则为之返回新分配的Container、失败的Container、待抢占的Container列表等信息。</p>
<h3 id="2-4-Application管理模块"><a href="#2-4-Application管理模块" class="headerlink" title="2.4 Application管理模块"></a>2.4 Application管理模块</h3><p>该模块主要涉及以下组件：　 </p>
<p><strong>ApplicationACLsManage。</strong>管理应用程序访问权限，包含两部分权限：查看权限和修改权限。查看权限主要用于查看应用程序基本信息，而修改权限则主要用于修改应用程序优先级、杀死应用程序等。　</p>
<p><strong>RMAppManager。</strong>管理应用程序的启动和关闭。　</p>
<p><strong>ContainerAllocationExpirer。</strong>当AM收到RM新分配的一个Container后，必须在一定的时间（默认为10min）内在对应的NM上启动该Container，否则RM将强制回收该Container，而一个已经分配的Container是否该被回收则是由ContainerAllocationExpirer决定和执行的。</p>
<h3 id="2-5-状态机管理模块"><a href="#2-5-状态机管理模块" class="headerlink" title="2.5 状态机管理模块"></a>2.5 状态机管理模块</h3><p>ResourceManager使用有限状态机维护有状态对象的生命周期，状态机的引入使得YARN设计架构更加清晰。ResourceManager共维护了4类状态机，分别是RMApp、RMAppAttempt、RMContainer和RMNode（这几个均是接口，具体实现类为对应接口名加上”Impl”后缀）。　</p>
<p><strong>RMApp。</strong>RMApp维护了一个应用程序（Application）的整个运行周期，包括从启动到运行结束整个过程。由于一个Application的生命周期可能会启动多个Application运行实例（Application Attempt），因此可认为，RMApp维护的是同一个Application启动的所有运行实例的生命周期。　</p>
<p><strong>RMAppAttempt。</strong>一个应用程序可能启动多个实例，即一个实例运行失败后，可能再次启动一个重新运行，而每次启动称为一次运行尝试（或者“运行实例”），用”RMAppAttempt”描述，RMAppAttempt维护了一次运行尝试的整个生命周期。　</p>
<p><strong>RMContainer。</strong>RMContainer维护了一个Container的运行周期，包括从创建到运行结束整个过程。ResourceManager将资源封装成Container发送给应用程序的ApplicationMaster，而ApplicationMaster则会在Container描述的运行环境中启动任务，因此，从这个层面上讲，Container和任务的生命周期是一致的（目前YARN尚不支持Container重用，一个Container用完后会立刻释放，将来可能会增加Container重用机制）。　</p>
<p><strong>RMNode。</strong>RMNode维护了一个NodeManager的生命周期，包括启动到运行结束整个过程。</p>
<h3 id="2-6-安全管理模块"><a href="#2-6-安全管理模块" class="headerlink" title="2.6 安全管理模块"></a>2.6 安全管理模块</h3><p>ResourceManage自带了非常全面的权限管理机制，主要由ClientTo-AMSecretManager、ContainerTokenSecretManager、ApplicationTokenSecretManager等模块完成。</p>
<h3 id="2-7-资源分配模块"><a href="#2-7-资源分配模块" class="headerlink" title="2.7 资源分配模块"></a>2.7 资源分配模块</h3><p>该模块主要涉及一个组件—ResourceScheduler。ResourceScheduler是资源调度器，它按照一定的约束条件（比如队列容量限制等）将集群中的资源分配给各个应用程序，当前主要考虑内存和CPU资源。ResourceScheduler是一个插拔式模块，YARN自带了一个批处理资源调度器—FIFO（First In First Out）和两个多用户调度器—Fair Scheduler和CapacityScheduler。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>董西成.《Hadoop技术内幕：深入解析YARN架构设计与实现原理》</li>
</ul>
]]></content>
      <categories>
        <category>YARN</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>YARN</tag>
      </tags>
  </entry>
  <entry>
    <title>始于日记，忠于写作</title>
    <url>/2021/11/10/%E5%A7%8B%E4%BA%8E%E6%97%A5%E8%AE%B0%EF%BC%8C%E5%BF%A0%E4%BA%8E%E5%86%99%E4%BD%9C/</url>
    <content><![CDATA[<p>一直想写点东西，但迟迟没有动身，一是不知道写什么，二是担心写不好，便一拖再拖，可明日复明日，明日何其多，结果就是永远不会有进展。</p>
<p>想做一件事，不去做始终是一项遗憾，正如非洲经济学家 Dambisa Moyo（丹比萨·莫约）在书籍 《dead aid》结束语中所说，只要你兴趣还在，可以一直做，什么时候都不会晚，种一棵树最好的时间是十年前，其次是现在。</p>
<p>确实，一件事，只要开始行动，终究是有回馈的，不管是积极的还是消极的，一旦有变化就是好的征兆，因为行动之后的连锁效应是无法预估的。</p>
<p>因为对写作充满畏惧，一直没有行动，于是选择从最简单的方式开始——写日记。日记是一种特殊的写作方式，因为读者通常只有你自己，这就给了作者很大的发挥空间，你不用顾及自己写什么，也不用担心写不好或者被别人嘲笑。自己坚持写日记有一段时间，也就有了现在在平台写作的勇气，写得好与坏姑且不做评判，但一定是自己想写的内容，也一定是最真实的想法。</p>
<p>从自己写日记的经验来看，日记内容主要包括三个方面，分别是：工作日记、读书心得和思想感悟。</p>
<ul>
<li><p>记好工作日记，既要记录工作的过程也要记录工作的结果，记录过程是为了让自己同样的错误不犯两遍，也是为了积累更多成功的经验，而记录结果是工作的产出，更是努力收获的果实。</p>
</li>
<li><p>阅读，通常是为了获得收获，包括对全书轮廓的了解、书中细节和知识的了解，以及作者在写作技巧和手法的了解等方面，阅读过的书，把书中精彩的段落记下来，把自己的收获和想法写下来，过一遍脑子，才能更好的变成自己的东西。</p>
</li>
<li><p>记录思想感悟，既可以是思维认知上的感知，也可以是技巧方法上的体会，既可以是现实世界的亲身目睹，也可以是网络世界的“百家争鸣”，既可以是成功的经历，也可以是失败的教训，能让你产生思考和想法的事物，都是可以记录的。</p>
</li>
</ul>
<p>而对于写日记的形式，也是有一些经验技巧。</p>
<p>首先，每次只写一件事。为了达到练习写作的目的，最好努力做到表达清晰、行文流畅、用词准确，尽量避免文章中有太多的基本错误。</p>
<p>其次，带着目的去写。比如你是为了理清某一个问题的思路，还是总结工作内容的得失，亦或是总结时间分配是否合理等等，目的性要很聚焦。</p>
<p>然后，写作要真实。不用在意想法多么单纯不成熟，也不用在意以后想法是否会改变，记录当下最真实的想法，它像是一面镜子，需要时间回顾复盘，不断校正和优化自己的想法。</p>
<p>最后，坚持每天写。写便是行动，行动终将会前进。</p>
]]></content>
      <categories>
        <category>flomo</category>
      </categories>
      <tags>
        <tag>随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>PicGo+Typora配置Github图床手册</title>
    <url>/2021/11/17/PicGo-Typora%E9%85%8D%E7%BD%AEGithub%E5%9B%BE%E5%BA%8A%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>最近用 Hexo + Github 搭建的个人博客写文章，发现文章里的图片在浏览器中没法加载，也不会自动上传到 Github 存稿，在网上找了一些资料，发现可以用图床来满足这个需求。图床，顾名思义，就是存储图片的服务器，能够把自己的所有照片保存在个人图床里。</p>
<p>实现图床的方式网上资料有很多，本文主要选用 Github + PicGo + Typora 的方式实现个人图床，Github 用于图片的存储，PicGo管理图床的工具，Typora是文本编辑器，直接配置图片上传。</p>
<p>先来直接看看效果。</p>
<p>这张图片是 PicGo 的 UI 界面图片，我们将照片拷贝到 Typora 编辑器中，然后右键“上传图片”就将图片上传到 Github 图床了，发布的博客也可以正常访问，是不是很简洁很方便呀。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/87408aac9a9abc2ff76a132c622f6fb4-image-20211117001921095-621a7f.png" alt="image-20211117001921095"></p>
<h1 id="1-Github图床准备"><a href="#1-Github图床准备" class="headerlink" title="1. Github图床准备"></a>1. Github图床准备</h1><h2 id="1-1-新建Github仓库"><a href="#1-1-新建Github仓库" class="headerlink" title="1.1 新建Github仓库"></a>1.1 新建Github仓库</h2><p>Github图床当然也需要一个仓库，仓库名随便取，这里我的图床仓库命名为”blog-imgs”，由于之前创建好了，这里提示已存在，其他保持默认配置即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/8efc22bd846677cb3e9df7ec5cbf33dd-8efc22bd846677cb3e9df7ec5cbf33dd-image-20211117002608528-b6b53b-8ab79f.png" alt="image-20211117002608528"></p>
<h2 id="1-2-创建个人Token"><a href="#1-2-创建个人Token" class="headerlink" title="1.2 创建个人Token"></a>1.2 创建个人Token</h2><p>在 Github 网站的 “Settings -&gt; Developer settings -&gt; Personal access tokens“ 标签中，点击“Generate new token” 按钮新建个人 token 信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/595e06f77bf855b5f9f373f414f1eb1d-image-20211117003451831-d40ef3.png" alt="image-20211117003451831"></p>
<p>最后点击 “generate token” 即可完成 token 的创建。</p>
<p>注意，生成的 token 在页面之后显示一次，一定要把 token 信息复制保存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/2d692e03546a1eaa1832ab93b0108099-image-20211117003550115-b71a12.png" alt="image-20211117003550115"></p>
<p>至此，Github 图床已经创建完成，对外访问图床的个人 token 也创建好了。</p>
<h1 id="2-PicGo配置Github图床"><a href="#2-PicGo配置Github图床" class="headerlink" title="2. PicGo配置Github图床"></a>2. PicGo配置Github图床</h1><h2 id="2-1-下载PicGo"><a href="#2-1-下载PicGo" class="headerlink" title="2.1 下载PicGo"></a>2.1 下载PicGo</h2><p>官网下载地址：（根据电脑版本下载对应文件即可）</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">https://github.com/Molunerfinn/PicGo/releases</span><br></pre></td></tr></table></figure>

<p>PicGo 使用手册：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">https://picgo.github.io/PicGo-Doc/zh/guide/</span><br></pre></td></tr></table></figure>

<h2 id="2-2-配置Github图床"><a href="#2-2-配置Github图床" class="headerlink" title="2.2 配置Github图床"></a>2.2 配置Github图床</h2><p>我是用的 mac 电脑，第一次使用都不知道怎么打开 PicGo UI 界面，如下图，可以通过 mac 状态栏的“打开详细窗口”进到 UI 界面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/75ead9fc3b8c5119b805a2ab49713fe4-image-20211117004309731-551504.png" alt="image-20211117004309731"></p>
<p>接下来就是如何通过 PicGo 配置 Github 图床，UI 中可以看到 PicGo 支持多种图床配置，这里我们选择配置 Github 图床。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> Github 图床配置</span><br><span class="line">设定仓库名（必须）：根据 1.1 小节创建的 Gihub 仓库地址自定义配置。</span><br><span class="line">设定分支名（必须）：main。Github 仓库默认的主分支就是 main，保持不变即可。</span><br><span class="line">设定Token（必须）：根据 1.2 小节创建的个人 Token 信息自定义修改。</span><br><span class="line">指定存储路径（非必须）：图片在仓库中的存储目录，默认是根目录存储所有图片。</span><br><span class="line">设定自定义域名（非必须）：免费的 cdn 访问加速工具，可配置上。格式为:https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;，其实就是第一项信息。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/7c51cb4df5ed344c6db7ac14756f9cf9-image-20211117004525265-f66ab5.png" alt="image-20211117004525265"></p>
<h2 id="2-3-PicGo上传图片"><a href="#2-3-PicGo上传图片" class="headerlink" title="2.3 PicGo上传图片"></a>2.3 PicGo上传图片</h2><p>配置好 Github 图床后，我们可以通过 PicGo UI 界面上传图片到 Github 图床。PicGo 也提供了多种上传方式，我个人选择了两张方式做验证，上传成功后就可以取 Github 图床（其实就是往仓库里提交图片信息）中查看照片是否成功上传。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/7da063c4cea021de4986d618f5484e27-image-20211117005551971-f2db47.png" alt="image-20211117005551971"></p>
<h1 id="3-Typora配置PicGo上传"><a href="#3-Typora配置PicGo上传" class="headerlink" title="3. Typora配置PicGo上传"></a>3. Typora配置PicGo上传</h1><p>用 PicGo 上传图片后，我又遇到一个问题，我在本地编辑器中插入一张图片，我需要先将图片通过 PicGo 上传到 Github 图床，然后在本地编辑器中通过地址插入图片，还是特别不方便。</p>
<h2 id="3-1-配置-PicGo"><a href="#3-1-配置-PicGo" class="headerlink" title="3.1 配置 PicGo"></a>3.1 配置 PicGo</h2><p>好在 Typora 提供了一个图片上传的服务配置，打开 Typora 工具 ”偏好设置 -&gt; 图像“，插入图片选项选择“无特殊操作”，然后在 “上传服务设定” 选项中，我们选择自定义上传命令。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">自定义上传命令：node picgo upload</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">node 命令是 nodeJs 环境，mac 下通过 brew install node 安装。</span><br><span class="line">picgo 命令是 PicGo 环境，mac 下通过 brew install npm; npm install picgo -g 安装。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/c57ffd946f0653f8229eb9d16eafe67d-image-20211117010049415-2f137e.png" alt="image-20211117010049415"></p>
<p>配置好命令后，点击”验证图片上传选项“，若上传成功则出现如下结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/723961c0b72aef8de035e1da4e7b6014-image-20211117010148554-f22b03.png" alt="image-20211117010148554"></p>
<h2 id="3-2-Typora上传图片"><a href="#3-2-Typora上传图片" class="headerlink" title="3.2 Typora上传图片"></a>3.2 Typora上传图片</h2><p>在文章开头也提过到效果，特别简单，两步操作即可完成：</p>
<ol>
<li>复制图片到 Typora 编辑器；</li>
<li>选中图片右键“上传图片”。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/17/87408aac9a9abc2ff76a132c622f6fb4-image-20211117001921095-621a7f.png" alt="image-20211117001921095"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN FairScheduler调度原理与源码分析</title>
    <url>/2021/11/06/YARN-FairScheduler%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文主要介绍 YARN 组件中的核心功能——资源调度，YARN 调度策略包括 FifoScheduler、FairSheduler 和 CapacityScheduler 三种，本文主要介绍 FairScheduler 的调度逻辑，看看集群的 NodeManager 是如何将资源上报给 ResourceManager（简称 RM），RM 是如何集中管理和分配这些资源，作业启动后 ApplicationMaster 又是如何定期向 RM 申请资源，接下来我们详细分析。</p>
<h1 id="1-YARN-资源调度方式"><a href="#1-YARN-资源调度方式" class="headerlink" title="1. YARN 资源调度方式"></a>1. YARN 资源调度方式</h1><p>资源调度方式确定了当任务提交到集群，如何为其分配资源执行任务。在 FairScheduler 中提供了两种资源调度方式：心跳调度和连续调度。</p>
<ul>
<li><strong>心跳调度方式：</strong>NodeManager 向 ResourceManager 汇报了自身资源情况（比如，当前可用资源，正在使用的资源，已经释放的资源)，这个 RPC 会触发 ResourceManager 调用 nodeUpdate() 方法，这个方法为这个节点进行一次资源调度，即，从维护的 Queue 中取出合适的应用的资源请求(合适 ，指的是这个资源请求既不违背队列的最大资源使用限制，也不违背这个 NodeManager 的剩余资源量限制)放到这个NodeManager上运行。这种调度方式一个主要缺点就是调度缓慢，当一个NodeManager即使已经有了剩余资源，调度也只能在心跳发送以后才会进行，不够及时。</li>
<li><strong>连续调度方式：</strong>由一个独立的线程 ContinuousSchedulingThread 负责进行持续的资源调度，与 NodeManager 的心跳是异步进行的。即不需要等到 NodeManager 发来心跳才开始资源调度。 </li>
</ul>
<p>无论是 NodeManager 心跳时触发调度，还是通过 ContinuousSchedulingThread 进行实时、持续触发，他们对某个节点进行一次调度的算法和原理是公用的，都是通过 synchronized void attemptScheduling(FSSchedulerNode node) 来在某个节点上进行一次调度，方法的的参数代表了准备进行资源分配的节点。两种触发机制不同的地方只有两个：</p>
<ul>
<li>调度时机：心跳调度仅仅发生在收到了某个 NodeManager 的心跳信息的情况下，持续调度则不依赖与NodeManager的心跳通信，是连续发生的，当心跳到来，会将调度结果直接返回给 NodeManager；</li>
<li>调度范围：心跳调度机制下，当收到某个节点的心跳，就对这个节点且仅仅对这个节点进行一次调度，即谁的心跳到来就触发对谁的调度，而持续调度的每一轮，是会遍历当前集群的所有节点，每个节点依次进行一次调度，保证一轮下来每一个节点都被公平的调度一次；</li>
</ul>
<p>在集群环境中，连续调度默认不开启，只有设置 YARN.scheduler.fair.continuous-scheduling-enabled 参数为 true，才会启动该线程。连续调度现在已经不推荐了，因为它会因为锁的问题，而导致资源调度变得缓慢。可以使用 YARN.scheduler.assignmultiple 参数启动批量分配功能，作为连续调度的替代。</p>
<h1 id="2-YARN-调度流程"><a href="#2-YARN-调度流程" class="headerlink" title="2. YARN 调度流程"></a>2. YARN 调度流程</h1><p>本文的调度流程主要介绍心跳调度的方式，下图是 YARN 心跳调度的主要流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/07/b7e1bab2bb03ef9579f700d67eba79f2-1372882-20200826170350663-775889568-dd9425.png" alt="img"></p>
<center>YARN 调度流程图</center>

<h2 id="2-1-名词解释"><a href="#2-1-名词解释" class="headerlink" title="2.1 名词解释"></a>2.1 名词解释</h2><ul>
<li>ResrouceSacheduler 是YARN 的调度器，负责 Container 的分配。下面主要是以 FairScheduler 调度器为例。</li>
<li>AsyncDispatcher 是单线程的事件分发器，负责向调度器发送调度事件。</li>
<li>ResourceTrackerService 是资源跟踪器，主要负责接收处理 NodeManager 的心跳信息。</li>
<li>ApplicationMasterService 是作业的 RPC 服务，主要负责接收处理作业的心跳信息。</li>
<li>AppMaster 是作业的程序控制器，负责跟 YARN 交互获取/释放资源。</li>
</ul>
<h2 id="2-2-调度流程"><a href="#2-2-调度流程" class="headerlink" title="2.2 调度流程"></a>2.2 调度流程</h2><p>YARN 的资源调度是异步进行的，NM 心跳发生时，调度器 ResourceScheduler 根据作业需求将 Container 资源分配给作业后，不会立即通知 AM，而是等待 AM 注册后通过心跳方式来主动获取。YARN 的整个调度流程可以概括为以下几个步骤：</p>
<ol>
<li>NM 节点通过心跳方式向 RM 汇报节点资源信息（包括当前可用资源、正在使用的资源、已经释放的资源)。</li>
<li>ResourceTrackerService 服务收到 NM 的心跳事件，将 NODE_UPDATE 事件交给 中央调度器 AsyncDispatcher 处理；</li>
<li>AsyncDispatcher 根据事件类型将请求转发给 ResourceScheduler 处理，ResourceScheduler 则按照一定的调度策略（队列层级调度）将 NM 的资源分配到 Container，并将 Container 保存在数据结构中；</li>
<li>ResourceScheduler 针对作业分配的第一个 Container 用于启动作业的 AM 进程；</li>
<li>AM 启动后，通过 ApplicationMasterService 定期向 RM 发生资源请求心跳，领取之前记录在 RM 中分配给自己的 Container 资源；</li>
<li>AM 向 NM 发送启动 Container 的命令，将收到的 Container 在 NM 上启动执行。</li>
</ol>
<p>其中，YARN 分配策略确定了在 NM 发生心跳时，如何在所有队列中选择合适的 APP 资源请求以为其分配资源。从上图队列层级结构可以看出一次 Container 的分配流程：每次分配从 root 节点开始，先从队列中选择合适的叶子队列，然后从队列的 APP 中选择合适的 APP，最后选择出该 APP 中合适的 Container 为其分配资源执行任务，选择过程如下：</p>
<ul>
<li><strong>选择队列 （排序）。</strong>从根队列开始，使用深度优先遍历算法，从根队列开始，依次遍历子队列找出资源占用率最小的子队列。若子队列为叶子队列，则选择该队列；若子队列为非叶子队列，则以该子队列为根队列重复前面的过程直到找到一个资源使用率最小的叶子队列为止。</li>
<li><strong>选择应用</strong> <strong>（排序）。</strong>在Step1中选好了叶子队列后，取该队列中排序最靠前的应用程序（排序逻辑可以根据应用程序的资源请求量、提交时间、作业名）。</li>
<li><strong>选择 Container （排序）。</strong>在 Step2中选好应用程序之后，选择该应用程序中优先级最高的 Container。对于优先级相同的 Containers，优选选择满足本地性的 Container，会依次选择 node local、rack local、no local。</li>
</ul>
<h1 id="3-FairScheduler-资源分配"><a href="#3-FairScheduler-资源分配" class="headerlink" title="3. FairScheduler 资源分配"></a>3. FairScheduler 资源分配</h1><h2 id="3-1-NM-心跳上报"><a href="#3-1-NM-心跳上报" class="headerlink" title="3.1 NM 心跳上报"></a>3.1 NM 心跳上报</h2><p>NM 中负责心跳的类是 NodeStatusUpdater 类型的成员变量 nodeStatusUpdater，在 NM 调用 serviceInit() 方法时被创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码：org/apache/hadoop/yarn/server/nodemanager/NodeManager.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serviceInit</span><span class="params">(Configuration conf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...  <span class="comment">// 省略</span></span><br><span class="line">    nodeStatusUpdater =</span><br><span class="line">        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);</span><br><span class="line">    ...  <span class="comment">// 省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> NodeStatusUpdater <span class="title">createNodeStatusUpdater</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">      Dispatcher dispatcher, NodeHealthCheckerService healthChecker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NodeStatusUpdaterImpl(context, dispatcher, healthChecker,</span><br><span class="line">      metrics);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>nodeStatusUpdater 在创建时初始化实例 NodeStatusUpdaterImpl，它是真正负责与 RM 通讯的类，其中 serviceStart() 方法中会进行 NM 注册和心跳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serviceStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NodeManager is the last service to start, so NodeId is available.</span></span><br><span class="line">    <span class="keyword">this</span>.nodeId = <span class="keyword">this</span>.context.getNodeId();</span><br><span class="line">    <span class="keyword">this</span>.httpPort = <span class="keyword">this</span>.context.getHttpPort();</span><br><span class="line">    <span class="keyword">this</span>.nodeManagerVersionId = YARNVersionInfo.getVersion();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Registration has to be in start so that ContainerManager can get the</span></span><br><span class="line">      <span class="comment">// perNM tokens needed to authenticate ContainerTokens.</span></span><br><span class="line">      <span class="keyword">this</span>.resourceTracker = getRMClient();</span><br><span class="line">      registerWithRM();         <span class="comment">// NM向RM注册</span></span><br><span class="line">      <span class="keyword">super</span>.serviceStart();</span><br><span class="line">      startStatusUpdater();     <span class="comment">// 独立线程进行NM心跳上报</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      String errorMessage = <span class="string">&quot;Unexpected error starting NodeStatusUpdater&quot;</span>;</span><br><span class="line">      LOG.error(errorMessage, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YARNRuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>NM 向 RM 注册逻辑直接跳过，重点看一下心跳逻辑，首先启动心跳线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startStatusUpdater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    statusUpdaterRunnable = <span class="keyword">new</span> Runnable() &#123; ... &#125;;</span><br><span class="line">    statusUpdater =</span><br><span class="line">        <span class="keyword">new</span> Thread(statusUpdaterRunnable, <span class="string">&quot;Node Status Updater&quot;</span>);</span><br><span class="line">    statusUpdater.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着来看看 statusUpdaterRunnable 线程如何进行心跳上报：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java</span></span><br><span class="line">    statusUpdaterRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastHeartBeatID = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isStopped) &#123;    <span class="comment">// 在被终止前死循环的跑</span></span><br><span class="line">          <span class="comment">// Send heartbeat</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            NodeHeartbeatResponse response = <span class="keyword">null</span>;</span><br><span class="line">            NodeStatus nodeStatus = getNodeStatus(lastHeartBeatID);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构建 request 请求信息</span></span><br><span class="line">            NodeHeartbeatRequest request =</span><br><span class="line">                NodeHeartbeatRequest.newInstance(nodeStatus,</span><br><span class="line">                  NodeStatusUpdaterImpl.<span class="keyword">this</span>.context</span><br><span class="line">                    .getContainerTokenSecretManager().getCurrentKey(),</span><br><span class="line">                  NodeStatusUpdaterImpl.<span class="keyword">this</span>.context.getNMTokenSecretManager()</span><br><span class="line">                    .getCurrentKey());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重点：这里向 RM 发送心跳 RPC 请求，并得到返回结果 response</span></span><br><span class="line">            response = resourceTracker.nodeHeartbeat(request);</span><br><span class="line">            <span class="comment">//get next heartbeat interval from response</span></span><br><span class="line">            nextHeartBeatInterval = response.getNextHeartBeatInterval();</span><br><span class="line">            updateMasterKeys(response);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (response.getNodeAction() == NodeAction.SHUTDOWN) &#123;</span><br><span class="line">              <span class="comment">// 处理 RM 返回的结果，包括停止运行和重新注册</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...  <span class="comment">// 省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>至此，NM 已经通过 NodeStatusUpdaterImpl 类向 RM 发送了心跳请求，那 RM 又如何处理该心跳请求呢？我们接着分析。</p>
<h2 id="3-2-RM-接收心跳"><a href="#3-2-RM-接收心跳" class="headerlink" title="3.2 RM 接收心跳"></a>3.2 RM 接收心跳</h2><p>NM 与 RM 通讯的接口是通过 ResourceTrackerService 服务来实现。直接来看看 NM 调用 nodeHeartbeat() 方法发送过来的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> NodeHeartbeatResponse <span class="title">nodeHeartbeat</span><span class="params">(NodeHeartbeatRequest request)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    NodeStatus remoteNodeStatus = request.getNodeStatus();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理心跳的流程：</span></span><br><span class="line"><span class="comment">     * 1. 判断是否是合法的 node（即是否被拉黑过）</span></span><br><span class="line"><span class="comment">     * 2. 判断是否是一个注册过的 node</span></span><br><span class="line"><span class="comment">     * 3. 判断这个心跳是否是重复的心跳</span></span><br><span class="line"><span class="comment">     * 4. 发送 NM 的状态给 RMNodeStatusEvent 事件处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 1-3 步跳过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Send status to RMNode, saving the latest response.</span></span><br><span class="line">    RMNodeStatusEvent nodeStatusEvent =</span><br><span class="line">        <span class="keyword">new</span> RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),</span><br><span class="line">          remoteNodeStatus.getContainersStatuses(),</span><br><span class="line">          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);</span><br><span class="line">    <span class="keyword">if</span> (request.getLogAggregationReportsForApps() != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; !request.getLogAggregationReportsForApps().isEmpty()) &#123;</span><br><span class="line">      nodeStatusEvent.setLogAggregationReportsForApps(request</span><br><span class="line">        .getLogAggregationReportsForApps());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodeHeartBeatResponse;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>心跳处理过程的关键是第 4 步，它会通过中央调度器 AsyncDispatcher 向 RM 发送 RMNodeStatusEvent 事件，那这个事件是由谁来处理的呢？在 YARN 这种事件处理逻辑很常见，关键点是要看事件对应的处理器是如何注册的。上面的 RMNodeStatusEvent 事件处理器继承自 RMNodeEvent，在 RM 的注册处理器代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java</span></span><br><span class="line">      <span class="comment">// Register event handler for RmNodes</span></span><br><span class="line">      rmDispatcher.register(</span><br><span class="line">          RMNodeEventType.class, <span class="keyword">new</span> NodeEventDispatcher(rmContext));</span><br></pre></td></tr></table></figure>

<p>其中 RMNodeStatusEvent 事件是交由 NodeEventDispatcher 调度器处理，处理的 handle() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(RMNodeEvent event)</span> </span>&#123;</span><br><span class="line">      NodeId nodeId = event.getNodeId();</span><br><span class="line">      RMNode node = <span class="keyword">this</span>.rmContext.getRMNodes().get(nodeId);</span><br><span class="line">      <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ((EventHandler&lt;RMNodeEvent&gt;) node).handle(event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          LOG.error(<span class="string">&quot;Error in handling event type &quot;</span> + event.getType()</span><br><span class="line">              + <span class="string">&quot; for node &quot;</span> + nodeId, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用 RMNode 的handle() 方法，RMNode 是一个接口类，实现类为 RMNodeImpl，对应 handle() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(RMNodeEvent event)</span> </span>&#123;</span><br><span class="line">  LOG.debug(<span class="string">&quot;Processing &quot;</span> + event.getNodeId() + <span class="string">&quot; of type &quot;</span> + event.getType());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    NodeState oldState = getState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       stateMachine.doTransition(event.getType(), event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidStateTransitonException e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Can&#x27;t handle this event at current state&quot;</span>, e);</span><br><span class="line">      LOG.error(<span class="string">&quot;Invalid event &quot;</span> + event.getType() + </span><br><span class="line">          <span class="string">&quot; on Node  &quot;</span> + <span class="keyword">this</span>.nodeId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldState != getState()) &#123;</span><br><span class="line">      LOG.info(nodeId + <span class="string">&quot; Node Transitioned from &quot;</span> + oldState + <span class="string">&quot; to &quot;</span></span><br><span class="line">               + getState());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就涉及到 RMNodeImpl 的状态机，由于 RMNodeStatusEvent 事件类型是 RMNodeEventType.STATUS_UPDATE，状态机中对这个事件的处理有三种情况：</p>
<ul>
<li>从 RUNNING 到 RUNNING、UNHEALTHY，调用 StatusUpdateWhenHealthyTransition；</li>
<li>从 DECOMMISSIONING 到 DECOMMISSIONING、DECOMMISSIONED，调用 StatusUpdateWhenHealthyTransition；</li>
<li>从 UNHEALTHY 到 UNHEALTHY、RUNNING，调用 StatusUpdateWhenUnHealthyTransition；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java</span></span><br><span class="line">      <span class="comment">//Transitions from RUNNING state</span></span><br><span class="line">      .addTransition(NodeState.RUNNING,</span><br><span class="line">          EnumSet.of(NodeState.RUNNING, NodeState.UNHEALTHY),</span><br><span class="line">          RMNodeEventType.STATUS_UPDATE,</span><br><span class="line">          <span class="keyword">new</span> StatusUpdateWhenHealthyTransition())</span><br><span class="line">      <span class="comment">//Transitions from DECOMMISSIONING state</span></span><br><span class="line">      .addTransition(NodeState.DECOMMISSIONING,</span><br><span class="line">          EnumSet.of(NodeState.DECOMMISSIONING, NodeState.DECOMMISSIONED),</span><br><span class="line">          RMNodeEventType.STATUS_UPDATE,</span><br><span class="line">          <span class="keyword">new</span> StatusUpdateWhenHealthyTransition())</span><br><span class="line">      <span class="comment">//Transitions from UNHEALTHY state</span></span><br><span class="line">      .addTransition(NodeState.UNHEALTHY,</span><br><span class="line">          EnumSet.of(NodeState.UNHEALTHY, NodeState.RUNNING),</span><br><span class="line">          RMNodeEventType.STATUS_UPDATE,</span><br><span class="line">          <span class="keyword">new</span> StatusUpdateWhenUnHealthyTransition())</span><br></pre></td></tr></table></figure>

<p>这里选择最常见的状态转换，从 RUNNING 到 RUNNING，查看被调用的 StatusUpdateWhenHealthyTransition 状态机的 transition() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NodeState <span class="title">transition</span><span class="params">(RMNodeImpl rmNode, RMNodeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      RMNodeStatusEvent statusEvent = (RMNodeStatusEvent) event;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Switch the last heartbeatresponse.</span></span><br><span class="line">      rmNode.latestNodeHeartBeatResponse = statusEvent.getLatestResponse();</span><br><span class="line"></span><br><span class="line">      NodeHealthStatus remoteNodeHealthStatus =</span><br><span class="line">          statusEvent.getNodeHealthStatus();</span><br><span class="line">      rmNode.setHealthReport(remoteNodeHealthStatus.getHealthReport());</span><br><span class="line">      rmNode.setLastHealthReportTime(</span><br><span class="line">          remoteNodeHealthStatus.getLastHealthReportTime());</span><br><span class="line">      NodeState initialState = rmNode.getState();</span><br><span class="line">      <span class="keyword">boolean</span> isNodeDecommissioning =</span><br><span class="line">          initialState.equals(NodeState.DECOMMISSIONING);</span><br><span class="line">      </span><br><span class="line">      ... <span class="comment">// 跳过 unhealthy 和 decommsission 的判断逻辑</span></span><br><span class="line"></span><br><span class="line">      rmNode.handleContainerStatus(statusEvent.getContainers());</span><br><span class="line"></span><br><span class="line">      List&lt;LogAggregationReport&gt; logAggregationReportsForApps =</span><br><span class="line">          statusEvent.getLogAggregationReportsForApps();</span><br><span class="line">      <span class="keyword">if</span> (logAggregationReportsForApps != <span class="keyword">null</span></span><br><span class="line">          &amp;&amp; !logAggregationReportsForApps.isEmpty()) &#123;</span><br><span class="line">        rmNode.handleLogAggregationStatus(logAggregationReportsForApps);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(rmNode.nextHeartBeat) &#123;</span><br><span class="line">        rmNode.nextHeartBeat = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 重点：向 RM 发送一个 NodeUpdateSchedulerEvent 事件</span></span><br><span class="line">        rmNode.context.getDispatcher().getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> NodeUpdateSchedulerEvent(rmNode));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Update DTRenewer in secure mode to keep these apps alive. Today this is</span></span><br><span class="line">      <span class="comment">// needed for log-aggregation to finish long after the apps are gone.</span></span><br><span class="line">      <span class="keyword">if</span> (UserGroupInformation.isSecurityEnabled()) &#123;</span><br><span class="line">        rmNode.context.getDelegationTokenRenewer().updateKeepAliveApplications(</span><br><span class="line">          statusEvent.getKeepAliveAppIds());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> initialState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里关键的逻辑是向 RM 发送了一个 NodeUpdateSchedulerEvent 事件，那这个事件又是谁处理的呢？NodeUpdateSchedulerEvent 继承自 SchedulerEvent，SchedulerEvent在RM中注册的处理器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/ResourceManager.java</span></span><br><span class="line">  <span class="comment">// 注册 SchedulerEventDispatcher</span></span><br><span class="line">  schedulerDispatcher = createSchedulerEventDispatcher();</span><br><span class="line">  addIfService(schedulerDispatcher);</span><br><span class="line">  rmDispatcher.register(SchedulerEventType.class, schedulerDispatcher);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> EventHandler&lt;SchedulerEvent&gt; <span class="title">createSchedulerEventDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SchedulerEventDispatcher(<span class="keyword">this</span>.scheduler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中 scheduler 对象是根据配置 YARN.resourcemanager.YARN.resourcemanager 指定的类生成的对象，这里使用 org.apache.hadoop.YARN.server.resourcemanager.scheduler.fair.FairScheduler。那就进入到 FairScheduler 的 handle() 方法，这里只看 NODE_UPDATE 事件的处理逻辑，其他的先省略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SchedulerEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = getClock().getTime();</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> NODE_ADDED:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_UPDATE:</span><br><span class="line">      <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> NodeUpdateSchedulerEvent)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unexpected event type: &quot;</span> + event);</span><br><span class="line">      &#125;</span><br><span class="line">      NodeUpdateSchedulerEvent nodeUpdatedEvent = (NodeUpdateSchedulerEvent)event;</span><br><span class="line">      nodeUpdate(nodeUpdatedEvent.getRMNode());</span><br><span class="line">      fsOpDurations.addHandleNodeUpdateEventDuration(getClock().getTime() - start);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> APP_ADDED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_RESOURCE_UPDATE: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_ADDED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_EXPIRED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESCHEDULED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOG.error(<span class="string">&quot;Unknown event arrived at FairScheduler: &quot;</span> + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于 NM 的心跳事件是 RMNodeEventType.STATUS_UPDATE，可以得知这里处理的事件类型为 SchedulerEventType.NODE_UPDATE，进入NODE_UPDATE处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nodeUpdate</span><span class="params">(RMNode nm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      writeLock.lock();</span><br><span class="line">      <span class="keyword">long</span> start = getClock().getTime();</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;nodeUpdate: &quot;</span> + nm +</span><br><span class="line">            <span class="string">&quot; cluster capacity: &quot;</span> + getClusterResource());</span><br><span class="line">      &#125;</span><br><span class="line">      eventLog.log(<span class="string">&quot;HEARTBEAT&quot;</span>, nm.getHostName());</span><br><span class="line">      FSSchedulerNode node = getFSSchedulerNode(nm.getNodeID());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Containe 状态更新：处理新运行或者运行完成的 Container</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断 NM 是否是 DECOMMISSIONING 状态</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 核心调度入口，无论是否开启连续调度入口都是 attemptScheduling(node) 方法</span></span><br><span class="line">      <span class="keyword">if</span> (continuousSchedulingEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedContainers.isEmpty()) &#123;</span><br><span class="line">          attemptScheduling(node);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        attemptScheduling(node);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> duration = getClock().getTime() - start;</span><br><span class="line">      fsOpDurations.addNodeUpdateDuration(duration);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看看核心调度入口，这里获取了一个 FSSchedulerNode 实例，并尝试进行调度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">attemptScheduling</span><span class="params">(FSSchedulerNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否是有效的 node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new containers...</span></span><br><span class="line">    <span class="comment">// 1. 检查是否有资源预留的应用</span></span><br><span class="line">    <span class="comment">// 2. 没有预留则进行调度分配新的 Container</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> validReservation = <span class="keyword">false</span>;</span><br><span class="line">    FSAppAttempt reservedAppSchedulable = node.getReservedAppSchedulable();</span><br><span class="line">    <span class="keyword">if</span> (reservedAppSchedulable != <span class="keyword">null</span>) &#123;</span><br><span class="line">      validReservation = reservedAppSchedulable.assignReservedContainer(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!validReservation) &#123;</span><br><span class="line">      <span class="comment">// No reservation, schedule at queue which is farthest below fair share</span></span><br><span class="line">      <span class="keyword">int</span> assignedContainers = <span class="number">0</span>;</span><br><span class="line">      Resource assignedResource = Resources.clone(Resources.none());</span><br><span class="line">      Resource maxResourcesToAssign =</span><br><span class="line">          Resources.multiply(node.getAvailableResource(), <span class="number">0.5f</span>);</span><br><span class="line">      <span class="keyword">while</span> (node.getReservedContainer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> assignedContainer = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 重点：核心分配逻辑开始，从 ROOT 队列开始调度</span></span><br><span class="line">        Resource assignment = queueMgr.getRootQueue().assignContainer(node);</span><br><span class="line">        <span class="keyword">if</span> (!assignment.equals(Resources.none())) &#123;</span><br><span class="line">          assignedContainers++;</span><br><span class="line">          assignedContainer = <span class="keyword">true</span>;</span><br><span class="line">          Resources.addTo(assignedResource, assignment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!assignedContainer) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!shouldContinueAssigning(assignedContainers,</span><br><span class="line">            maxResourcesToAssign, assignedResource)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateRootQueueMetrics();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>分配 Container 是从 ROOT 队列开始，这里调用 queueMgr.getRootQueue() 方法找到 ROOT 队列，然后调用 assignContainer(node) 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSParentQueue.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource <span class="title">assignContainer</span><span class="params">(FSSchedulerNode node)</span> </span>&#123;</span><br><span class="line">    Resource assigned = Resources.none();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果超过了队列的 maxShare 则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!assignContainerPreCheck(node)) &#123;</span><br><span class="line">      <span class="keyword">return</span> assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;FSQueue&gt; sortedChildQueues = <span class="keyword">new</span> TreeSet&lt;&gt;(policy.getComparator());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里对所有叶子队列进行排序，有两个情况需要考虑下：</span></span><br><span class="line"><span class="comment">     * 1. 新增加一个 queue，不影响结果的正确性，下次会处理新 queue</span></span><br><span class="line"><span class="comment">     * 2. 删除一个 queue，最好处理一下以不对该 queue 进行分配，不过目前没有处理，也没有影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sortedChildQueues.addAll(childQueues);</span><br><span class="line">        <span class="keyword">for</span> (FSQueue child : sortedChildQueues) &#123;</span><br><span class="line">        assigned = child.assignContainer(node);</span><br><span class="line">        <span class="keyword">if</span> (!Resources.equals(assigned, Resources.none())) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assigned;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里是 FSParentQueue 父队列的 assignContainer() 逻辑，对所有孩子节点进行遍历，递归调用该该方法，调用过程有两种情况：</p>
<ul>
<li>如果孩子节点是 FSParentQueue 父队列，则递归进入 FSParentQueue 类相同的逻辑中。</li>
<li>如果孩子节点是 FSLeafQueue 叶子队列，则进入到下一步的调用逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSLeafQueue.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource <span class="title">assignContainer</span><span class="params">(FSSchedulerNode node)</span> </span>&#123;</span><br><span class="line">    Resource assigned = none();</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Node &quot;</span> + node.getNodeName() + <span class="string">&quot; offered to queue: &quot;</span> +</span><br><span class="line">          getName() + <span class="string">&quot; fairShare: &quot;</span> + getFairShare());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否超过队列的 maxShare 限制</span></span><br><span class="line">    <span class="keyword">if</span> (!assignContainerPreCheck(node)) &#123;</span><br><span class="line">      <span class="keyword">return</span> assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历叶子节点所有有资源需求的 APP，并对其尝试分配 Container</span></span><br><span class="line">    <span class="keyword">for</span> (FSAppAttempt sched : fetchAppsWithDemand(<span class="keyword">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SchedulerAppUtils.isBlacklisted(sched, node, LOG)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      assigned = sched.assignContainer(node);</span><br><span class="line">      <span class="keyword">if</span> (!assigned.equals(none())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;Assigned container in queue:&quot;</span> + getName() + <span class="string">&quot; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;container:&quot;</span> + assigned);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assigned;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里获取叶子节点的 APP 调用了 fetchAppsWithDemand() 方法，该方法主要是对该队列所有 APP 进行遍历，找到真正有资源需求的 APP，过滤掉没有资源的 APP。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSLeafQueue.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TreeSet&lt;FSAppAttempt&gt; <span class="title">fetchAppsWithDemand</span><span class="params">(<span class="keyword">boolean</span> assignment)</span> </span>&#123;</span><br><span class="line">    TreeSet&lt;FSAppAttempt&gt; pendingForResourceApps =</span><br><span class="line">        <span class="keyword">new</span> TreeSet&lt;&gt;(policy.getComparator());</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (FSAppAttempt app : runnableApps) &#123;</span><br><span class="line">        <span class="comment">// 判断 APP 是否有资源需求，即有资源还没有得到满足</span></span><br><span class="line">        <span class="keyword">if</span> (!Resources.isNone(app.getPendingDemand()) &amp;&amp;</span><br><span class="line">            (assignment || app.shouldCheckForStarvation())) &#123;</span><br><span class="line">          pendingForResourceApps.add(app);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pendingForResourceApps;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>获取到叶子节点有资源需求的 APP 后，调用 FSAppAttempt 类的实例 assignContainer(node) 方法，进行接下来的分配逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource <span class="title">assignContainer</span><span class="params">(FSSchedulerNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里主要检查队列已使用资源是否达到了用于运行 AM 的资源限制</span></span><br><span class="line">    <span class="keyword">if</span> (isOverAMShareLimit()) &#123;</span><br><span class="line">      List&lt;ResourceRequest&gt; ask = appSchedulingInfo.getAllResourceRequests();</span><br><span class="line">      Resource amResourceRequest = Resources.none();</span><br><span class="line">      <span class="keyword">if</span> (!ask.isEmpty()) &#123;</span><br><span class="line">        amResourceRequest = ask.get(<span class="number">0</span>).getCapability();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;AM resource request: &quot;</span> + amResourceRequest</span><br><span class="line">            + <span class="string">&quot; exceeds maximum AM resource allowed, &quot;</span></span><br><span class="line">            + getQueue().dumpState());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Resources.none();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> assignContainer(node, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要检查队列已使用资源是否达到了用于运行 AM 的资源限制，如果没有的话，则继续调度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource <span class="title">assignContainer</span><span class="params">(FSSchedulerNode node, <span class="keyword">boolean</span> reserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">      LOG.trace(<span class="string">&quot;Node offered to app: &quot;</span> + getName() + <span class="string">&quot; reserved: &quot;</span> + reserved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 APP 的所有 ResourceRequest 按照 priority 排序</span></span><br><span class="line">    Collection&lt;Priority&gt; prioritiesToTry = (reserved) ?</span><br><span class="line">        Arrays.asList(node.getReservedContainer().getReservedPriority()) :</span><br><span class="line">        getPriorities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For each priority, see if we can schedule a node local, rack local</span></span><br><span class="line">    <span class="comment">// or off-switch request. Rack of off-switch requests may be delayed</span></span><br><span class="line">    <span class="comment">// (not scheduled) in order to promote better locality.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 按照 priority 从高到低遍历所有 ResourceRequest</span></span><br><span class="line">      <span class="keyword">for</span> (Priority priority : prioritiesToTry) &#123;</span><br><span class="line">        <span class="comment">// 判断该 Container 是否有预留</span></span><br><span class="line">        <span class="comment">// hasContainerForNode() 会分 node、rack、any 三种情况考虑该节点是否有合适的 Container</span></span><br><span class="line">        <span class="keyword">if</span> (!reserved &amp;&amp; !hasContainerForNode(priority, node)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度机会计数加 1</span></span><br><span class="line">        addSchedulingOpportunity(priority);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的逻辑主要根据 NODE_LOCAL、RACK_LOCAL、OFF_SWITCH 三种情况判断该 ResourceRequest 满足哪一种调度方式</span></span><br><span class="line">        ResourceRequest rackLocalRequest = getResourceRequest(priority,</span><br><span class="line">            node.getRackName());</span><br><span class="line">        ResourceRequest localRequest = getResourceRequest(priority,</span><br><span class="line">            node.getNodeName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localRequest != <span class="keyword">null</span> &amp;&amp; !localRequest.getRelaxLocality()) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Relax locality off is not supported on local request: &quot;</span></span><br><span class="line">              + localRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略三种情况的具体选择逻辑</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Resources.none();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，主要是按照 priority 从高到低的顺序遍历所有的 ResourceRequest，针对每个 ResourceRequest，在待分配的 node 节点上，根据 NODE_LOCAL、RACK_LOCAL、OFF_SWITCH 三种情况判断该 ResourceRequest 满足哪一种调度方式，这里以 NODE_LOCAL 参数为例进入到下一步的调度逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource <span class="title">assignContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      FSSchedulerNode node, ResourceRequest request, NodeType type,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> reserved)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 ResoureRequest 需要多少资源</span></span><br><span class="line">    Resource capability = request.getCapability();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 node 还剩多少资源可分配</span></span><br><span class="line">    Resource available = node.getAvailableResource();</span><br><span class="line"></span><br><span class="line">    Container reservedContainer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 判断是否有预留，有预留在直接从该 node 获取对应资源。这里不考虑预留的情况</span></span><br><span class="line">    <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">      reservedContainer = node.getReservedContainer().getContainer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该 ResourRequest 的资源需求是否能够在该 node 上得到满足</span></span><br><span class="line">    <span class="keyword">if</span> (Resources.fitsIn(capability, available)) &#123;</span><br><span class="line">      <span class="comment">// 重点：node 资源足够的话，这里会分配出一个 Container</span></span><br><span class="line">      RMContainer allocatedContainer =</span><br><span class="line">          allocate(type, node, request.getPriority(), request,</span><br><span class="line">              reservedContainer);</span><br><span class="line">      <span class="keyword">if</span> (allocatedContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Did the application need this resource?</span></span><br><span class="line">        <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">          unreserve(request.getPriority(), node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Resources.none();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we had previously made a reservation, delete it</span></span><br><span class="line">      <span class="keyword">if</span> (reserved) &#123;</span><br><span class="line">        unreserve(request.getPriority(), node);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通知 node 记录该分配出来的 Container</span></span><br><span class="line">      node.allocateContainer(allocatedContainer);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If not running unmanaged, the first container we allocate is always</span></span><br><span class="line">      <span class="comment">// the AM. Set the amResource for this app and update the leaf queue&#x27;s AM</span></span><br><span class="line">      <span class="comment">// usage</span></span><br><span class="line">      <span class="keyword">if</span> (!isAmRunning() &amp;&amp; !getUnmanagedAM()) &#123;</span><br><span class="line">        setAMResource(capability);</span><br><span class="line">        getQueue().addAMResourceUsage(capability);</span><br><span class="line">        setAmRunning(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> capability;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// 省略</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>重点看看分配逻辑 allocate() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FSAppAttempt.java</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> RMContainer <span class="title">allocate</span><span class="params">(NodeType type, FSSchedulerNode node,</span></span></span><br><span class="line"><span class="params"><span class="function">      Priority priority, ResourceRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">      Container reservedContainer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更新 locality 级别，忽略</span></span><br><span class="line">    NodeType allowed = allowedLocalityLevel.get(priority);</span><br><span class="line">    <span class="keyword">if</span> (allowed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (allowed.equals(NodeType.OFF_SWITCH) &amp;&amp;</span><br><span class="line">          (type.equals(NodeType.NODE_LOCAL) ||</span><br><span class="line">              type.equals(NodeType.RACK_LOCAL))) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resetAllowedLocalityLevel(priority, type);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (allowed.equals(NodeType.RACK_LOCAL) &amp;&amp;</span><br><span class="line">          type.equals(NodeType.NODE_LOCAL)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resetAllowedLocalityLevel(priority, type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Required sanity check - AM can call &#x27;allocate&#x27; to update resource</span></span><br><span class="line">    <span class="comment">// request without locking the scheduler, hence we need to check</span></span><br><span class="line">    <span class="keyword">if</span> (getTotalRequiredResources(priority) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Container container = reservedContainer;</span><br><span class="line">    <span class="keyword">if</span> (container == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 重点：这里会具体创建一个 Container 实例</span></span><br><span class="line">      container =</span><br><span class="line">          createContainer(node, request.getCapability(), request.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 RMContainer 记录新创建出来的 Container 实例</span></span><br><span class="line">    RMContainer rmContainer = <span class="keyword">new</span> RMContainerImpl(container,</span><br><span class="line">        getApplicationAttemptId(), node.getNodeID(),</span><br><span class="line">        appSchedulingInfo.getUser(), rmContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点：记录 rmContainer，等待下次 AM 心跳发生时，会从这里把分配出来的 Container 带走</span></span><br><span class="line">    newlyAllocatedContainers.add(rmContainer);</span><br><span class="line">    liveContainers.put(container.getId(), rmContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update consumption and track allocations</span></span><br><span class="line">    List&lt;ResourceRequest&gt; resourceRequestList = appSchedulingInfo.allocate(</span><br><span class="line">        type, node, priority, request, container);</span><br><span class="line">    Resources.addTo(currentConsumption, container.getResource());</span><br><span class="line">    getQueue().incUsedResource(container.getResource());</span><br><span class="line">    <span class="comment">// Update resource requests related to &quot;request&quot; and store in RMContainer</span></span><br><span class="line">    ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里发送 Container 的 START 事件，更新 Container 状态</span></span><br><span class="line">    rmContainer.handle(</span><br><span class="line">        <span class="keyword">new</span> RMContainerEvent(container.getId(), RMContainerEventType.START));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;allocate: applicationAttemptId=&quot;</span></span><br><span class="line">          + container.getId().getApplicationAttemptId()</span><br><span class="line">          + <span class="string">&quot; container=&quot;</span> + container.getId() + <span class="string">&quot; host=&quot;</span></span><br><span class="line">          + container.getNodeId().getHost() + <span class="string">&quot; type=&quot;</span> + type);</span><br><span class="line">    &#125;</span><br><span class="line">    RMAuditLogger.logSuccess(getUser(),</span><br><span class="line">        AuditConstants.ALLOC_CONTAINER, <span class="string">&quot;SchedulerApp&quot;</span>,</span><br><span class="line">        getApplicationId(), container.getId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rmContainer;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，一个全新的 Container 已经分配出来了，并保存在 RM 的内存数据结构中，那分配出来的 Container 是如何被用到的呢？我们接着后续的逻辑。</p>
<h2 id="3-3-AM-认领资源"><a href="#3-3-AM-认领资源" class="headerlink" title="3.3 AM 认领资源"></a><strong>3.3 AM 认领资源</strong></h2><p>上面知道，分配的 Container 已经保存在 RM 的内存数据结构中了，接下来就是 AM 的心跳上报定时领取给自己分配的资源。</p>
<h3 id="3-3-1-AM-启动并发起资源请求"><a href="#3-3-1-AM-启动并发起资源请求" class="headerlink" title="3.3.1 AM 启动并发起资源请求"></a><strong>3.3.1 AM 启动并发起资源请求</strong></h3><p>作业在启动时，会首先启动 ApplicationMaster 进程，启动入口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/YARN/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationMaster appMaster = <span class="keyword">new</span> ApplicationMaster();</span><br><span class="line">      LOG.info(<span class="string">&quot;Initializing ApplicationMaster&quot;</span>);</span><br><span class="line">      <span class="keyword">boolean</span> doRun = appMaster.init(args);</span><br><span class="line">      <span class="keyword">if</span> (!doRun) &#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ApplicationMaster 启动 run() 方法</span></span><br><span class="line">      appMaster.run();</span><br><span class="line">      result = appMaster.finish();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      LOG.fatal(<span class="string">&quot;Error running ApplicationMaster&quot;</span>, t);</span><br><span class="line">      LogManager.shutdown();</span><br><span class="line">      ExitUtil.terminate(<span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Application Master completed successfully. exiting&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Application Master failed. exiting&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>run() 方法做了什么事呢？主要是进行 ApplicationMaster 的注册和心跳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/YARN/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;Starting ApplicationMaster&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 AMRMClient 实例，用于向 RM 发送 RPC 请求，这里采用异步方式，每个 AMRMClient 都是单独的线程</span></span><br><span class="line">    AMRMClientAsync.CallbackHandler allocListener = <span class="keyword">new</span> RMCallbackHandler();</span><br><span class="line">    amRMClient = AMRMClientAsync.createAMRMClientAsync(<span class="number">1000</span>, allocListener);</span><br><span class="line">    amRMClient.init(conf);</span><br><span class="line">    amRMClient.start();</span><br><span class="line"></span><br><span class="line">    containerListener = createNMCallbackHandler();</span><br><span class="line">    nmClientAsync = <span class="keyword">new</span> NMClientAsyncImpl(containerListener);</span><br><span class="line">    nmClientAsync.init(conf);</span><br><span class="line">    nmClientAsync.start();</span><br><span class="line"></span><br><span class="line">    appMasterHostname = NetUtils.getHostname();</span><br><span class="line">    <span class="comment">// 重要：AM 通过 RPC 请求向 RM 注册，心跳线程在注册逻辑里启动</span></span><br><span class="line">    RegisterApplicationMasterResponse response = amRMClient</span><br><span class="line">        .registerApplicationMaster(appMasterHostname, appMasterRpcPort,</span><br><span class="line">            appMasterTrackingUrl);</span><br><span class="line">    ... <span class="comment">// 省略</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AM 向 RM 发送 RPC 请求是通过 ApplicationMasterService 服务实现的，这里的 AM 注册和心跳都需要通过该服务与 RM 进行通讯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/YARN/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RegisterApplicationMasterResponse <span class="title">registerApplicationMaster</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      String appHostName, <span class="keyword">int</span> appHostPort, String appTrackingUrl)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line">    RegisterApplicationMasterResponse response = client</span><br><span class="line">        .registerApplicationMaster(appHostName, appHostPort, appTrackingUrl);</span><br><span class="line">    <span class="comment">// 启动 AM 心跳线程</span></span><br><span class="line">    heartbeatThread.start();</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里忽略 registerApplicationMaster() 注册的逻辑，主要是心跳线程做了些什么，即 heartbeatThread 线程的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/YARN/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        AllocateResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// synchronization ensures we don&#x27;t send heartbeats after unregistering</span></span><br><span class="line">        <span class="keyword">synchronized</span> (unregisterHeartbeatLock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!keepRunning) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重要：AM 通过 AMRMClient 客户端向 RM 发送请求，进行资源的 allocate() 操作</span></span><br><span class="line">            response = client.allocate(progress);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ApplicationAttemptNotFoundException e) &#123;</span><br><span class="line">            handler.onShutdownRequest();</span><br><span class="line">            LOG.info(<span class="string">&quot;Shutdown requested. Stopping callback.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Exception on heartbeat&quot;</span>, ex);</span><br><span class="line">            savedException = ex;</span><br><span class="line">            <span class="comment">// interrupt handler thread in case it waiting on the queue</span></span><br><span class="line">            handlerThread.interrupt();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                responseQueue.put(response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Interrupted while waiting to put on response queue&quot;</span>, ex);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(heartbeatIntervalMs.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;Heartbeater interrupted&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，AM 已经向 RM 发送资源请求，接下来看看 RM 是如何处理这个 RPC 请求的。</p>
<h3 id="3-3-2-RM-处理-AM-请求"><a href="#3-3-2-RM-处理-AM-请求" class="headerlink" title="3.3.2 RM 处理 AM 请求"></a><strong>3.3.2 RM 处理 AM 请求</strong></h3><p>RM 中负责处理 AM 心跳请求是通过 ApplicationMasterService 服务，其内部的 allocate() 负责处理 AM 的 RPC 资源分配请求，具体逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AllocateResponse <span class="title">allocate</span><span class="params">(AllocateRequest request)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    AMRMTokenIdentifier amrmTokenIdentifier = authorizeRequest();</span><br><span class="line"></span><br><span class="line">    ApplicationAttemptId appAttemptId =</span><br><span class="line">        amrmTokenIdentifier.getApplicationAttemptId();</span><br><span class="line">    ApplicationId applicationId = appAttemptId.getApplicationId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.amLivelinessMonitor.receivedPing(appAttemptId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对每个 appAttempt，会有一个独立的锁对象</span></span><br><span class="line">    AllocateResponseLock lock = responseMap.get(appAttemptId);</span><br><span class="line">    <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">      String message =</span><br><span class="line">          <span class="string">&quot;Application attempt &quot;</span> + appAttemptId</span><br><span class="line">              + <span class="string">&quot; doesn&#x27;t exist in ApplicationMasterService cache.&quot;</span>;</span><br><span class="line">      LOG.error(message);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationAttemptNotFoundException(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      AllocateResponse lastResponse = lock.getAllocateResponse();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 省略一些神圣的检查工作</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重点：AM 资源请求的心跳函数，发送新请求和接收之前的分配都需要进行</span></span><br><span class="line">      Allocation allocation =</span><br><span class="line">          <span class="keyword">this</span>.rScheduler.allocate(appAttemptId, ask, release, </span><br><span class="line">              blacklistAdditions, blacklistRemovals);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略一些状态更新操作</span></span><br><span class="line">      </span><br><span class="line">      lock.setAllocateResponse(allocateResponse);</span><br><span class="line">      <span class="keyword">return</span> allocateResponse;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进 this.rScheduler.allocate() 方法，这里的 scheduler 配置的是 FairScheduler，来看看它的 allocate 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Allocation <span class="title">allocate</span><span class="params">(ApplicationAttemptId appAttemptId,</span></span></span><br><span class="line"><span class="params"><span class="function">      List&lt;ResourceRequest&gt; ask, List&lt;ContainerId&gt; release,</span></span></span><br><span class="line"><span class="params"><span class="function">      List&lt;String&gt; blacklistAdditions, List&lt;String&gt; blacklistRemovals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 跳过一些检查工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 Container 分配的开始开始时间</span></span><br><span class="line">    application.recordContainerRequestTime(getClock().getTime());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 AM 认为要释放的 Container</span></span><br><span class="line">    releaseContainers(release, application);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (application) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ask.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;allocate: pre-update&quot;</span> +</span><br><span class="line">              <span class="string">&quot; applicationAttemptId=&quot;</span> + appAttemptId +</span><br><span class="line">              <span class="string">&quot; application=&quot;</span> + application.getApplicationId());</span><br><span class="line">        &#125;</span><br><span class="line">        application.showRequests();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新应用的资源请求</span></span><br><span class="line">        application.updateResourceRequests(ask);</span><br><span class="line"></span><br><span class="line">        application.showRequests();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Set&lt;ContainerId&gt; preemptionContainerIds =</span><br><span class="line">          application.getPreemptionContainerIds();</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(</span><br><span class="line">            <span class="string">&quot;allocate: post-update&quot;</span> + <span class="string">&quot; applicationAttemptId=&quot;</span> + appAttemptId</span><br><span class="line">                + <span class="string">&quot; #ask=&quot;</span> + ask.size() + <span class="string">&quot; reservation= &quot;</span> + application</span><br><span class="line">                .getCurrentReservation());</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&quot;Preempting &quot;</span> + preemptionContainerIds.size()</span><br><span class="line">            + <span class="string">&quot; container(s)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (application.isWaitingForAMContainer(application.getApplicationId())) &#123;</span><br><span class="line">        <span class="comment">// Allocate is for AM and update AM blacklist for this</span></span><br><span class="line">        application.updateAMBlacklist(</span><br><span class="line">            blacklistAdditions, blacklistRemovals);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        application.updateBlacklist(blacklistAdditions, blacklistRemovals);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重要：这里就是 AM 获取最近分配的 Container。这里获取的其实就是前面保存在 RM 内存数据结构的 Container。</span></span><br><span class="line">      ContainersAndNMTokensAllocation allocation =</span><br><span class="line">          application.pullNewlyAllocatedContainersAndNMTokens();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Record container allocation time</span></span><br><span class="line">      <span class="keyword">if</span> (!(allocation.getContainerList().isEmpty())) &#123;</span><br><span class="line">        application.recordContainerAllocationTime(getClock().getTime());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Allocation(allocation.getContainerList(),</span><br><span class="line">        application.getHeadroom(), preemptionContainerIds, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">        allocation.getNMTokenList());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，AM 已经顺利拿到 RM 分配的 Container，整理 FairScheduler 资源分配流程基本就是这样。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://tech.meituan.com/2019/08/01/hadoop-YARN-scheduling-performance-optimization-practice.html">(美团)Hadoop YARN: 调度性能优化实践</a></li>
<li><a href="https://yoelee.github.io/2018/06/26/YARN%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/">YARN源码分析-资源调度</a></li>
<li><a href="https://blog.csdn.net/zhanyuanlin/article/details/78799131#">YARN资源请求处理和资源分配原理解析</a></li>
<li><a href="https://blog.csdn.net/iie_libi/article/details/71597753">YARN资源调度策略</a></li>
</ul>
]]></content>
      <categories>
        <category>YARN</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>YARN</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN RM与ZK交互源码分析及优化</title>
    <url>/2021/11/16/YARN-RM%E4%B8%8EZK%E4%BA%A4%E4%BA%92%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>线上集群出现过几次 YARN RM 写 ZK ZNode 的数据量超过 ZNode 限制，导致 RM 服务均进入 Standby 状态，用户无法正常提交任务，整个集群 hang 住，后续排查发现主要是异常任务写 ZNode 数据量太大，超过 ZNode 限制，导致集群其他提交作业的状态信息无法正常写入 ZNode，为避免类似问题再次出现，我们对 RM 写 ZNode 逻辑进行了优化，规避异常任务对整个集群造成的雪崩效应。</p>
<h1 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1. 问题复现"></a>1. 问题复现</h1><p>最直接方式是修改 ZK 的 Jute 最大缓冲区为 512 B，重启 ZK 和 Yarn 服务，此时 ZK 和 RM 服务均出现异常，ZK 异常信息表现为数据 java.io.IOException: Len error 614 客户端写入数据超过 512B 无法正常写入 ZK，RM 表现为 ”code:CONNECTIONLOSS“，无法连接到 ZK，两个 RM 均处于 Standy 状态，此时集群处于不可用状态。</p>
<p><strong>leader ZK 异常信息：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">2020-12-07 16:00:11,869 INFO org.apache.zookeeper.server.ZooKeeperServer: Client attempting to renew session 0x1763c3707800002 at /10.197.1.96:32892</span><br><span class="line">2020-12-07 16:00:11,869 INFO org.apache.zookeeper.server.ZooKeeperServer: Established session 0x1763c3707800002 with negotiated timeout 40000 for client /10.197.1.96:32892</span><br><span class="line">2020-12-07 16:00:11,870 WARN org.apache.zookeeper.server.NIOServerCnxn: Exception causing close of session 0x1763c3707800002 due to java.io.IOException: Len error 614</span><br><span class="line">2020-12-07 16:00:11,870 INFO org.apache.zookeeper.server.NIOServerCnxn: Closed socket connection for client /10.197.1.96:32892 which had sessionid 0x1763c3707800002</span><br><span class="line">2020-12-07 16:00:12,216 INFO org.apache.zookeeper.server.NIOServerCnxnFactory: Accepted socket connection from /10.197.1.141:56492</span><br><span class="line">2020-12-07 16:00:12,216 INFO org.apache.zookeeper.server.ZooKeeperServer: Client attempting to establish new session at /10.197.1.141:56492</span><br><span class="line">2020-12-07 16:00:12,218 INFO org.apache.zookeeper.server.ZooKeeperServer: Established session 0x3763c3707830001 with negotiated timeout 40000 for client /10.197.1.141:56492</span><br><span class="line">2020-12-07 16:00:12,219 WARN org.apache.zookeeper.server.NIOServerCnxn: Exception causing close of session 0x3763c3707830001 due to java.io.IOException: Len error 614</span><br><span class="line">2020-12-07 16:00:12,220 INFO org.apache.zookeeper.server.NIOServerCnxn: Closed socket connection for client /10.197.1.141:56492 which had sessionid 0x3763c3707830001</span><br><span class="line">2020-12-07 16:00:14,275 INFO org.apache.zookeeper.server.NIOServerCnxnFactory: Accepted socket connection from /10.197.1.141:56510</span><br><span class="line">2020-12-07 16:00:14,275 INFO org.apache.zookeeper.server.ZooKeeperServer: Client attempting to renew session 0x3763c3707830001 at /10.197.1.141:56510</span><br><span class="line">2020-12-07 16:00:14,276 INFO org.apache.zookeeper.server.ZooKeeperServer: Established session 0x3763c3707830001 with negotiated timeout 40000 for client /10.197.1.141:56510</span><br><span class="line">2020-12-07 16:00:14,276 WARN org.apache.zookeeper.server.NIOServerCnxn: Exception causing close of session 0x3763c3707830001 due to java.io.IOException: Len error 614</span><br><span class="line">2020-12-07 16:00:14,276 INFO org.apache.zookeeper.server.NIOServerCnxn: Closed socket connection for client /10.197.1.141:56510 which had sessionid 0x3763c3707830001</span><br><span class="line">2020-12-07 16:00:16,000 INFO org.apache.zookeeper.server.ZooKeeperServer: Expiring session 0x1763c3707800000, timeout of 5000ms exceeded</span><br></pre></td></tr></table></figure>

<p><strong>YARN RM 日志：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">2020-12-07 16:00:10,938 INFO org.apache.hadoop.ha.ActiveStandbyElector: Session connected.</span><br><span class="line">2020-12-07 16:00:10,938 INFO org.apache.hadoop.ha.ActiveStandbyElector: Ignore duplicate monitor lock-node request.</span><br><span class="line">2020-12-07 16:00:11,038 INFO org.apache.hadoop.ha.ActiveStandbyElector: Session disconnected. Entering neutral mode...</span><br><span class="line">2020-12-07 16:00:11,647 INFO org.apache.zookeeper.ClientCnxn: Opening socket connection to server slave-prd-10-197-1-236.v-bj-5.kwang.lan/10.197.1.236:2181. Will not attempt to authenticate using SASL (unknown error)</span><br><span class="line">2020-12-07 16:00:11,647 INFO org.apache.zookeeper.ClientCnxn: Socket connection established, initiating session, client: /10.197.1.141:56854, server: slave-prd-10-197-1-236.v-bj-5.kwang.lan/10.197.1.236:2181</span><br><span class="line">2020-12-07 16:00:11,649 INFO org.apache.zookeeper.ClientCnxn: Session establishment complete on server slave-prd-10-197-1-236.v-bj-5.kwang.lan/10.197.1.236:2181, sessionid = 0x1763c3707800001, negotiated timeout = 40000</span><br><span class="line">2020-12-07 16:00:11,649 INFO org.apache.hadoop.ha.ActiveStandbyElector: Session connected.</span><br><span class="line">2020-12-07 16:00:11,650 INFO org.apache.hadoop.ha.ActiveStandbyElector: Ignore duplicate monitor lock-node request.</span><br><span class="line">2020-12-07 16:00:11,650 INFO org.apache.zookeeper.ClientCnxn: Unable to read additional data from server sessionid 0x1763c3707800001, likely server has closed socket, closing socket connection and attempting reconnect</span><br><span class="line">2020-12-07 16:00:11,750 FATAL org.apache.hadoop.ha.ActiveStandbyElector: Received create error from Zookeeper. code:CONNECTIONLOSS for path /yarn-leader-election/yarnRM/ActiveStandbyElectorLock. Not retrying further znode create connection errors.</span><br><span class="line">2020-12-07 16:00:12,210 INFO org.apache.zookeeper.ZooKeeper: Session: 0x1763c3707800001 closed</span><br><span class="line">2020-12-07 16:00:12,212 WARN org.apache.hadoop.ha.ActiveStandbyElector: Ignoring stale result from old client with sessionId 0x1763c3707800001</span><br><span class="line">2020-12-07 16:00:12,212 WARN org.apache.hadoop.ha.ActiveStandbyElector: Ignoring stale result from old client with sessionId 0x1763c3707800001</span><br><span class="line">2020-12-07 16:00:12,212 INFO org.apache.zookeeper.ClientCnxn: EventThread shut down</span><br><span class="line">2020-12-07 16:00:12,213 ERROR org.apache.hadoop.yarn.server.resourcemanager.ResourceManager: Received RMFatalEvent of type EMBEDDED<span class="built_in">_</span>ELECTOR<span class="built_in">_</span>FAILED, caused by Received create error from Zookeeper. code:CONNECTIONLOSS for path /yarn-leader-election/yarnRM/ActiveStandbyElectorLock. Not retrying further znode create connection errors.</span><br><span class="line">2020-12-07 16:00:12,213 WARN org.apache.hadoop.yarn.server.resourcemanager.ResourceManager: Transitioning the resource manager to standby.</span><br><span class="line">2020-12-07 16:00:12,214 INFO org.apache.hadoop.yarn.server.resourcemanager.ResourceManager: Transitioning RM to Standby mode</span><br><span class="line">2020-12-07 16:00:12,214 INFO org.apache.hadoop.yarn.server.resourcemanager.ResourceManager: Already in standby state</span><br><span class="line">2020-12-07 16:00:12,214 INFO org.apache.hadoop.ha.ActiveStandbyElector: Yielding from electionÏ</span><br><span class="line">2020-12-07 16:00:12,214 INFO org.apache.zookeeper.ZooKeeper: Initiating client connection, connectString=slave-prd-10-197-1-236.v-bj-5.kwang.lan:2181,slave-prd-10-197-1-96.v-bj-5.kwang.lan:2181,slave-prd-10-197-1-141.v-bj-5.kwang.lan:2181 sessionTimeout=60000 watcher=org.apache.hadoop.ha.ActiveStandbyElector<span class="built_in">$</span>WatcherWithClientRef@67b6359c</span><br><span class="line">2020-12-07 16:00:12,215 INFO org.apache.zookeeper.ClientCnxn: Opening socket connection to server slave-prd-10-197-1-141.v-bj-5.kwang.lan/10.197.1.141:2181. Will not attempt to authenticate using SASL (unknown error)</span><br><span class="line">2020-12-07 16:00:12,216 INFO org.apache.zookeeper.ClientCnxn: Socket connection established, initiating session, client: /10.197.1.141:56492, server: slave-prd-10-197-1-141.v-bj-5.kwang.lan/10.197.1.141:2181</span><br><span class="line">2020-12-07 16:00:12,218 INFO org.apache.zookeeper.ClientCnxn: Session establishment complete on server slave-prd-10-197-1-141.v-bj-5.kwang.lan/10.197.1.141:2181, sessionid = 0x3763c3707830001, negotiated timeout = 40000</span><br><span class="line">2020-12-07 16:00:12,219 INFO org.apache.hadoop.ha.ActiveStandbyElector: Session connected.</span><br><span class="line">2020-12-07 16:00:12,220 INFO org.apache.zookeeper.ClientCnxn: Unable to read additional data from server sessionid 0x3763c3707830001, likely server has closed socket, closing socket connection and attempting reconnect</span><br><span class="line">2020-12-07 16:00:12,320 INFO org.apache.hadoop.ha.ActiveStandbyElector: Session disconnected. Entering neutral mode...</span><br><span class="line">2020-12-07 16:00:12,320 WARN org.apache.hadoop.yarn.server.resourcemanager.EmbeddedElectorService: Lost contact with Zookeeper. Transitioning to standby in 60000 ms if connection is not reestablished.</span><br></pre></td></tr></table></figure>

<h1 id="2-RM-与-ZNode-交互原理"><a href="#2-RM-与-ZNode-交互原理" class="headerlink" title="2. RM 与 ZNode 交互原理"></a>2. RM 与 ZNode 交互原理</h1><h2 id="2-1-RM-状态在-ZK-中的存储"><a href="#2-1-RM-状态在-ZK-中的存储" class="headerlink" title="2.1 RM 状态在 ZK 中的存储"></a>2.1 RM 状态在 ZK 中的存储</h2><p>不管 RM 是否启用了高可用，RM 作为 Yarn 的核心服务组件，不仅要与各个节点上的 ApplicationMaster 进行通信，还要与 NodeManager 进行心跳包的传输，自然在 RM 上会注册进来很多应用，每个应用由一个 ApplicationMaster 负责掌管整个应用周期，既然 RM 角色如此重要，就有必要保存一下 RM 的信息状态，以免 RM 进程异常退出后导致应用状态信息全部丢失，RM 重启无法重跑之前的任务。</p>
<p>既然应用状态信息要保存的目标易经明确了，那保存方式和保存的数据信息是什么呢。</p>
<p>在 Yarn 中 RM 应用状态信息保存的方式有四种：</p>
<ul>
<li><p>MemoryRMStateStore——信息状态保存在内存中的实现类。</p>
</li>
<li><p>FileSystemRMStateStore——信息状态保存在 HDFS 文件系统中，这个是做了持久化的。</p>
</li>
<li><p>NullRMStateStore——什么都不做，就是不保存应用状态信息。</p>
</li>
<li><p>ZKRMStateStore——信息状态保存在 Zookeeper 中。</p>
</li>
</ul>
<p>由于 YARN 启用了 RM HA，以上四种方式只能支持 ZKRMStateStore。</p>
<p>那 RM 在 ZK 中到底是存储了哪些信息状态呢？如下所示，是 ZK 中存储 RM 信息状态的目录格式，可以看出，ZK 中主要存储 Application（作业的状态信息）和 SECRET_MANAGER（作业的 TOKEN 信息）等。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ROOT<span class="built_in">_</span>DIR<span class="built_in">_</span>PATH</span><br><span class="line">  |--- VERSION<span class="built_in">_</span>INFO</span><br><span class="line">  |--- EPOCH<span class="built_in">_</span>NODE</span><br><span class="line">  |--- RM<span class="built_in">_</span>ZK<span class="built_in">_</span>FENCING<span class="built_in">_</span>LOCK</span><br><span class="line">  |--- RM<span class="built_in">_</span>APP<span class="built_in">_</span>ROOT</span><br><span class="line">  |     |----- (<span class="params">#</span>ApplicationId1)</span><br><span class="line">  |     |        |----- (<span class="params">#</span>ApplicationAttemptIds)</span><br><span class="line">  |     |</span><br><span class="line">  |     |----- (<span class="params">#</span>ApplicationId2)</span><br><span class="line">  |     |       |----- (<span class="params">#</span>ApplicationAttemptIds)</span><br><span class="line">  |     ....</span><br><span class="line">  |</span><br><span class="line">  |--- RM<span class="built_in">_</span>DT<span class="built_in">_</span>SECRET<span class="built_in">_</span>MANAGER<span class="built_in">_</span>ROOT</span><br><span class="line">  |----- RM<span class="built_in">_</span>DT<span class="built_in">_</span>SEQUENTIAL<span class="built_in">_</span>NUMBER<span class="built_in">_</span>ZNODE<span class="built_in">_</span>NAME</span><br><span class="line">  |----- RM<span class="built_in">_</span>DELEGATION<span class="built_in">_</span>TOKENS<span class="built_in">_</span>ROOT<span class="built_in">_</span>ZNODE<span class="built_in">_</span>NAME</span><br><span class="line">  |       |----- Token<span class="built_in">_</span>1</span><br><span class="line">  |       |----- Token<span class="built_in">_</span>2</span><br><span class="line">  |       ....</span><br><span class="line">  |</span><br><span class="line">  |----- RM<span class="built_in">_</span>DT<span class="built_in">_</span>MASTER<span class="built_in">_</span>KEYS<span class="built_in">_</span>ROOT<span class="built_in">_</span>ZNODE<span class="built_in">_</span>NAME</span><br><span class="line">  |      |----- Key<span class="built_in">_</span>1</span><br><span class="line">  |      |----- Key<span class="built_in">_</span>2</span><br><span class="line">  ....</span><br><span class="line">  |--- AMRMTOKEN<span class="built_in">_</span>SECRET<span class="built_in">_</span>MANAGER<span class="built_in">_</span>ROOT</span><br><span class="line">  |----- currentMasterKey</span><br><span class="line">  |----- nextMasterKey</span><br></pre></td></tr></table></figure>

<h2 id="2-2-ZK-存储-amp-更新-RM-信息状态逻辑"><a href="#2-2-ZK-存储-amp-更新-RM-信息状态逻辑" class="headerlink" title="2.2 ZK 存储&amp;更新 RM 信息状态逻辑"></a>2.2 ZK 存储&amp;更新 RM 信息状态逻辑</h2><p>作业提交到 YARN 上的入口，都是通过 YarnClient 这个接口 api 提交的，具体提交方法为 submitApplication()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/YarnClient.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ApplicationId <span class="title">submitApplication</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationSubmissionContext appContext)</span> <span class="keyword">throws</span> YarnException,</span></span><br><span class="line"><span class="function">      IOException</span>;</span><br></pre></td></tr></table></figure>



<p>作业提交后，会经过一些列的事件转换，请求到不同的状态机进行处理，而保存作业的状态机 StoreAppTransition 会对 APP 的状态进行保存，将其元数据存储到 ZK 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/RMStateStore.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeNewApplication</span><span class="params">(RMApp app)</span> </span>&#123;</span><br><span class="line">    ApplicationSubmissionContext context = app</span><br><span class="line">                                            .getApplicationSubmissionContext();</span><br><span class="line">    <span class="keyword">assert</span> context <span class="keyword">instanceof</span> ApplicationSubmissionContextPBImpl;</span><br><span class="line">    ApplicationStateData appState =</span><br><span class="line">        ApplicationStateData.newInstance(</span><br><span class="line">            app.getSubmitTime(), app.getStartTime(), context, app.getUser());</span><br><span class="line">    <span class="comment">// 向调度器发送 RMStateStoreEventType.STORE_APP 事件</span></span><br><span class="line">    dispatcher.getEventHandler().handle(<span class="keyword">new</span> RMStateStoreAppEvent(appState));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>这里向调度器发送 RMStateStoreEventType.STORE_APP 事件，并注册了 StoreAppTransition 状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/RMStateStore.java</span></span><br><span class="line">    .addTransition(RMStateStoreState.ACTIVE,</span><br><span class="line">          EnumSet.of(RMStateStoreState.ACTIVE, RMStateStoreState.FENCED),</span><br><span class="line">          RMStateStoreEventType.STORE_APP, <span class="keyword">new</span> StoreAppTransition())</span><br></pre></td></tr></table></figure>



<p>StoreAppTransition 状态机最终会调用 ZKRMStateStore#storeApplicationStateInternal() 方法，对 RM 的元数据在 ZK 中进行保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">storeApplicationStateInternal</span><span class="params">(ApplicationId appId,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationStateData appStateDataPB)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String nodeCreatePath = getNodePath(rmAppRoot, appId.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Storing info for app: &quot;</span> + appId + <span class="string">&quot; at: &quot;</span> + nodeCreatePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] appStateData = appStateDataPB.getProto().toByteArray();</span><br><span class="line">	createWithRetries(nodeCreatePath, appStateData, zkAcl,</span><br><span class="line">              CreateMode.PERSISTENT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>RM Application 的状态保存到 ZK 后，APP 状态最终会转化为 ACCETPED 状态 ，此时，会触发 StartAppAttemptTransition 状态机，对 AppAttemp 状态进行保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">storeApplicationAttemptStateInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationAttemptId appAttemptId,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationAttemptStateData attemptStateDataPB)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String appDirPath = getNodePath(rmAppRoot,</span><br><span class="line">        appAttemptId.getApplicationId().toString());</span><br><span class="line">    String nodeCreatePath = getNodePath(appDirPath, appAttemptId.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Storing info for attempt: &quot;</span> + appAttemptId + <span class="string">&quot; at: &quot;</span></span><br><span class="line">          + nodeCreatePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] attemptStateData = attemptStateDataPB.getProto().toByteArray();</span><br><span class="line">	createWithRetries(nodeCreatePath, attemptStateData, zkAcl,</span><br><span class="line">					CreateMode.PERSISTENT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>而在任务运行结束时，会对 Application 和 AppAttemp 的状态进行更新。而更新操作也是容易出现异常的地方，这两段代码主要是执行更新或添加任务重试状态信息到 ZK 中的操作，YARN 在调度任务的过程中，可能会对任务进行多次重试，主要受网络、硬件、资源等因素影响，如果任务重试信息保存在 ZK 失败，会调用 ZKRMStateStore.ZKAction 类的 runWithRetries() 方法重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java </span></span><br><span class="line">  <span class="comment">// 对 Application 状态进行更新</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateApplicationStateInternal</span><span class="params">(ApplicationId appId,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationStateData appStateDataPB)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String nodeUpdatePath = getNodePath(rmAppRoot, appId.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Storing final state info for app: &quot;</span> + appId + <span class="string">&quot; at: &quot;</span></span><br><span class="line">          + nodeUpdatePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] appStateData = appStateDataPB.getProto().toByteArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existsWithRetries(nodeUpdatePath, <span class="keyword">false</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setDataWithRetries(nodeUpdatePath, appStateData, -<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// retry 是会调用到 ZKRMStateStore.ZKAction#runWithRetries() 方法</span></span><br><span class="line">      createWithRetries(nodeUpdatePath, appStateData, zkAcl,</span><br><span class="line">              CreateMode.PERSISTENT);</span><br><span class="line">      LOG.debug(appId + <span class="string">&quot; znode didn&#x27;t exist. Created a new znode to&quot;</span></span><br><span class="line">              + <span class="string">&quot; update the application state.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 AppAttemp 状态进行更新</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateApplicationAttemptStateInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationAttemptId appAttemptId,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationAttemptStateData attemptStateDataPB)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String appIdStr = appAttemptId.getApplicationId().toString();</span><br><span class="line">    String appAttemptIdStr = appAttemptId.toString();</span><br><span class="line">    String appDirPath = getNodePath(rmAppRoot, appIdStr);</span><br><span class="line">    String nodeUpdatePath = getNodePath(appDirPath, appAttemptIdStr);</span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Storing final state info for attempt: &quot;</span> + appAttemptIdStr</span><br><span class="line">          + <span class="string">&quot; at: &quot;</span> + nodeUpdatePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] attemptStateData = attemptStateDataPB.getProto().toByteArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existsWithRetries(nodeUpdatePath, <span class="keyword">false</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      setDataWithRetries(nodeUpdatePath, attemptStateData, -<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWithRetries(nodeUpdatePath, attemptStateData, zkAcl,</span><br><span class="line">              CreateMode.PERSISTENT);</span><br><span class="line">      LOG.debug(appAttemptId + <span class="string">&quot; znode didn&#x27;t exist. Created a new znode to&quot;</span></span><br><span class="line">              + <span class="string">&quot; update the application attempt state.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>在启用 YARN 高可用情况下，重试间隔机制如下：受 yarn.resourcemanager.zk-timeout-ms（ZK会话超时时间，线上 1 分钟，即 60000ms）和 yarn.resourcemanager.zk-num-retries（操作失败后重试次数，线上环境 1000次）参数控制，计算公式为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">重试时间间隔（yarn.resourcemanager.zk-retry-interval-ms ）=yarn.resourcemanager.zk-timeout-ms(ZK session超时时间)/yarn.resourcemanager.zk-num-retries（重试次数）</span><br></pre></td></tr></table></figure>

<p>即在生产环境中，重试时间间隔 = 600000ms /1000次 = 60 ms/次，即线上环境在任务不成功的条件下，会重试 1000 次，每次 60 ms，这里也可能会导致 RM 堆内存溢出。参考资料：<a href="https://my.oschina.net/dabird/blog/3089265%E3%80%82">https://my.oschina.net/dabird/blog/3089265。</a></p>
<p>重试间隔确定代码如下，在 ZKRMStateStore 类 serviceInit() 初始化中被设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java  </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">(Configuration conf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zkHostPort = conf.get(YarnConfiguration.RM_ZK_ADDRESS);</span><br><span class="line">    <span class="keyword">if</span> (zkHostPort == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;No server address specified for &quot;</span> +</span><br><span class="line">          <span class="string">&quot;zookeeper state store for Resource Manager recovery. &quot;</span> +</span><br><span class="line">          YarnConfiguration.RM_ZK_ADDRESS + <span class="string">&quot; is not configured.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ZK 连接重试次数</span></span><br><span class="line">    numRetries =</span><br><span class="line">        conf.getInt(YarnConfiguration.RM_ZK_NUM_RETRIES,</span><br><span class="line">            YarnConfiguration.DEFAULT_ZK_RM_NUM_RETRIES);</span><br><span class="line">    znodeWorkingPath =</span><br><span class="line">        conf.get(YarnConfiguration.ZK_RM_STATE_STORE_PARENT_PATH,</span><br><span class="line">            YarnConfiguration.DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZK session 超时时间</span></span><br><span class="line">    zkSessionTimeout =</span><br><span class="line">        conf.getInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,</span><br><span class="line">            YarnConfiguration.DEFAULT_RM_ZK_TIMEOUT_MS);</span><br><span class="line">    zknodeLimit =</span><br><span class="line">        conf.getInt(YarnConfiguration.RM_ZK_ZNODE_SIZE_LIMIT_BYTES,</span><br><span class="line">            YarnConfiguration.DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAUtil.isHAEnabled(conf)) &#123;</span><br><span class="line">      zkRetryInterval = zkSessionTimeout / numRetries;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      zkRetryInterval =</span><br><span class="line">          conf.getLong(YarnConfiguration.RM_ZK_RETRY_INTERVAL_MS,</span><br><span class="line">              YarnConfiguration.DEFAULT_RM_ZK_RETRY_INTERVAL_MS);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们已经清楚了 RM 中作业的信息状态是如何保存在 ZK 中并如何进行更新的。</p>
<h2 id="2-3-ZK-删除-RM-信息状态逻辑"><a href="#2-3-ZK-删除-RM-信息状态逻辑" class="headerlink" title="2.3 ZK 删除 RM 信息状态逻辑"></a>2.3 ZK 删除 RM 信息状态逻辑</h2><p>在了解了 RM 作业信息状态保存在 ZK 的逻辑后，我们便会产生一个疑问，那 RM 状态保存在 ZK 中后，是否会一直驻留在 ZK 中呢？答案是否定的，ZK 也会对作业的状态进行删除，那删除逻辑是这样的呢？</p>
<p>删除的核心逻辑位于 RMAppManager#checkAppNumCompletedLimit() 方法中调用的 removeApplication() 方法，其逻辑就是判断保存在 ZK StateStore 中或已完成的作业数量超过对应限制，则对 App 状态信息进行删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * check to see if hit the limit for max # completed apps kept</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">checkAppNumCompletedLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check apps kept in state store.</span></span><br><span class="line">    <span class="keyword">while</span> (completedAppsInStateStore &gt; <span class="keyword">this</span>.maxCompletedAppsInStateStore) &#123;</span><br><span class="line">      ApplicationId removeId =</span><br><span class="line">          completedApps.get(completedApps.size() - completedAppsInStateStore);</span><br><span class="line">      RMApp removeApp = rmContext.getRMApps().get(removeId);</span><br><span class="line">      LOG.info(<span class="string">&quot;Max number of completed apps kept in state store met:&quot;</span></span><br><span class="line">          + <span class="string">&quot; maxCompletedAppsInStateStore = &quot;</span> + maxCompletedAppsInStateStore</span><br><span class="line">          + <span class="string">&quot;, removing app &quot;</span> + removeApp.getApplicationId()</span><br><span class="line">          + <span class="string">&quot; from state store.&quot;</span>);</span><br><span class="line">      rmContext.getStateStore().removeApplication(removeApp);</span><br><span class="line">      completedAppsInStateStore--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check apps kept in memorty.</span></span><br><span class="line">    <span class="keyword">while</span> (completedApps.size() &gt; <span class="keyword">this</span>.maxCompletedAppsInMemory) &#123;</span><br><span class="line">      ApplicationId removeId = completedApps.remove();</span><br><span class="line">      LOG.info(<span class="string">&quot;Application should be expired, max number of completed apps&quot;</span></span><br><span class="line">          + <span class="string">&quot; kept in memory met: maxCompletedAppsInMemory = &quot;</span></span><br><span class="line">          + <span class="keyword">this</span>.maxCompletedAppsInMemory + <span class="string">&quot;, removing app &quot;</span> + removeId</span><br><span class="line">          + <span class="string">&quot; from memory: &quot;</span>);</span><br><span class="line">      rmContext.getRMApps().remove(removeId);</span><br><span class="line">      <span class="keyword">this</span>.applicationACLsManager.removeApplication(removeId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>可以看看相关参数是如何设置的，其中保存在 ZK StateStore 中和保存在 Memory 的 App 最大数量是一致的，默认是 10000（线上环境默认也是 10000），且保存在 ZK StateSotre 中的作业数量不能超过保存在 Memory 中的作业数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RMAppManager</span><span class="params">(RMContext context,</span></span></span><br><span class="line"><span class="params"><span class="function">      YarnScheduler scheduler, ApplicationMasterService masterService,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationACLsManager applicationACLsManager, Configuration conf)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保存在 Memory 中的 App 最大数量</span></span><br><span class="line">    <span class="keyword">this</span>.maxCompletedAppsInMemory = conf.getInt(</span><br><span class="line">        YarnConfiguration.RM_MAX_COMPLETED_APPLICATIONS,</span><br><span class="line">        YarnConfiguration.DEFAULT_RM_MAX_COMPLETED_APPLICATIONS);</span><br><span class="line">    <span class="comment">// 保存在 ZK StateStore 中的 App 最大数量，默认和 Memory 中的最大值保存一致</span></span><br><span class="line">    <span class="keyword">this</span>.maxCompletedAppsInStateStore =</span><br><span class="line">        conf.getInt(</span><br><span class="line">          YarnConfiguration.RM_STATE_STORE_MAX_COMPLETED_APPLICATIONS,</span><br><span class="line">          YarnConfiguration.DEFAULT_RM_STATE_STORE_MAX_COMPLETED_APPLICATIONS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存在 ZK StateStore 中的 App 数量不能超过保存在 Memory 中的 App 数量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.maxCompletedAppsInStateStore &gt; <span class="keyword">this</span>.maxCompletedAppsInMemory) &#123;</span><br><span class="line">      <span class="keyword">this</span>.maxCompletedAppsInStateStore = <span class="keyword">this</span>.maxCompletedAppsInMemory;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/conf/YarnConfiguration.java</span></span><br><span class="line">  <span class="comment">// maxCompletedAppsInMemory 参数定义</span></span><br><span class="line">  <span class="comment">/** The maximum number of completed applications RM keeps. */</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RM_MAX_COMPLETED_APPLICATIONS =</span><br><span class="line">    RM_PREFIX + <span class="string">&quot;max-completed-applications&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_RM_MAX_COMPLETED_APPLICATIONS = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// maxCompletedAppsInStateStore 参数定义，默认和 maxCompletedAppsInMemory 保持一致</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The maximum number of completed applications RM state store keeps, by</span></span><br><span class="line"><span class="comment">   * default equals to DEFAULT_RM_MAX_COMPLETED_APPLICATIONS</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RM_STATE_STORE_MAX_COMPLETED_APPLICATIONS =</span><br><span class="line">      RM_PREFIX + <span class="string">&quot;state-store.max-completed-applications&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_RM_STATE_STORE_MAX_COMPLETED_APPLICATIONS =</span><br><span class="line">      DEFAULT_RM_MAX_COMPLETED_APPLICATIONS;</span><br></pre></td></tr></table></figure>



<p>执行真正的删除操作，删除在 ZK 中保存的超出限制的 App 状态信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeApplicationStateInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationStateData  appState)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String appId = appState.getApplicationSubmissionContext().getApplicationId()</span><br><span class="line">        .toString();</span><br><span class="line">    String appIdRemovePath = getNodePath(rmAppRoot, appId);</span><br><span class="line">    ArrayList&lt;Op&gt; opList = <span class="keyword">new</span> ArrayList&lt;Op&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除在 ZK 中保存的 AppAttempt 信息</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationAttemptId attemptId : appState.attempts.keySet()) &#123;</span><br><span class="line">      String attemptRemovePath = getNodePath(appIdRemovePath, attemptId.toString());</span><br><span class="line">      opList.add(Op.delete(attemptRemovePath, -<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    opList.add(Op.delete(appIdRemovePath, -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Removing info for app: &quot;</span> + appId + <span class="string">&quot; at: &quot;</span> + appIdRemovePath</span><br><span class="line">          + <span class="string">&quot; and its attempts.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除在 ZK 中保存的 Applicaton 信息</span></span><br><span class="line">    doDeleteMultiWithRetries(opList);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-技术方案调研及优化"><a href="#3-技术方案调研及优化" class="headerlink" title="3. 技术方案调研及优化"></a>3. 技术方案调研及优化</h1><h2 id="3-1-Hadoop-2-9-0之前修复方法"><a href="#3-1-Hadoop-2-9-0之前修复方法" class="headerlink" title="3.1 Hadoop 2.9.0之前修复方法"></a>3.1 Hadoop 2.9.0之前修复方法</h2><p>RM 状态在 ZK 存储的过程中，RM 作为客户端，ZK 作为服务端，在 Hadoop 2.9.0 版本之前，出现这种异常的处理方式为修改 ZK 端 <code>jute.maxbuffer</code> 参数的值，以增加 RM 作业允许写 ZK 的最大值。但这种处理方式有三种不足：</p>
<ol>
<li><p>ZK 服务端允许写入的 ZNode 数据量太大，会影响 ZK 服务的读写性能和 ZK 内存紧张；</p>
</li>
<li><p>需要重启 ZK 服务端和客户端 RM 服务，运维成本较高。（如果有其他服务依赖此 ZK 则成本更高，可能还需要重启其他服务）</p>
</li>
<li><p>异常任务写 ZNode 数据量不可控，某些情况下还是会发生写入 ZNode 大小超过限制。</p>
</li>
</ol>
<p><strong>Q：为什么要限制 ZK 中 ZNode 大小？</strong></p>
<p>A：ZK 是一套高吞吐量的系统，为了提高系统的读取速度，ZK不允许从文件中读取需要的数据，而是直接从内存中查找。换句话说，ZK 集群中每一台服务器都包含全量的数据，并且这些数据都会加载到内存中，同时 ZNode 的数据不支持 Append 操作，全部都是 Replace 操作。如果 ZNode 数据量过大，那么读写 ZNode 将造成不确定的延时（比如服务端同步数据慢），同时 ZNode 太大会消耗 ZK 服务器的内存，这也是为什么 ZK 不适合存储大量数据的原因。</p>
<h2 id="3-2-Hadoop-2-9-0及后续版本修复方法"><a href="#3-2-Hadoop-2-9-0及后续版本修复方法" class="headerlink" title="3.2 Hadoop 2.9.0及后续版本修复方法"></a>3.2 Hadoop 2.9.0及后续版本修复方法</h2><p>在 Hadoop 2.9.0 及后续版本中，yarn-site.xml 中增加了 <code>yarn.resourcemanager.zk-max-znode-size.bytes</code> 参数，该参数定义了 ZK 的 ZNode 节点所能存储的最大数据量，以字节为单位，默认是 1024*1024 字节，也就是 1MB。使用这种方式，我们就不需要修改 ZK 的服务端的配置，而只需修改 Yarn 服务端的配置并重启 RM 服务，就能限制 RM 往 ZK 中写入的数据量，而且也提高了 ZK 服务的可用性。</p>
<h1 id="4-优化及测试"><a href="#4-优化及测试" class="headerlink" title="4. 优化及测试"></a>4. 优化及测试</h1><h2 id="4-1-优化方案"><a href="#4-1-优化方案" class="headerlink" title="4.1 优化方案"></a>4.1 优化方案</h2><p>优化思路主要是采用 Hadoop 2.9.0 之后的方式，核心主要是在 ZKRMStateStore 类中的 <code>storeApplicationStateInternal()</code>、<code>updateApplicationStateInternal()</code>、<code>storeApplicationAttemptStateInternal()</code>、<code>updateApplicationAttemptStateInternal()</code> 方法逻辑中增加了是否超过写 ZNode 大小限制的判断，避免单个作业写 ZNode 数据量过大导致 RM 和 ZK 服务的不可用。部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java </span></span><br><span class="line">  <span class="comment">// Application 写 ZNode 时判断大小限制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">storeApplicationStateInternal</span><span class="params">(ApplicationId appId,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationStateData appStateDataPB)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String nodeCreatePath = getNodePath(rmAppRoot, appId.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Storing info for app: &quot;</span> + appId + <span class="string">&quot; at: &quot;</span> + nodeCreatePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] appStateData = appStateDataPB.getProto().toByteArray();</span><br><span class="line">    <span class="keyword">if</span> (appStateData.length &lt;= zknodeLimit) &#123;</span><br><span class="line">      createWithRetries(nodeCreatePath, appStateData, zkAcl,</span><br><span class="line">              CreateMode.PERSISTENT);</span><br><span class="line">      LOG.debug(<span class="string">&quot;Store application state data size for &quot;</span> + appId + <span class="string">&quot; is &quot;</span> + appStateData.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Store application state data size for &quot;</span> + appId + <span class="string">&quot; is &quot;</span> + appStateData.length +</span><br><span class="line">        <span class="string">&quot;. exceeds the maximum allowed size &quot;</span> + zknodeLimit + <span class="string">&quot; for application data.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Application 状态更新时判断写 ZNode 大小</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateApplicationStateInternal</span><span class="params">(ApplicationId appId,</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationStateData appStateDataPB)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String nodeUpdatePath = getNodePath(rmAppRoot, appId.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Storing final state info for app: &quot;</span> + appId + <span class="string">&quot; at: &quot;</span></span><br><span class="line">          + nodeUpdatePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] appStateData = appStateDataPB.getProto().toByteArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (appStateData.length &lt;= zknodeLimit) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existsWithRetries(nodeUpdatePath, <span class="keyword">false</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        setDataWithRetries(nodeUpdatePath, appStateData, -<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createWithRetries(nodeUpdatePath, appStateData, zkAcl,</span><br><span class="line">                CreateMode.PERSISTENT);</span><br><span class="line">        LOG.debug(appId + <span class="string">&quot; znode didn&#x27;t exist. Created a new znode to&quot;</span></span><br><span class="line">                + <span class="string">&quot; update the application state.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      LOG.debug(<span class="string">&quot;Update application state data size for &quot;</span> + appId + <span class="string">&quot; is &quot;</span> + appStateData.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Update application state data size for &quot;</span> + appId + <span class="string">&quot; is &quot;</span> + appStateData.length +</span><br><span class="line">              <span class="string">&quot;. exceeds the maximum allowed size &quot;</span> + zknodeLimit + <span class="string">&quot; for application data.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-验证测试"><a href="#4-2-验证测试" class="headerlink" title="4.2 验证测试"></a>4.2 验证测试</h2><p>设置 Yarn app 允许写 ZNode 的最大值（由于是测试环境，上限限制得比较小），重启 active RM。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">参数：yarn-site.xml 的 ResourceManager 高级配置代码段（安全阀）</span><br><span class="line">值：</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.zk-max-znode-size.bytes&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;512&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>测试任务：</p>
<p>hadoop jar /opt/cloudera/parcels/CDH-5.14.4-1.cdh5.14.4.p0.3/jars/hadoop-mapreduce-examples-2.6.0-cdh5.14.4.jar  pi -Dmapred.job.queue.name=root.exquery 20 10</p>
<p>任务失败时 RM 任务日志如下，可以看出作业状态信息保存在 ZK 的数据超过了 ZNode 限制，此时 ZK 不会保存该作业的状态信息，而 ZK 服务和 RM 服务均是正常对外提供服务的，不影响集群的正常使用。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> tailf hadoop-cmf-yarn-RESOURCEMANAGER-slave-prd-10-197-1-141.v-bj-5.kwang.log.out  |grep &quot;the maximum allowed size&quot;</span><br><span class="line">2020-12-10 16:53:37,544 INFO org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore: Application state data size for application<span class="built_in">_</span>1607589684539<span class="built_in">_</span>0001 is 1515. exceeds the maximum allowed size 512 for application data.</span><br><span class="line">2020-12-10 16:53:48,086 INFO org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore: Application state data size for application<span class="built_in">_</span>1607590418121<span class="built_in">_</span>0001 is 1515. exceeds the maximum allowed size 512 for application data.</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> RM 具体 Warn 信息：</span><br><span class="line">2020-12-10 16:53:49,377 WARN org.apache.hadoop.security.UserGroupInformation: PriviledgedActionException as:kwang (auth:SIMPLE) cause:org.apache.hadoop.yarn.exceptions.ApplicationNotFoundException: Application with id &#x27;application<span class="built_in">_</span>1607590418121<span class="built_in">_</span>0001&#x27; doesn&#x27;t exist in RM.</span><br><span class="line">2020-12-10 16:53:49,377 INFO org.apache.hadoop.ipc.Server: IPC Server handler 0 on 8032, call org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.getApplicationReport from 10.197.1.141:56026 Call<span class="params">#6</span>3 Retry<span class="params">#0</span></span><br><span class="line">org.apache.hadoop.yarn.exceptions.ApplicationNotFoundException: Application with id &#x27;application<span class="built_in">_</span>1607590418121<span class="built_in">_</span>0001&#x27; doesn&#x27;t exist in RM.</span><br><span class="line">        at org.apache.hadoop.yarn.server.resourcemanager.ClientRMService.getApplicationReport(ClientRMService.java:324)</span><br><span class="line">        at org.apache.hadoop.yarn.api.impl.pb.service.ApplicationClientProtocolPBServiceImpl.getApplicationReport(ApplicationClientProtocolPBServiceImpl.java:170)</span><br><span class="line">        at org.apache.hadoop.yarn.proto.ApplicationClientProtocol<span class="built_in">$</span>ApplicationClientProtocolService<span class="built_in">$</span>2.callBlockingMethod(ApplicationClientProtocol.java:401)</span><br><span class="line">        at org.apache.hadoop.ipc.ProtobufRpcEngine<span class="built_in">$</span>Server<span class="built_in">$</span>ProtoBufRpcInvoker.call(ProtobufRpcEngine.java:617)</span><br><span class="line">        at org.apache.hadoop.ipc.RPC<span class="built_in">$</span>Server.call(RPC.java:1073)</span><br><span class="line">        at org.apache.hadoop.ipc.Server<span class="built_in">$</span>Handler<span class="built_in">$</span>1.run(Server.java:2281)</span><br><span class="line">        at org.apache.hadoop.ipc.Server<span class="built_in">$</span>Handler<span class="built_in">$</span>1.run(Server.java:2277)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at javax.security.auth.Subject.doAs(Subject.java:422)</span><br><span class="line">        at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1924)</span><br><span class="line">        at org.apache.hadoop.ipc.Server<span class="built_in">$</span>Handler.run(Server.java:2275)</span><br></pre></td></tr></table></figure>

<h2 id="4-3-线上参数配置"><a href="#4-3-线上参数配置" class="headerlink" title="4.3 线上参数配置"></a>4.3 线上参数配置</h2><p>设置 YARN app 允许写 ZNode 的最大值（4<em>1024</em>1024 B，即 4M），重启 RM。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参数：yarn-site.xml 的 ResourceManager 高级配置代码段（安全阀）</span><br><span class="line">值：</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.zk-max-znode-size.bytes&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;<span class="number">4194304</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>前面在 2.2 小节中分析了作业在更新 Application 或 AppAttemp 状态时，会通过重试的方式向 ZK 的 ZNode 中写入数据，线上环境默认的重试次数为 1000 次，重试间隔为 60ms，而一旦任务出现异常时，这种高频次的写入会对 ZK 或 RM 服务造成一定的压力，因此可以调小作业的重试次数，减少重试时对服务的压力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参数：yarn-site.xml 的 ResourceManager 高级配置代码段（安全阀）</span><br><span class="line">值：</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.zk-num-retries&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;<span class="number">100</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://github.com/apache/hadoop/blob/trunk/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/recovery/ZKRMStateStore.java">Hadoop官方源码</a></p>
</li>
<li><p><a href="https://issues.apache.org/jira/browse/YARN-2368">issue YARN-2368</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1629687">ZooKeeper节点数据量限制引起的Hadoop YARN ResourceManager崩溃原因分析</a></p>
</li>
<li><p><a href="https://blog.csdn.net/Androidlushangderen/article/details/48224707">YARN源码分析(三)—–ResourceManager HA之应用状态存储与恢复</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>YARN</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>YARN</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN聚合日志源码分析及优化</title>
    <url>/2021/11/16/YARN%E8%81%9A%E5%90%88%E6%97%A5%E5%BF%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>线上集群 Container 日志上报的事务集群 namenode rpc 持续飙高，影响到了 YARN 分配 Container 的性能，任务提交数下降，导致整个集群的吞吐量下降。</p>
<p>这是由于作业提交到 YARN 集群时，每个 NM 节点都会对每个 app 作业进行日志聚合操作，该操作包括初始化日志聚合服务、检测和创建日志聚合的 HDFS 目录、创建日志聚合线程执行本地日志的上传。其中，初始化日志聚合服务就是简单的对象创建，不和 HDFS 交互，基本无压力；检测和创建日志聚合的 HDFS 目录会执行 HDFS 读和写请求，并且是同步阻塞执行，依赖写 /tmp/logs/ 目录所在集群的 HDFS 服务；创建日志聚合线程上传本地日志，代码中该线程是通过线程池异步创建，不存在阻塞，但固定大小的线程池可能会出现线程创建阻塞。</p>
<p>根据以上分析，针对日志聚合依赖读写 HDFS 数据反向影响作业的提交问题，主要有两种解决方案：</p>
<ul>
<li>作业提交不依赖日志聚合对 HDFS 服务的读/写。（本文主要解决这一问题）</li>
<li>日志聚合写 HDFS 进行分流，写到多个 HDFS 集群。</li>
</ul>
<h1 id="1-聚合日志介绍"><a href="#1-聚合日志介绍" class="headerlink" title="1. 聚合日志介绍"></a>1. 聚合日志介绍</h1><p>日志聚集是 YARN 提供的日志中央化管理功能，它能将运行完成的 Container 任务日志上传到 HDFS 上，从而减轻 NodeManager 负载，且提供一个中央化存储和分析机制。默认情况下，Container 任务日志存在在各个 NodeManager 的本地磁盘上，保存在 <code>yarn.nodemanager.log-dirs</code>参数配置的目录下，保存的时间由 <code>yarn.nodemanager.log.retain-seconds</code> 参数决定（默认时3小时）。若启用日志聚集功能，会将作业完成的日志上传到 HDFS 的 <code>$&#123;yarn.nodemanager.remote-app-log-dir&#125;/$&#123;user&#125;/$&#123;yarn.nodemanager.remote-app-log-dir-suffix&#125; </code>下，要实现日志聚合功能，需要额外的配置。</p>
<p>这里的日志存储的就是具体 Mapreduce 和 Spark 任务的日志，包括框架的和应用程序里自己打印的。这日志聚合是用来看日志的，而 job history server 则是用来看某个application 的大致统计信息的，包括作业启停时间，map 任务数，reduce 任务数以及各种计数器的值等等。job history server 是抽象概要性的统计信息，而聚合日志是该application 所有任务节点的详细日志集合。</p>
<h1 id="2-聚合日志生命周期"><a href="#2-聚合日志生命周期" class="headerlink" title="2. 聚合日志生命周期"></a>2. 聚合日志生命周期</h1><p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/16/6d487d41f9fb51ce956ff7f2877ff802-1637065327727-58de5ef3-1b51-4f9d-809d-95a468c82d44-678b84.png" alt="img"></p>
<center>YARN 聚合日志上传流程</center>

<p>YARN 作业在运行过程中，聚合日志的生命周期如上图，大致分为以下四个步骤：</p>
<ol>
<li><p>作业运行过程中，日志将暂存于 <code>yarn.nodemanager.log-dirs</code> 配置项指定的本地路径下，默认为 <code>/var/log/hadoop-yarn/container/</code>。</p>
</li>
<li><p>作业运行结束后（无论正常结束与否），将持久化日志到 <code>yarn.nodemanager.remote-app-log-dir</code> 和 <code>yarn.nodemanager.remote-app-log-dir-suffix</code> 配置项指定的 HDFS 路径下，前者默认为 <code>/tmp/logs/</code>，后者默认为 <code>logs</code>。对应 HDFS 的实际路径为 <code>$&#123;yarn.nodemanager.remote-app-log-dir&#125;/$&#123;user&#125;/$&#123;yarn.nodemanager.remote-app-log-dir-suffix&#125;/$&#123;application_id&#125;/</code>，即 <code>/tmp/logs/&lt;user&gt;/logs/</code>。控制日志聚合操作的服务为 LogAggregationService，具体上传日志到 HDFS 的行为由 LogAggregationService 服务创建的 AppLogAggregator 线程执行。</p>
</li>
<li><p>日志持久化聚合到 HDFS 后，会删除本地的暂存日志。</p>
</li>
<li><p>聚合上传到 HDFS 的日志也是有保留周期的，保存周期由 <code>yarn.log-aggregation.retain-seconds</code> 参数控制，集群可配置。</p>
</li>
</ol>
<h1 id="3-聚合日志参数"><a href="#3-聚合日志参数" class="headerlink" title="3. 聚合日志参数"></a>3. 聚合日志参数</h1><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">参数：yarn.nodemanager.log-dirs</span><br><span class="line">参数解释：日志存放地址（可配置多个目录）。</span><br><span class="line">默认值：<span class="built_in">$</span>&#123;yarn.log.dir&#125;/userlogs</span><br><span class="line"></span><br><span class="line">参数：yarn.log-aggregation-enable</span><br><span class="line">参数解释：是否启用日志聚集功能。</span><br><span class="line">默认值：false</span><br><span class="line"></span><br><span class="line">参数：yarn.log-aggregation.retain-seconds</span><br><span class="line">参数解释：在HDFS上聚集的日志最多保存多长时间。</span><br><span class="line">默认值：-1</span><br><span class="line"></span><br><span class="line">参数：yarn.log-aggregation.retain-check-interval-seconds</span><br><span class="line">参数解释：多长时间检查一次日志，并将满足条件的删除，如果是0或者负数，则为上一个值的1/10。</span><br><span class="line">默认值：-1</span><br><span class="line"></span><br><span class="line">参数：yarn.nodemanager.remote-app-log-dir</span><br><span class="line">参数解释：当应用程序运行结束后，日志被转移到的HDFS目录（启用日志聚集功能时有效）。</span><br><span class="line">默认值：/tmp/logs</span><br><span class="line"></span><br><span class="line">参数：yarn.nodemanager.remote-app-log-dir-suffix</span><br><span class="line">参数解释：远程日志目录子目录名称（启用日志聚集功能时有效）。</span><br><span class="line">默认值：logs 日志将被转移到目录<span class="built_in">$</span>&#123;yarn.nodemanager.remote-app-log-dir&#125;/<span class="built_in">$</span>&#123;user&#125;/<span class="built_in">$</span>&#123;thisParam&#125;下</span><br><span class="line"></span><br><span class="line">参数：yarn.nodemanager.log.retain-seconds</span><br><span class="line">参数解释：NodeManager上日志最多存放时间（不启用日志聚集功能时有效）。</span><br><span class="line">默认值：10800（3小时）</span><br></pre></td></tr></table></figure>

<h1 id="4-技术方案调研"><a href="#4-技术方案调研" class="headerlink" title="4. 技术方案调研"></a>4. 技术方案调研</h1><p><a href="https://mp.weixin.qq.com/s/0ffysIzzJIFLcyg2bXfwSQ">YARN 在字节跳动的优化与实践</a></p>
<blockquote>
<p>将 HDFS 做成弱依赖 对于一般的离线批处理来说，如果 HDFS 服务不可用了，那么 YARN 也没必要继续运行了。但是在字节跳动内部由于 YARN 还同时承载流式作业和模型训练，因此不能容忍 HDFS 故障影响到 YARN。为此，我们通过将 NodeLabel 存储到 ZK 中，将 Container Log 在 HDFS 的目录初始化和上传都改为异步的方式，摆脱了对 HDFS 的强依赖。</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/z5HzYSqc2zHmd-DDBVcG4w">YARN 在快手的应用实践与技术演进之路</a></p>
<blockquote>
<p>HDFS是yarn非常底层的基础设施，ResourceManager事件处理逻辑中有一些HDFS操作，HDFS卡一下，会造成整个事件处理逻辑卡住，最终整个集群卡住。分析发现RM对HDFS的操作主要集中在失败APP的处理，不是非常核心的逻辑，解决方案也比较简单粗暴，把HDFS的操作从同步改成异步。我们还对整个yarn事件处理逻辑进行排查，发现有一些像DNS的操作，在某些情况下也会比较卡，我们就把这种比较重IO的操作进行相应的优化，确保事件处理逻辑中都是快速的CPU操作，保证事件处理的高效和稳定。</p>
</blockquote>
<p><a href="https://www.infoq.cn/article/pmlsDrWfcjZBxj2P97S1">基于 Hadoop 的 58 同城离线计算平台设计与实践</a></p>
<blockquote>
<p>虽然有 Fedoration 机制来均衡各个 NN 的压力，但是对于单个 NN 压力仍然非常大，各种问题时刻在挑战 HDFS 稳定性，比如：NN RPC 爆炸，我们线上最大的 NS 有 15 亿的 RPC 调用，4000+ 并发连接请求，如此高的连接请求对业务稳定影响很大。针对这个问题，我们使用”拆解+优化”的两种手段相结合的方式来改进。拆解就是说我们把一些大的访问，能不能拆解到不同的集群上，或者我们能不能做些控制，具体案例如下： 1.Hive Scratch：我们经过分析 Hive Scratch 的临时目录在 RPC 调用占比中达到 20%，对于 Hive Scratch 实际上每个业务不需要集中到一个 NS 上，我们把它均衡到多个 NS 上。 2.Yarn 日志聚合：Yarn 的日志聚合主要是给业务查看一些日志，实际上他没有必要那个聚合到 HDFS 上，只需要访问本地就可以了。ResourceLocalize：同样把它均衡到各个 NS 上。</p>
</blockquote>
<p><a href="https://tech.meituan.com/2017/04/14/hdfs-federation.html">HDFS Federation在美团点评的应用与改进</a></p>
<blockquote>
<p>计算引擎（包括MapReduce和Spark）在提交作业时，会向NameNode发送RPC，获取HDFS Token。在ViewFileSystem中，会向所有namespace串行的申请Token，如果某个namespace的NameNode负载很高，或者发生故障，则任务无法提交，YARN的ResourceManager在renew Token时，也会受此影响。随着美团点评的发展YARN作业并发量也在逐渐提高，保存在HDFS上的YARN log由于QPS过高，被拆分为独立的namespace。但由于其并发和YARN container并发相同，NameNode读写压力还是非常大，经常导致其RPC队列打满，请求超时，进而影响了作业的提交。针对此问题，我们做出了一下改进： 1.container日志由NodeManager通过impersonate写入HDFS，这样客户端在提交Job时，就不需要YARN log所在namespace的Token。 2.ViewFileSystem在获取Token时，增加了参数，用于指定不获取哪些namespace的Token。 3.由于作业并不总是需要所有namespace中的数据，因此当单个namespace故障时，不应当影响其他namespace数据的读写，否则会降低整个集群的分区容忍性和可用性，ViewFileSystem在获取Token时，即使失败，也不影响作业提交，而是在真正访问数据时作业失败，这样在不需要的Token获取失败时，不影响作业的运行。 另外，客户端获取到的Token会以namespace为key，保存在一个自定义数据结构中（Credentials）。ResourceManager renew时，遍历这个数据结构。而NodeManager在拉取JAR包时，根据本地配置中的namespace名去该数据结构中获取对应Token。因此需要注意的是，虽然namespace配置和服务端不同不影响普通HDFS读写，但提交作业所使用的namespace配置需要与NodeManager相同，至少会用到的namespace配置需要是一致的。</p>
</blockquote>
<p>本文主要针对字节跳动的思路对日志聚合逻辑进行优化，将日志聚合读写 HDFS 集群改为弱依赖。</p>
<h1 id="5-YARN日志聚合源码分析"><a href="#5-YARN日志聚合源码分析" class="headerlink" title="5. YARN日志聚合源码分析"></a>5. YARN日志聚合源码分析</h1><p>要弄清楚聚合日志如何工作的，就需要了解 YARN 中处理聚合日志的服务在哪里创建的，根据 <a href="https://benkoons.github.io/2021/11/07/YARN-ApplicationMaster%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YARN ApplicationMaster启动原理与源码分析</a> 文章分析，我们知道 YARN 的第一个 Container 启动是用于 AppAttmpt 角色，也就是我们通常在 YARN UI 界面看到的 ApplicationMaster 服务。所以我们来看看一个作业的第一个 Container 是如何启动以及如何创建日志记录组件 LogHandler 的。</p>
<p>ApplicationMaster 通过调用 RPC 函数 ContainerManagementProtocol#startContainers() 开始启动 Container，即 startContainerInternal() 方法，这部分逻辑做了两件事：</p>
<ul>
<li>发送 ApplicationEventType.INIT_APPLICATION 事件，对应用程序资源的初始化，主要是初始化各类必需的服务组件（如日志记录组件 LogHandler、资源状态追踪组件 LocalResourcesTrackerImpl等），供后续 Container 启动，通常来自 ApplicationMaster 的第一个 Container 完成，这里的 if 逻辑针对一个 NM 节点上运行作业的所有 Containers 只调用一次，后续的 Container 跳过这段 Application 初始化过程。</li>
<li>发送 ApplicationEventType.INIT_CONTAINER 事件，对 Container 进行初始化操作。（这部分事件留在 Container 启动环节介绍）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startContainerInternal</span><span class="params">(NMTokenIdentifier nmTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      ContainerTokenIdentifier containerTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      StartContainerRequest request)</span> <span class="keyword">throws</span> YarnException, IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略Token认证及ContainerLaunchContext上下文初始化</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!serviceStopped) &#123;</span><br><span class="line">        <span class="comment">// Create the application</span></span><br><span class="line">        Application application =</span><br><span class="line">            <span class="keyword">new</span> ApplicationImpl(dispatcher, user, applicationID, credentials, context);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 应用程序的初始化，供后续Container使用，这个逻辑只调用一次，通常由来自ApplicationMaster的第一个Container完成</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == context.getApplications().putIfAbsent(applicationID,</span><br><span class="line">          application)) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;Creating a new application reference for app &quot;</span> + applicationID);</span><br><span class="line">          LogAggregationContext logAggregationContext =</span><br><span class="line">              containerTokenIdentifier.getLogAggregationContext();</span><br><span class="line">          Map&lt;ApplicationAccessType, String&gt; appAcls =</span><br><span class="line">              container.getLaunchContext().getApplicationACLs();</span><br><span class="line">          context.getNMStateStore().storeApplication(applicationID,</span><br><span class="line">              buildAppProto(applicationID, user, credentials, appAcls,</span><br><span class="line">                logAggregationContext));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 1.向 ApplicationImpl 发送 ApplicationEventType.INIT_APPLICATION 事件</span></span><br><span class="line">          dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ApplicationInitEvent(applicationID, appAcls,</span><br><span class="line">              logAggregationContext));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2.向 ApplicationImpl 发送 ApplicationEventType.INIT_CONTAINER 事件</span></span><br><span class="line">        <span class="keyword">this</span>.context.getNMStateStore().storeContainer(containerId, request);</span><br><span class="line">        dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> ApplicationContainerInitEvent(container));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">this</span>.context.getContainerTokenSecretManager().startContainerSuccessful(</span><br><span class="line">          containerTokenIdentifier);</span><br><span class="line">        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,</span><br><span class="line">          <span class="string">&quot;ContainerManageImpl&quot;</span>, applicationID, containerId);</span><br><span class="line">        <span class="comment">// TODO launchedContainer misplaced -&gt; doesn&#x27;t necessarily mean a container</span></span><br><span class="line">        <span class="comment">// launch. A finished Application will not launch containers.</span></span><br><span class="line">        metrics.launchedContainer();</span><br><span class="line">        metrics.allocateContainer(containerTokenIdentifier.getResource());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> YarnException(</span><br><span class="line">            <span class="string">&quot;Container start failed as the NodeManager is &quot;</span> +</span><br><span class="line">            <span class="string">&quot;in the process of shutting down&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>这里主要看看第1件事情，即向 ApplicationImpl 发送 ApplicationEventType.INIT_APPLICATION 事件，事件对应的状态机为 AppInitTransition 状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line"><span class="comment">// Transitions from NEW state</span></span><br><span class="line">           .addTransition(ApplicationState.NEW, ApplicationState.INITING,</span><br><span class="line">               ApplicationEventType.INIT_APPLICATION, <span class="keyword">new</span> AppInitTransition())</span><br></pre></td></tr></table></figure>



<p>AppInitTransition 状态机会对日志聚合组件服务进行初始化，关键行动是向调度器发送 LogHandlerEventType.APPLICATION_STARTED 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Notify services of new application.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * In particular, this initializes the &#123;<span class="doctag">@link</span> LogAggregationService&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">SingleArcTransition</span>&lt;<span class="title">ApplicationImpl</span>, <span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ApplicationImpl app, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">      ApplicationInitEvent initEvent = (ApplicationInitEvent)event;</span><br><span class="line">      app.applicationACLs = initEvent.getApplicationACLs();</span><br><span class="line">      app.aclsManager.addApplication(app.getAppId(), app.applicationACLs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化日志聚合组件服务</span></span><br><span class="line">      <span class="comment">// Inform the logAggregator</span></span><br><span class="line">      app.logAggregationContext = initEvent.getLogAggregationContext();</span><br><span class="line">      <span class="comment">// 向调度器发送 LogHandlerEventType.APPLICATION_STARTED 事件</span></span><br><span class="line">      app.dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> LogHandlerAppStartedEvent(app.appId, app.user,</span><br><span class="line">              app.credentials, ContainerLogsRetentionPolicy.ALL_CONTAINERS,</span><br><span class="line">              app.applicationACLs, app.logAggregationContext)); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>想要弄清楚 LogHandlerEventType.APPLICATION_STARTED 事件做了什么，就要知道 LogHandlerEventType 类注册的事件处理器是什么以及事件处理器做了什么事情。这里的 register 方法对 LogHandlerEventType 类进行了注册，对应的 logHandler 事件处理器为 LogAggregationService 服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceInit</span><span class="params">(Configuration conf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 定义日志处理器</span></span><br><span class="line">    LogHandler logHandler =</span><br><span class="line">      createLogHandler(conf, <span class="keyword">this</span>.context, <span class="keyword">this</span>.deletionService);</span><br><span class="line">    addIfService(logHandler);</span><br><span class="line">    <span class="comment">// 注册 LogHandlerEventType 事件，logHandler 为对应的处理器</span></span><br><span class="line">    dispatcher.register(LogHandlerEventType.class, logHandler);</span><br><span class="line">    </span><br><span class="line">    waitForContainersOnShutdownMillis =</span><br><span class="line">        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,</span><br><span class="line">            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) +</span><br><span class="line">        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,</span><br><span class="line">            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +</span><br><span class="line">        SHUTDOWN_CLEANUP_SLOP_MS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.serviceInit(conf);</span><br><span class="line">    recover();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>具体创建 logHandler 对象的调用，由于集群开启了日志聚合功能（由参数 <code>yarn.log-aggregation-enable</code> 控制），这里返回 LogAggregationService 服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> LogHandler <span class="title">createLogHandler</span><span class="params">(Configuration conf, Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">      DeletionService deletionService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,</span><br><span class="line">        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) &#123;</span><br><span class="line">      <span class="comment">// 判断是否启用了日志聚合，由于集群开启了日志聚合，这里初始化 LogAggregationService 服务</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LogAggregationService(<span class="keyword">this</span>.dispatcher, context,</span><br><span class="line">          deletionService, dirsHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> NonAggregatingLogHandler(<span class="keyword">this</span>.dispatcher, deletionService,</span><br><span class="line">                                          dirsHandler,</span><br><span class="line">                                          context.getNMStateStore());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>弄清楚了 LogHandlerEventType 类注册的服务是 LogAggregationService，我们就进入 LogAggregationService 类的 handle() 方法，看看上面的 LogHandlerEventType.APPLICATION_STARTED 事件做了什么事。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LogHandlerEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="comment">// APPLICATION_STARTED 事件处理流程</span></span><br><span class="line">      <span class="keyword">case</span> APPLICATION_STARTED:</span><br><span class="line">        LogHandlerAppStartedEvent appStartEvent =</span><br><span class="line">            (LogHandlerAppStartedEvent) event;</span><br><span class="line">        initApp(appStartEvent.getApplicationId(), appStartEvent.getUser(),</span><br><span class="line">            appStartEvent.getCredentials(),</span><br><span class="line">            appStartEvent.getLogRetentionPolicy(),</span><br><span class="line">            appStartEvent.getApplicationAcls(),</span><br><span class="line">            appStartEvent.getLogAggregationContext());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CONTAINER_FINISHED:</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> APPLICATION_FINISHED:</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ; <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>LogHandlerEventType.APPLICATION_STARTED 事件的关键逻辑在 initApp() 方法的调用。这段逻辑主要做了三件事：</p>
<ol>
<li><p>判断 HDFS 上日志聚合的根目录是否存在，即 <code>/tmp/logs/</code> 目录（具体为 <code>hdfs://nameservice/tmp/logs/</code>)，由参数 <code>yarn.nodemanager.remote-app-log-dir</code> 控制。（注意：这里的请求会阻塞读 HDFS）</p>
</li>
<li><p>创建作业日志聚合的 HDFS 目录，并初始化 app 日志聚合实例，采用线程池的方式启动日志聚合进程。（重点，这里会有请求阻塞写 HDFS，并且通过有限大小的线程池异步创建日志聚合线程去做日志的聚合）</p>
</li>
<li><p>根据构建的 ApplicationEvent 事件，向发送 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件，告知处理器日志聚合服务初始化完成。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initApp</span><span class="params">(<span class="keyword">final</span> ApplicationId appId, String user,</span></span></span><br><span class="line"><span class="params"><span class="function">      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">      Map&lt;ApplicationAccessType, String&gt; appAcls,</span></span></span><br><span class="line"><span class="params"><span class="function">      LogAggregationContext logAggregationContext)</span> </span>&#123;</span><br><span class="line">    ApplicationEvent eventResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、 判断 HDFS 上日志聚合的根目录是否存在，即 `/tmp/logs/` 目录（具体为 `hdfs://nameservice/tmp/logs`)，由参数 `yarn.nodemanager.remote-app-log-dir` 控制</span></span><br><span class="line">      verifyAndCreateRemoteLogDir(getConfig());</span><br><span class="line">      <span class="comment">// 重点：2、创建作业日志聚合的 HDFS 目录，并初始化 app 日志聚合实例，采用线程池的方式启动日志聚合进程</span></span><br><span class="line">      initAppAggregator(appId, user, credentials, logRetentionPolicy, appAcls,</span><br><span class="line">          logAggregationContext);</span><br><span class="line">      <span class="comment">// 构建 ApplicationEvent 事件</span></span><br><span class="line">      eventResponse = <span class="keyword">new</span> ApplicationEvent(appId,</span><br><span class="line">          ApplicationEventType.APPLICATION_LOG_HANDLING_INITED);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (YarnRuntimeException e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">&quot;Application failed to init aggregation&quot;</span>, e);</span><br><span class="line">      eventResponse = <span class="keyword">new</span> ApplicationEvent(appId,</span><br><span class="line">          ApplicationEventType.APPLICATION_LOG_HANDLING_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、根据构建的 ApplicationEvent 事件，向发送 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件，告知处理器日志聚合服务初始化完成</span></span><br><span class="line">    <span class="keyword">this</span>.dispatcher.getEventHandler().handle(eventResponse);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>第一件事比较简单，主要是是判断 HDFS 聚合日志的根目录是否存在，由于目录一般都存在，这一块主要是读 HDFS 请求。我们主要来看看 initApp() 方法做的第二件事，可以看到第三件事是发送 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件，表示日志聚合服务初始化完成，包括创建作业在 HDFS 的日志聚合目录和启动日志聚合线程。所以基本可以知道第2件事的 initAppAggregator() 是会创建作业日志聚合目录，并启动日志聚合线程，具体的我们来看代码。</p>
<p>这段代码其实主要做了两件事：</p>
<ol>
<li>调用 createAppDir() 方法执行 HDFS 写请求为作业创建日志聚合的目录，即 <code>hdfs://nameservice/tmp/logs/&lt;user&gt;/logs/</code> 目录，这里的写逻辑如果成功则只调用一次，一般是由第一个 Container 创建（即作业的 ApplicationMaster Container），其他 Container 只执行 HDFS 读请求判断该目录是否存在即可。</li>
<li>通过 threadPool 线程池创建每个作业在 NM 节点的日志聚合线程，异步处理本地日志的上传，该线程池大小由参数 <code>yarn.nodemanager.logaggregation.threadpool-size-max</code> 控制，默认大小为 100。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initAppAggregator</span><span class="params">(<span class="keyword">final</span> ApplicationId appId, String user,</span></span></span><br><span class="line"><span class="params"><span class="function">      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">      Map&lt;ApplicationAccessType, String&gt; appAcls,</span></span></span><br><span class="line"><span class="params"><span class="function">      LogAggregationContext logAggregationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get user&#x27;s FileSystem credentials</span></span><br><span class="line">    <span class="keyword">final</span> UserGroupInformation userUgi =</span><br><span class="line">        UserGroupInformation.createRemoteUser(user);</span><br><span class="line">    <span class="keyword">if</span> (credentials != <span class="keyword">null</span>) &#123;</span><br><span class="line">      userUgi.addCredentials(credentials);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// New application</span></span><br><span class="line">    <span class="keyword">final</span> AppLogAggregator appLogAggregator =</span><br><span class="line">        <span class="keyword">new</span> AppLogAggregatorImpl(<span class="keyword">this</span>.dispatcher, <span class="keyword">this</span>.deletionService,</span><br><span class="line">            getConfig(), appId, userUgi, <span class="keyword">this</span>.nodeId, dirsHandler,</span><br><span class="line">            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,</span><br><span class="line">            appAcls, logAggregationContext, <span class="keyword">this</span>.context,</span><br><span class="line">            getLocalFileContext(getConfig()));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.appLogAggregators.putIfAbsent(appId, appLogAggregator) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;Duplicate initApp for &quot;</span> + appId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait until check for existing aggregator to create dirs</span></span><br><span class="line">    YarnRuntimeException appDirException = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建作业日志聚合目录，即 hdfs://nameservice/tmp/logs/&lt;user&gt;/logs/ 目录</span></span><br><span class="line">      <span class="comment">// Create the app dir</span></span><br><span class="line">      createAppDir(user, appId, userUgi);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      appLogAggregator.disableLogAggregation();</span><br><span class="line">      <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> YarnRuntimeException)) &#123;</span><br><span class="line">        appDirException = <span class="keyword">new</span> YarnRuntimeException(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appDirException = (YarnRuntimeException)e;</span><br><span class="line">      &#125;</span><br><span class="line">      appLogAggregators.remove(appId);</span><br><span class="line">      closeFileSystems(userUgi);</span><br><span class="line">      <span class="keyword">throw</span> appDirException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建作业的日志聚合线程，并通过线程池启动日志聚合线程，异步上传 NM 节点的日志</span></span><br><span class="line">    <span class="comment">// Schedule the aggregator.</span></span><br><span class="line">    Runnable aggregatorWrapper = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          appLogAggregator.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          appLogAggregators.remove(appId);</span><br><span class="line">          closeFileSystems(userUgi);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.threadPool.execute(aggregatorWrapper);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，从日志聚合服务组件的创建，到为作业初始化 HDFS 聚合日志目录，到启动日志聚合线程，整个日志聚合的调用逻辑已介绍完毕，日志的具体上传逻辑在 AppLogAggregatorImpl 类的 run() 方法开始执行，具体上传这里不做详细介绍，感兴趣可以可以去看看上传行为是如何做的。</p>
<h1 id="6-优化方案"><a href="#6-优化方案" class="headerlink" title="6. 优化方案"></a>6. 优化方案</h1><p>在背景介绍中，提到了日志聚合操作存在风险的点主要在读/写 HDFS 请求所在的集群 namenode rpc 压力，和固定大小的线程池创建线程的阻塞，代码的修改逻辑也是结合这两个问题诞生的。</p>
<ul>
<li>针对读/写 HDFS 请求的 rpc 压力，代码将日志聚合逻辑中与 HDFS 交互的方式全部改为异步处理，不依赖日志聚合读写数据的 HDFS 集群。</li>
<li>针对固定大小线程池创建线程可能出现的阻塞情况，代码将这一块修改为生产者-消费者模式，聚合日志线程的产生与线程的处理解耦。</li>
</ul>
<h2 id="6-1-读-写-HDFS-请求异步"><a href="#6-1-读-写-HDFS-请求异步" class="headerlink" title="6.1 读/写 HDFS 请求异步"></a>6.1 读/写 HDFS 请求异步</h2><p>日志聚合服务中与 HDFS 交互有两个地方，一个是读操作，判断 HDFS 上 <code>/tmp/logs/</code> 目录是否存在，一个是写操作，创建作业的聚合日志目录 <code>/tmp/logs/&lt;user&gt;/logs/&lt;appid&gt;/</code>，这写操作每个作业只执行一次，后续都是读操作，判断该目录是否存在即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">asyncCreateAppDir</span><span class="params">(<span class="keyword">final</span> String user, <span class="keyword">final</span> ApplicationId appId, <span class="keyword">final</span> UserGroupInformation userUgi)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	          <span class="comment">// check dir &#x27;/tmp/logs/&#x27; exists</span></span><br><span class="line">	          verifyAndCreateRemoteLogDir(getConfig());</span><br><span class="line">	          <span class="comment">// create app log dir</span></span><br><span class="line">	          createAppDir(user, appId, userUgi);</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	          e.printStackTrace();</span><br><span class="line">	        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>将日志聚合读写 HDFS 请求改为异步后，可能会产生另外一个问题。由于作业日志聚合目录的创建是异步的，而执行日志上传操作也是异步进行的，这里存在着先后顺序，即必须作业的日志聚合目录已经创建完成，上传操作才能正常进行。因此，在具体执行上传操作时，我们对日志聚合目录是否存在添加一层校验，以确保上传前聚合目录必须存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAppLogAggregation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断作业是否完成，直到作业完成后才跳出 while 逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.appFinishing.get() &amp;&amp; !<span class="keyword">this</span>.aborted.get()) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          waiting.set(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.rollingMonitorInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait(<span class="keyword">this</span>.rollingMonitorInterval * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.appFinishing.get() || <span class="keyword">this</span>.aborted.get()) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uploadLogsForContainers(<span class="keyword">false</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(THREAD_SLEEP_TIME);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;PendingContainers queue is interrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">this</span>.appFinishing.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aborted.get()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改造点：增加日志聚合目录是否存在的校验，如果不存在则创建改目录（具体改造见下面）</span></span><br><span class="line">    <span class="comment">//check remote app dir</span></span><br><span class="line">    checkRemoteDir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键：执行真正的日志上传动作</span></span><br><span class="line">    <span class="comment">// App is finished, upload the container logs.</span></span><br><span class="line">    uploadLogsForContainers(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除作业在 NM 本地目录保存的日志，由 DeletionService 服务负责。</span></span><br><span class="line">    doAppLogAggregationPostCleanUp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dispatcher.getEventHandler().handle(</span><br><span class="line">        <span class="keyword">new</span> ApplicationEvent(<span class="keyword">this</span>.appId,</span><br><span class="line">            ApplicationEventType.APPLICATION_LOG_HANDLING_FINISHED));</span><br><span class="line">    <span class="keyword">this</span>.appAggregationFinished.set(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p><code>checkRemoteDir()</code> 逻辑和前面的 <code>createAppDir(user, appId, userUgi);</code> 逻辑差不多，无非就是在实际上传时再做一次 check 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AppLogAggregatorImpl.java</span></span><br><span class="line">  <span class="comment">// 改造的具体代码如下</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">checkRemoteDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    userUgi.doAs(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileSystem remoteFS = remoteNodeLogFileForApp.getFileSystem(conf);</span><br><span class="line">        <span class="keyword">if</span> (!remoteFS.exists(remoteNodeLogFileForApp.getParent())) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            FsPermission dirPerm = <span class="keyword">new</span> FsPermission(APP_DIR_PERMISSIONS);</span><br><span class="line">            remoteFS.mkdirs(remoteNodeLogFileForApp.getParent(), dirPerm);</span><br><span class="line">            FsPermission umask = FsPermission.getUMask(remoteFS.getConf());</span><br><span class="line">            <span class="keyword">if</span> (!dirPerm.equals(dirPerm.applyUMask(umask))) &#123;</span><br><span class="line">              remoteFS.setPermission(remoteNodeLogFileForApp.getParent(), dirPerm);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Failed to setup application log directory for &quot;</span> + appId, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-聚合日志线程的创建和处理解耦"><a href="#6-2-聚合日志线程的创建和处理解耦" class="headerlink" title="6.2 聚合日志线程的创建和处理解耦"></a>6.2 聚合日志线程的创建和处理解耦</h2><p>这一块主要是通过生产者-消费者模式，将日志聚合线程的创建和处理解耦，生产的线程由阻塞队列 logAggregatorQueue 维护，具体的线程消费逻辑由独立线程 LauncherLogAggregatorThread 处理，具体代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initAppAggregator</span><span class="params">(<span class="keyword">final</span> ApplicationId appId, String user,</span></span></span><br><span class="line"><span class="params"><span class="function">      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">      Map&lt;ApplicationAccessType, String&gt; appAcls,</span></span></span><br><span class="line"><span class="params"><span class="function">      LogAggregationContext logAggregationContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务停止时阻塞新请求的接收</span></span><br><span class="line">    <span class="keyword">if</span> (blockNewLogAggr) &#123;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	  processed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the aggregator thread.</span></span><br><span class="line">    Runnable aggregatorWrapper = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          appLogAggregator.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          appLogAggregators.remove(appId);</span><br><span class="line">          closeFileSystems(userUgi);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 改造点：将线程池直接创建线程改为生产-消费模式，这里负责生产日志聚合线程，添加到阻塞队列中</span></span><br><span class="line">	  logAggregatorQueue.add(aggregatorWrapper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logAggregatorQueue 对象的定义</span></span><br><span class="line">  <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; logAggregatorQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br></pre></td></tr></table></figure>



<p>定义一个消费者线程，专门用来处理 <code>logAggregatorQueue.add(aggregatorWrapper);</code> 队列中添加的线程任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">    <span class="comment">// 消费线程停止标志 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否阻塞新聚合日志的接收，默认不阻塞 false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> blockNewLogAggr = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费队列中对象是否处理完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> processed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于线程等待/通知的 syncronized 对象</span></span><br><span class="line">    <span class="keyword">private</span> Object waitForProcess = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 改造点：具体的线程消费由单独的线程类控制，实现线程创建和处理的解耦</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LauncherLogAggregatorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!stopped &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        processed = logAggregatorQueue.isEmpty();</span><br><span class="line">          <span class="keyword">if</span> (blockNewLogAggr) &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (waitForProcess) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (processed) &#123;</span><br><span class="line">                      waitForProcess.notify();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        Runnable toLaunch;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// Schedule the aggregator.</span></span><br><span class="line">          toLaunch = logAggregatorQueue.take();</span><br><span class="line">          threadPool.execute(toLaunch);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          LOG.warn(<span class="keyword">this</span>.getClass().getName() + <span class="string">&quot; interrupted. Returning.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>服务停止时等待消费队列聚合事件处理完成，然后关闭消费线程和线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serviceStop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LOG.info(<span class="keyword">this</span>.getName() + <span class="string">&quot; waiting for pending aggregation during exit&quot;</span>);</span><br><span class="line">    blockNewLogAggr = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (waitForProcess) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!processed &amp;&amp; launcherLogAggregatorThread.isAlive()) &#123;</span><br><span class="line">        waitForProcess.wait(<span class="number">1000</span>);</span><br><span class="line">        LOG.info(<span class="string">&quot;Waiting for launcherLogAggregatorThread to process. Thread state is :&quot;</span> + launcherLogAggregatorThread.getState());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.stopped = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (launcherLogAggregatorThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">      launcherLogAggregatorThread.interrupt();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        launcherLogAggregatorThread.join();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        LOG.warn(launcherLogAggregatorThread.getName() + <span class="string">&quot; interrupted during join &quot;</span>, ie);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopAggregators();</span><br><span class="line">    <span class="keyword">super</span>.serviceStop();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-测试分析"><a href="#7-测试分析" class="headerlink" title="7. 测试分析"></a>7. 测试分析</h1><p>测试集群分为 hadoop-up1 集群和 hadoop-up2 集群，采用 viewfs 模式访问 HDFS，作业提交在 hadoop-up1 集群，日志聚合目录 <code>/tmp/logs/</code> 挂载在 hadoop-up2 集群下，即 <code>hdfs://hadoop-up2/tmp/logs/</code> 目录。</p>
<h2 id="7-1-NM日志聚合改造前"><a href="#7-1-NM日志聚合改造前" class="headerlink" title="7.1 NM日志聚合改造前"></a>7.1 NM日志聚合改造前</h2><p>作业提交命令：</p>
<blockquote>
<p>hadoop jar /opt/cloudera/parcels/CDH-5.14.4-1.cdh5.14.4.p0.3/jars/hadoop-mapreduce-examples-2.6.0-cdh5.14.4.jar pi -Dmapred.job.queue.name=root.exquery 50 50</p>
</blockquote>
<h3 id="7-1-1-开启-up2-集群-HDFS-服务"><a href="#7-1-1-开启-up2-集群-HDFS-服务" class="headerlink" title="7.1.1 开启 up2 集群 HDFS 服务"></a>7.1.1 开启 up2 集群 HDFS 服务</h3><p><strong>结论：</strong>作业正常提交，日志正常聚合。</p>
<h3 id="7-1-2-关闭-up2-集群-HDFS-服务"><a href="#7-1-2-关闭-up2-集群-HDFS-服务" class="headerlink" title="7.1.2 关闭 up2 集群 HDFS 服务"></a>7.1.2 关闭 up2 集群 HDFS 服务</h3><p><strong>结论：</strong>作业提交卡住，需等待请求 HDFS 服务超时，作业处于 Accepted 状态卡住，作业的 ApplicationMaster 处于 NEW 状态，该 Container 没有被分配（整个过程卡住大概 3min），直到抛异常触发日志聚合失败（即 ApplicationEventType.APPLICATION_LOG_HANDLING_FAILED）事件，作业的 ApplicationMaster 分配到 Container，作业开始运行，并且日志不聚合。</p>
<p><strong>现象1:</strong></p>
<p>作业提交卡住，YARN UI 作业的状态为 Accepted 状态，Elapsed 时间大概持续了 3min，说明作业在这段时间一直等待运行，并且用于启动 ApplicationMaster 的 Container 状态为 NEW，没有转换到 Submited 状态，表示 Container 没有运行，YARN 认为该作业还未提交。这也是线上集群在日志聚合集群 rpc 压力大时会影响作业的提交数和 Container 分配性能下降的原因。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/16/c3e8a179698af5e4bc0dc4ee1392583b-1637066438185-21b10203-de41-405f-8b01-73be38692032-44b5fa.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/16/043368e578589389f5922ef9f798fa7f-1637066438442-12a965c0-2692-452e-8052-c62c424f9c7b-d31c59.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/16/63c946d6373eeccbe88257d366bc7f41-1637067044797-16b73c6a-6576-4308-adf3-e7c334c46f5a-9caa8a.png" alt="img"></p>
<p><strong>现象2:</strong></p>
<p>由于 hadoop-up2 集群 HDFS 服务关闭，分析 NodeManager 执行日志，先打印 <code>Application failed to init aggregation</code> 信息，然后打印 <code>LogAggregationService.verifyAndCreateRemoteLogDir() </code>方法执行 HDFS 读请求的调用异常，读请求多次重试后抛出 YarnRuntimeException 异常，堆栈信息的调用栈和执行代码都和这一现象吻合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// NodeManager 日志：</span><br><span class="line">2021-03-10 09:56:43,444 WARN org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.LogAggregationService: Application failed to init aggregation</span><br><span class="line">org.apache.hadoop.yarn.exceptions.YarnRuntimeException: Failed to check permissions for dir [/tmp/logs]</span><br><span class="line">        at org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.LogAggregationService.verifyAndCreateRemoteLogDir(LogAggregationService.java:205)</span><br><span class="line">        at org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.LogAggregationService.initApp(LogAggregationService.java:336)</span><br><span class="line">        at org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.LogAggregationService.handle(LogAggregationService.java:463)</span><br><span class="line">        at org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.LogAggregationService.handle(LogAggregationService.java:68)</span><br><span class="line">        at org.apache.hadoop.yarn.event.AsyncDispatcher.dispatch(AsyncDispatcher.java:182)</span><br><span class="line">        at org.apache.hadoop.yarn.event.AsyncDispatcher$1.run(AsyncDispatcher.java:109)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.net.ConnectException: Call From 10-197-1-236/10.197.1.236 to 10-197-1-238:8020 failed on connection exception: java.net.ConnectException: Connection refused; For more details see:  http://wiki.apache.org/hadoop/ConnectionRefused</span><br><span class="line">        // 省略</span><br><span class="line">        at org.apache.hadoop.hdfs.DistributedFileSystem.getFileStatus(DistributedFileSystem.java:1261)</span><br><span class="line">        at org.apache.hadoop.fs.FilterFileSystem.getFileStatus(FilterFileSystem.java:432)</span><br><span class="line">        at org.apache.hadoop.fs.viewfs.ChRootedFileSystem.getFileStatus(ChRootedFileSystem.java:226)</span><br><span class="line">        at org.apache.hadoop.fs.viewfs.ViewFileSystem.getFileStatus(ViewFileSystem.java:379)</span><br><span class="line">        at org.apache.hadoop.yarn.server.nodemanager.containermanager.logaggregation.LogAggregationService.verifyAndCreateRemoteLogDir(LogAggregationService.java:194)</span><br><span class="line">2021-03-10 09:56:43,445 WARN org.apache.hadoop.yarn.server.nodemanager.containermanager.application.Application: Log Aggregation service failed to initialize, there will be no logs for this application</span><br></pre></td></tr></table></figure>

<h2 id="7-2-NM日志聚合改造后"><a href="#7-2-NM日志聚合改造后" class="headerlink" title="7.2 NM日志聚合改造后"></a>7.2 NM日志聚合改造后</h2><p>作业提交命令：</p>
<blockquote>
<p>hadoop jar /opt/cloudera/parcels/CDH-5.14.4-1.cdh5.14.4.p0.3/jars/hadoop-mapreduce-examples-2.6.0-cdh5.14.4.jar pi -Dmapred.job.queue.name=root.exquery 50 50</p>
</blockquote>
<h3 id="（1）开启-hadoop-up2-集群-HDFS-服务"><a href="#（1）开启-hadoop-up2-集群-HDFS-服务" class="headerlink" title="（1）开启 hadoop-up2 集群 HDFS 服务"></a>（1）开启 hadoop-up2 集群 HDFS 服务</h3><p><strong>结论：</strong>作业正常提交，日志正常聚合。</p>
<h3 id="（2）关闭-hadoop-up2-集群-HDFS-服务"><a href="#（2）关闭-hadoop-up2-集群-HDFS-服务" class="headerlink" title="（2）关闭 hadoop-up2 集群 HDFS 服务"></a>（2）关闭 hadoop-up2 集群 HDFS 服务</h3><p><strong>结论：</strong> 作业正常提交，日志聚合失败，不影响作业提交和运行。</p>
<p><strong>现象：</strong></p>
<ul>
<li><p>作业正常执行提交和执行。</p>
</li>
<li><p>日志聚合读请求 HDFS 异常（和 7.1 中 NM 日志一致），但不影响作业执行。</p>
</li>
<li><p>日志聚合失败，HistoryServer 无法查看聚合的日志。 </p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/16/f030a2d6f3aff5590254ba0500e9f117-1637067077718-7e978d06-1909-423f-b610-45e3bc94e209-4fa55a.png" alt="img"></p>
<p>至此，我们已经实现了 YARN 聚合日志的异步初始化和上传，避免了聚合日志集群 HDFS 服务异常对 YARN 集群任务执行的影响。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/Androidlushangderen/article/details/90115624">YARN的Log Aggregation原理</a></li>
</ol>
]]></content>
      <categories>
        <category>YARN</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>YARN</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN Container启动原理源码分析</title>
    <url>/2021/11/07/YARN-Container%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在 《YARN ApplicationMaster启动原理及源码分析》文章中，AM 向 RM 注册后，会周期性地通过 RPC 函数 ApplicationMaster#allocate() 与 RM 通信，通信目的包括请求资源、获取新分配的资源及形成周期性心跳，本文中我们重点看看 AM 向 RM 申请到 Container 资源后，如何在 NM 节点上启动 Container，接下来会详细介绍 Container 从申请资源、启动到资源清理整个过程的源码。</p>
<h1 id="1-Container启动流程介绍"><a href="#1-Container启动流程介绍" class="headerlink" title="1. Container启动流程介绍"></a>1. Container启动流程介绍</h1><p>Container 启动是由 ApplicationMaster 通过 RPC 函数 ContainerManagementProtocol#startContainers() 向 NM 发起的，NM 中的 ContainerManagerImpl 组件负责接收并处理该请求。Container 启动过程主要经历三个阶段：资源本地化、启动并运行 Container和资源清理。</p>
<ul>
<li><strong>资源本地化</strong>主要是指分布式缓存机制完成的工作，功能包括初始化各种服务组件、创建工作目录、从 HDFS 下载运行所需的各种资源（比如文本文件、JAR 包、可执行文件）等。资源本地化主要有两部分组成，分别是应用程序初始化和 Container 本地化。其中，应用程序初始化的主要工作是初始化各类必需的服务组件（比如日志记录组件 LogHandler、资源状态追踪器 LocalResourceTrackerImpl等），供后续 Container 使用，通常由 Application 的第一个 Container 完成；Container 本地化则是创建工作目录，从 HDFS 下载各类文件资源。</li>
<li><strong>Container 启动</strong>是由 ContainerLauncher 服务完成，该服务将进一步调用插拔式组件 ContainerExecutor。YARN 中提供了三种 ContainerExecutor 实现，一种是 DefaultContainerExecutor，一种是 LinuxContainerExecutor，另一种是 DockerContainerExecutor，由参数 yarn.nodemanager.container-executor.class 控制具体采用的方式。</li>
<li><strong>资源清理</strong>则是资源本地化的逆过程，它负责清理各类资源，均由 ResourceLocalizationService 服务完成。</li>
</ul>
<h1 id="2-Container启动源码分析"><a href="#2-Container启动源码分析" class="headerlink" title="2. Container启动源码分析"></a>2. Container启动源码分析</h1><h2 id="2-1-AM调用api请求启动Container"><a href="#2-1-AM调用api请求启动Container" class="headerlink" title="2.1 AM调用api请求启动Container"></a>2.1 AM调用api请求启动Container</h2><p>在介绍 Container 启动前，我们先来看看 AM 在心跳时如何根据申请到的资源来请求 Container 的启动。AM 通过 RPC 函数 ApplicationMaster#allocate() 周期性向 RM 申请资源，并将申请到的资源保存在阻塞队列 responseQueue 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartbeatThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">&quot;AMRM Heartbeater thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">// 心跳线程死循环的跑</span></span><br><span class="line">        AllocateResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// synchronization ensures we don&#x27;t send heartbeats after unregistering</span></span><br><span class="line">        <span class="keyword">synchronized</span> (unregisterHeartbeatLock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!keepRunning) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重点：心跳线程其实就是周期性的调用 allocate() 方法，将分配出来的 Container 保存在 AllocateResponse 实例中</span></span><br><span class="line">            response = client.allocate(progress);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ApplicationAttemptNotFoundException e) &#123;</span><br><span class="line">            handler.onShutdownRequest();</span><br><span class="line">            LOG.info(<span class="string">&quot;Shutdown requested. Stopping callback.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Exception on heartbeat&quot;</span>, ex);</span><br><span class="line">            savedException = ex;</span><br><span class="line">            <span class="comment">// interrupt handler thread in case it waiting on the queue</span></span><br><span class="line">            handlerThread.interrupt();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 将 RM 返回的 AllocateResponse 对象资源添加到阻塞队列 responseQueue 中</span></span><br><span class="line">                responseQueue.put(response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Interrupted while waiting to put on response queue&quot;</span>, ex);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(heartbeatIntervalMs.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;Heartbeater interrupted&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>那 responseQueue 队列保存申请到的 Container 资源怎么使用呢？通过查看 responseQueue.take() 函数，可以发现 AMRMClientAsyncImpl 类中的独立线程 CallbackHandlerThread 会不断地从队列中取出 AllocateResponse 对象进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackHandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallbackHandlerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">&quot;AMRM Callback Handler Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;    <span class="comment">// 死循环取出申请到的 Container 资源并进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (!keepRunning) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          AllocateResponse response;</span><br><span class="line">          <span class="keyword">if</span>(savedException != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Stopping callback due to: &quot;</span>, savedException);</span><br><span class="line">            handler.onError(savedException);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 从阻塞队列 responseQueue 取出 Container 资源</span></span><br><span class="line">            response = responseQueue.take();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;Interrupted while waiting for queue&quot;</span>, ex);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;NodeReport&gt; updatedNodes = response.getUpdatedNodes();</span><br><span class="line">          <span class="keyword">if</span> (!updatedNodes.isEmpty()) &#123;</span><br><span class="line">            handler.onNodesUpdated(updatedNodes);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          List&lt;ContainerStatus&gt; completed =</span><br><span class="line">              response.getCompletedContainersStatuses();</span><br><span class="line">          <span class="keyword">if</span> (!completed.isEmpty()) &#123;</span><br><span class="line">            handler.onContainersCompleted(completed);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          List&lt;Container&gt; allocated = response.getAllocatedContainers();</span><br><span class="line">          <span class="keyword">if</span> (!allocated.isEmpty()) &#123;</span><br><span class="line">              <span class="comment">// 重点：处理分配出来的 Container</span></span><br><span class="line">            handler.onContainersAllocated(allocated);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 更新 Container 的执行进度</span></span><br><span class="line">          progress = handler.getProgress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          handler.onError(ex);</span><br><span class="line">          <span class="comment">// re-throw exception to end the thread</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handler.onContainersAllocated(allocated) 方法会对分配出来的 Container 资源进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContainersAllocated</span><span class="params">(List&lt;Container&gt; allocatedContainers)</span> </span>&#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Got response from RM for container ask, allocatedCnt=&quot;</span></span><br><span class="line">          + allocatedContainers.size());</span><br><span class="line">      numAllocatedContainers.addAndGet(allocatedContainers.size());</span><br><span class="line">      <span class="keyword">for</span> (Container allocatedContainer : allocatedContainers) &#123;</span><br><span class="line">        String yarnShellId = Integer.toString(yarnShellIdCounter);</span><br><span class="line">        yarnShellIdCounter++;</span><br><span class="line">        LOG.info(<span class="string">&quot;Launching shell command on a new container.&quot;</span></span><br><span class="line">            + <span class="string">&quot;, containerId=&quot;</span> + allocatedContainer.getId()</span><br><span class="line">            + <span class="string">&quot;, yarnShellId=&quot;</span> + yarnShellId</span><br><span class="line">            + <span class="string">&quot;, containerNode=&quot;</span> + allocatedContainer.getNodeId().getHost()</span><br><span class="line">            + <span class="string">&quot;:&quot;</span> + allocatedContainer.getNodeId().getPort()</span><br><span class="line">            + <span class="string">&quot;, containerNodeURI=&quot;</span> + allocatedContainer.getNodeHttpAddress()</span><br><span class="line">            + <span class="string">&quot;, containerResourceMemory&quot;</span></span><br><span class="line">            + allocatedContainer.getResource().getMemory()</span><br><span class="line">            + <span class="string">&quot;, containerResourceVirtualCores&quot;</span></span><br><span class="line">            + allocatedContainer.getResource().getVirtualCores());</span><br><span class="line">        <span class="comment">// + &quot;, containerToken&quot;</span></span><br><span class="line">        <span class="comment">// +allocatedContainer.getContainerToken().getIdentifier().toString());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建运行 Container 的 LaunchContainerRunnable 线程</span></span><br><span class="line">        Thread launchThread = createLaunchContainerThread(allocatedContainer,</span><br><span class="line">            yarnShellId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// launch and start the container on a separate thread to keep</span></span><br><span class="line">        <span class="comment">// the main thread unblocked</span></span><br><span class="line">        <span class="comment">// as all containers may not be allocated at one go.</span></span><br><span class="line">        launchThreads.add(launchThread);</span><br><span class="line">        launchedContainers.add(allocatedContainer.getId());</span><br><span class="line">        <span class="comment">// 启动 LaunchContainerRunnable 线程</span></span><br><span class="line">        launchThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="function">Thread <span class="title">createLaunchContainerThread</span><span class="params">(Container allocatedContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">        String shellId)</span> </span>&#123;</span><br><span class="line">      LaunchContainerRunnable runnableLaunchContainer =</span><br><span class="line">          <span class="keyword">new</span> LaunchContainerRunnable(allocatedContainer, containerListener,</span><br><span class="line">              shellId);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Thread(runnableLaunchContainer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的逻辑启动了一个 LaunchContainerRunnable 线程，LaunchContainerRunnable 是 ApplicationMaster 类的内部类，继承自 Runnable 接口，通过该类的 run() 方法，可以知道该类主要做了两件事：</p>
<ul>
<li>初始化 Contianer 的本地资源，并构建 Container 的启动脚本</li>
<li>调用 NMClientAsync#startContainerAsync() api 接口启动 Container。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Setting up container launch container for containerid=&quot;</span></span><br><span class="line">          + container.getId() + <span class="string">&quot; with shellid=&quot;</span> + shellId);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略构建 Container 启动脚本逻辑</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set up ContainerLaunchContext, setting local resource, environment,</span></span><br><span class="line">      <span class="comment">// command and token for constructor.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Note for tokens: Set up tokens for the container too. Today, for normal</span></span><br><span class="line">      <span class="comment">// shell commands, the container in distribute-shell doesn&#x27;t need any</span></span><br><span class="line">      <span class="comment">// tokens. We are populating them mainly for NodeManagers to be able to</span></span><br><span class="line">      <span class="comment">// download anyfiles in the distributed file-system. The tokens are</span></span><br><span class="line">      <span class="comment">// otherwise also useful in cases, for e.g., when one is running a</span></span><br><span class="line">      <span class="comment">// &quot;hadoop dfs&quot; command inside the distributed shell.</span></span><br><span class="line">      Map&lt;String, String&gt; myShellEnv = <span class="keyword">new</span> HashMap&lt;String, String&gt;(shellEnv);</span><br><span class="line">      myShellEnv.put(YARN_SHELL_ID, shellId);</span><br><span class="line">      ContainerLaunchContext ctx = ContainerLaunchContext.newInstance(</span><br><span class="line">        localResources, myShellEnv, commands, <span class="keyword">null</span>, allTokens.duplicate(),</span><br><span class="line">          <span class="keyword">null</span>);</span><br><span class="line">      containerListener.addContainer(container.getId(), container);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 重点：通过 NMClientAsync api 启动分配出来的 Container</span></span><br><span class="line">      nmClientAsync.startContainerAsync(container, ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 nmClientAsync.startContainerAsync() 方法并没有真正启动 Container，而是将 ContainerEventType.START_CONTAINER 事件封装成 ContainerEvent 对象（StartContainerEvent 类继承自 ContainerEvent 类），并添加到 Container 事件处理的阻塞队列 events 中，具体操作处理流程由 events 队列的消费逻辑处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startContainerAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Container container, ContainerLaunchContext containerLaunchContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (containers.putIfAbsent(container.getId(),</span><br><span class="line">        <span class="keyword">new</span> StatefulContainer(<span class="keyword">this</span>, container.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      callbackHandler.onStartContainerError(container.getId(),</span><br><span class="line">          RPCUtil.getRemoteException(<span class="string">&quot;Container &quot;</span> + container.getId() +</span><br><span class="line">              <span class="string">&quot; is already started or scheduled to start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      events.put(<span class="keyword">new</span> StartContainerEvent(container, containerLaunchContext));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">&quot;Exception when scheduling the event of starting Container &quot;</span> +</span><br><span class="line">          container.getId());</span><br><span class="line">      callbackHandler.onStartContainerError(container.getId(), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那这里的阻塞队列 events 又是怎么处理呢？还是来找找 events.take() 方法，发现在 NMClientAsyncImpl 类执行 serviceStart() 方法时会启动一个线程去消费 events 队列的事件，队列取出来的事件对象为内部封装有 ContainerEventType.START_CONTAINER 事件的 ContainerEvent 对象，通过 getContainerEventProcessor(event) 方法，获取对应的 ContainerEvent 对象的处理器 ContainerEventProcessor，并以线程池的方式运行该处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serviceStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    client.start();</span><br><span class="line"></span><br><span class="line">    ThreadFactory tf = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(</span><br><span class="line">        <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot; #%d&quot;</span>).setDaemon(<span class="keyword">true</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with a default core-pool size and change it dynamically.</span></span><br><span class="line">    <span class="keyword">int</span> initSize = Math.min(INITIAL_THREAD_POOL_SIZE, maxThreadPoolSize);</span><br><span class="line">    threadPool = <span class="keyword">new</span> ThreadPoolExecutor(initSize, Integer.MAX_VALUE, <span class="number">1</span>,</span><br><span class="line">        TimeUnit.HOURS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), tf);</span><br><span class="line"></span><br><span class="line">    eventDispatcherThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ContainerEvent event = <span class="keyword">null</span>;</span><br><span class="line">        Set&lt;String&gt; allNodes = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stopped.get() &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 从阻塞队列 events 中取出 ContainerEvent 事件</span></span><br><span class="line">            event = events.take();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stopped.get()) &#123;</span><br><span class="line">              LOG.error(<span class="string">&quot;Returning, thread interrupted&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          allNodes.add(event.getNodeId().toString());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> threadPoolSize = threadPool.getCorePoolSize();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can increase the pool size only if haven&#x27;t reached the maximum</span></span><br><span class="line">          <span class="comment">// limit yet.</span></span><br><span class="line">          <span class="keyword">if</span> (threadPoolSize != maxThreadPoolSize) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nodes where containers will run at *this* point of time. This is</span></span><br><span class="line">            <span class="comment">// *not* the cluster size and doesn&#x27;t need to be.</span></span><br><span class="line">            <span class="keyword">int</span> nodeNum = allNodes.size();</span><br><span class="line">            <span class="keyword">int</span> idealThreadPoolSize = Math.min(maxThreadPoolSize, nodeNum);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (threadPoolSize &lt; idealThreadPoolSize) &#123;</span><br><span class="line">              <span class="comment">// Bump up the pool size to idealThreadPoolSize +</span></span><br><span class="line">              <span class="comment">// INITIAL_POOL_SIZE, the later is just a buffer so we are not</span></span><br><span class="line">              <span class="comment">// always increasing the pool-size</span></span><br><span class="line">              <span class="keyword">int</span> newThreadPoolSize = Math.min(maxThreadPoolSize,</span><br><span class="line">                  idealThreadPoolSize + INITIAL_THREAD_POOL_SIZE);</span><br><span class="line">              LOG.info(<span class="string">&quot;Set NMClientAsync thread pool size to &quot;</span> +</span><br><span class="line">                  newThreadPoolSize + <span class="string">&quot; as the number of nodes to talk to is &quot;</span></span><br><span class="line">                  + nodeNum);</span><br><span class="line">              threadPool.setCorePoolSize(newThreadPoolSize);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 重点：根据获取到的 Container 事件类型为 ContainerEventType.START_CONTAINER</span></span><br><span class="line">          <span class="comment">// getContainerEventProcessor(event) 返回一个 ContainerEventProcessor 线程对象，并在线程池中启动</span></span><br><span class="line">          threadPool.execute(getContainerEventProcessor(event));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    eventDispatcherThread.setName(<span class="string">&quot;Container  Event Dispatcher&quot;</span>);</span><br><span class="line">    eventDispatcherThread.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">    eventDispatcherThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.serviceStart();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerEventProcessor 处理器类是 NMClientAsyncImpl 类的内部类，继承自 Runnable 类，那我们来看看该类的 run() 方法，根据事件类型 ContainerEventType.START_CONTAINER 进入到对应的执行逻辑中，并通过 handle() 方法交给对应的状态机执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ContainerId containerId = event.getContainerId();</span><br><span class="line">      LOG.info(<span class="string">&quot;Processing Event &quot;</span> + event + <span class="string">&quot; for Container &quot;</span> + containerId);</span><br><span class="line">      <span class="comment">// 对 ContainerEventType.QUERY_CONTAINER 事件单独处理</span></span><br><span class="line">      <span class="keyword">if</span> (event.getType() == ContainerEventType.QUERY_CONTAINER) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ContainerStatus containerStatus = client.getContainerStatus(</span><br><span class="line">              containerId, event.getNodeId());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            callbackHandler.onContainerStatusReceived(</span><br><span class="line">                containerId, containerStatus);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t process user created unchecked exception</span></span><br><span class="line">            LOG.info(</span><br><span class="line">                <span class="string">&quot;Unchecked exception is thrown from onContainerStatusReceived&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; for Container &quot;</span> + event.getContainerId(), thr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">          onExceptionRaised(containerId, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          onExceptionRaised(containerId, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          onExceptionRaised(containerId, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ContainerEventType.START_CONTAINER 和 ContainerEventType.STOP_CONTAINER 事件处理逻辑</span></span><br><span class="line">        StatefulContainer container = containers.get(containerId);</span><br><span class="line">        <span class="keyword">if</span> (container == <span class="keyword">null</span>) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;Container &quot;</span> + containerId + <span class="string">&quot; is already stopped or failed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据事件类型交给对应的状态机处理</span></span><br><span class="line">          container.handle(event);</span><br><span class="line">          <span class="keyword">if</span> (isCompletelyDone(container)) &#123;</span><br><span class="line">            containers.remove(containerId);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerEventType.START_CONTAINER 事件的注册状态机为 StartContainerTransition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">    <span class="comment">// Transitions from PREP state</span></span><br><span class="line">    .addTransition(ContainerState.PREP,</span><br><span class="line">        EnumSet.of(ContainerState.RUNNING, ContainerState.FAILED),</span><br><span class="line">        ContainerEventType.START_CONTAINER,</span><br><span class="line">        <span class="keyword">new</span> StartContainerTransition())</span><br></pre></td></tr></table></figure>

<p>StartContainerTransition 状态机里的转换方法 transition()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> ContainerState <span class="title">transition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          StatefulContainer container, ContainerEvent event)</span> </span>&#123;</span><br><span class="line">        ContainerId containerId = event.getContainerId();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          StartContainerEvent scEvent = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (event <span class="keyword">instanceof</span> StartContainerEvent) &#123;</span><br><span class="line">            scEvent = (StartContainerEvent) event;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">assert</span> scEvent != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//重点：调用 NMClient 类的 startContainer() 启动 Container</span></span><br><span class="line">          Map&lt;String, ByteBuffer&gt; allServiceResponse =</span><br><span class="line">              container.nmClientAsync.getClient().startContainer(</span><br><span class="line">                  scEvent.getContainer(), scEvent.getContainerLaunchContext());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 通过回调的方式更新 Container 状态</span></span><br><span class="line">            container.nmClientAsync.getCallbackHandler().onContainerStarted(</span><br><span class="line">                containerId, allServiceResponse);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t process user created unchecked exception</span></span><br><span class="line">            LOG.info(<span class="string">&quot;Unchecked exception is thrown from onContainerStarted for &quot;</span></span><br><span class="line">                + <span class="string">&quot;Container &quot;</span> + containerId, thr);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 返回 Container 的 RUNNING 状态</span></span><br><span class="line">          <span class="keyword">return</span> ContainerState.RUNNING;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">          <span class="keyword">return</span> onExceptionRaised(container, event, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">return</span> onExceptionRaised(container, event, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="keyword">return</span> onExceptionRaised(container, event, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在这里看到了激动人心的 startContainer() 方法，不过别急，这里还没有到真正的启动 Container 的时候，这里首先获取到 AM 真正与 NM 交互的客户端 NMClient，并调用其实现类 NMClientImpl 的 startContainer() 方法，获取到与 NM 交互的 RPC 协议 ContainerManagementProtocol，并通过其协议的 startContainers() 方法实现 RPC 远程调用，来实现 Container 的启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/client/api/impl/NMClientImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, ByteBuffer&gt; <span class="title">startContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Container container, ContainerLaunchContext containerLaunchContext)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> YarnException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 构建 StartContainer 对象</span></span><br><span class="line">    StartedContainer startingContainer =</span><br><span class="line">        <span class="keyword">new</span> StartedContainer(container.getId(), container.getNodeId());</span><br><span class="line">    <span class="keyword">synchronized</span> (startingContainer) &#123;</span><br><span class="line">      addStartingContainer(startingContainer);</span><br><span class="line">      </span><br><span class="line">      Map&lt;String, ByteBuffer&gt; allServiceResponse;</span><br><span class="line">      ContainerManagementProtocolProxyData proxy = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        proxy =</span><br><span class="line">            cmProxy.getProxy(container.getNodeId().toString(),</span><br><span class="line">                container.getId());</span><br><span class="line">        StartContainerRequest scRequest =</span><br><span class="line">            StartContainerRequest.newInstance(containerLaunchContext,</span><br><span class="line">              container.getContainerToken());</span><br><span class="line">        List&lt;StartContainerRequest&gt; list = <span class="keyword">new</span> ArrayList&lt;StartContainerRequest&gt;();</span><br><span class="line">        list.add(scRequest);</span><br><span class="line">        StartContainersRequest allRequests =</span><br><span class="line">            StartContainersRequest.newInstance(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点：获取到 RPC 调用协议 ContainerManagementProtocol，并通过 RPC 函数 startContainers 启动 Container</span></span><br><span class="line">        StartContainersResponse response =</span><br><span class="line">            proxy</span><br><span class="line">                .getContainerManagementProtocol().startContainers(allRequests);</span><br><span class="line">        <span class="keyword">if</span> (response.getFailedRequests() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; response.getFailedRequests().containsKey(container.getId())) &#123;</span><br><span class="line">          Throwable t =</span><br><span class="line">              response.getFailedRequests().get(container.getId()).deSerialize();</span><br><span class="line">          parseAndThrowException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        allServiceResponse = response.getAllServicesMetaData();</span><br><span class="line">        startingContainer.state = ContainerState.RUNNING;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">        <span class="comment">// 省略异常的状态返回</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">          cmProxy.mayBeCloseProxy(proxy);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> allServiceResponse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>NMClient 调用 RPC 函数 ContainerManagementProtocol#startContainers() 启动 Container。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StartContainersResponse</span></span><br><span class="line"><span class="function">      <span class="title">startContainers</span><span class="params">(StartContainersRequest requests)</span> <span class="keyword">throws</span> YarnException,</span></span><br><span class="line"><span class="function">          IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blockNewContainerRequests.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NMNotYetReadyException(</span><br><span class="line">        <span class="string">&quot;Rejecting new containers as NodeManager has not&quot;</span></span><br><span class="line">            + <span class="string">&quot; yet connected with ResourceManager&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    UserGroupInformation remoteUgi = getRemoteUgi();</span><br><span class="line">    NMTokenIdentifier nmTokenIdentifier = selectNMTokenIdentifier(remoteUgi);</span><br><span class="line">    authorizeUser(remoteUgi,nmTokenIdentifier);</span><br><span class="line">    List&lt;ContainerId&gt; succeededContainers = <span class="keyword">new</span> ArrayList&lt;ContainerId&gt;();</span><br><span class="line">    Map&lt;ContainerId, SerializedException&gt; failedContainers =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;ContainerId, SerializedException&gt;();</span><br><span class="line">    <span class="keyword">for</span> (StartContainerRequest request : requests.getStartContainerRequests()) &#123;</span><br><span class="line">      ContainerId containerId = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ContainerTokenIdentifier containerTokenIdentifier =</span><br><span class="line">            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());</span><br><span class="line">        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),</span><br><span class="line">          containerTokenIdentifier);</span><br><span class="line">        containerId = containerTokenIdentifier.getContainerID();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 Contain 的内部逻辑</span></span><br><span class="line">        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,</span><br><span class="line">          request);</span><br><span class="line">        succeededContainers.add(containerId);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">        failedContainers.put(containerId, SerializedException.newInstance(e));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvalidToken ie) &#123;</span><br><span class="line">        failedContainers.put(containerId, SerializedException.newInstance(ie));</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RPCUtil.getRemoteException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StartContainersResponse.newInstance(getAuxServiceMetaData(),</span><br><span class="line">      succeededContainers, failedContainers);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，AM 与 NM 的交互流程已实现，通过  RPC 函数 ContainerManagementProtocol#startContainers() 来启动 Container，那 Container 又是如何在 NM 上启动的呢？这一块我们留在后面介绍。</p>
<h2 id="2-2-Container资源本地化"><a href="#2-2-Container资源本地化" class="headerlink" title="2.2 Container资源本地化"></a>2.2 Container资源本地化</h2><p>上面过程中 AM 通过调用 RPC 函数 ContainerManagementProtocol#startContainers() 开始启动 Container，这部分我们来看看具体的启动逻辑，即 startContainerInternal() 方法。这里做了两件事</p>
<ul>
<li>发送 ApplicationEventType.INIT_APPLICATION 事件，对应用程序资源的初始化，主要是初始化各类必需的服务组件（如日志记录组件 LogHandler、资源状态追踪组件 LocalResourcesTrackerImpl等），供后续 Container 启动，通常来自 ApplicationMaster 的第一个 Container 完成，后续的 Container 跳过这段 Application 初始化过程。</li>
<li>发送 ApplicationEventType.INIT_CONTAINER 事件，对 Container 进行初始化操作。（这部分事件留在 Container 启动环节介绍）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startContainerInternal</span><span class="params">(NMTokenIdentifier nmTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      ContainerTokenIdentifier containerTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      StartContainerRequest request)</span> <span class="keyword">throws</span> YarnException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略Token认证及ContainerLaunchContext上下文初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!serviceStopped) &#123;</span><br><span class="line">        <span class="comment">// Create the application</span></span><br><span class="line">        Application application =</span><br><span class="line">            <span class="keyword">new</span> ApplicationImpl(dispatcher, user, applicationID, credentials, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 应用程序的初始化，供后续Container使用，这个逻辑只调用一次，通常由来自ApplicationMaster的第一个Container完成</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == context.getApplications().putIfAbsent(applicationID,</span><br><span class="line">          application)) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;Creating a new application reference for app &quot;</span> + applicationID);</span><br><span class="line">          LogAggregationContext logAggregationContext =</span><br><span class="line">              containerTokenIdentifier.getLogAggregationContext();</span><br><span class="line">          Map&lt;ApplicationAccessType, String&gt; appAcls =</span><br><span class="line">              container.getLaunchContext().getApplicationACLs();</span><br><span class="line">          context.getNMStateStore().storeApplication(applicationID,</span><br><span class="line">              buildAppProto(applicationID, user, credentials, appAcls,</span><br><span class="line">                logAggregationContext));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.向 ApplicationImpl 发送 ApplicationEventType.INIT_APPLICATION 事件</span></span><br><span class="line">          dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ApplicationInitEvent(applicationID, appAcls,</span><br><span class="line">              logAggregationContext));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.向 ApplicationImpl 发送 ApplicationEventType.INIT_CONTAINER 事件</span></span><br><span class="line">        <span class="keyword">this</span>.context.getNMStateStore().storeContainer(containerId, request);</span><br><span class="line">        dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> ApplicationContainerInitEvent(container));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.context.getContainerTokenSecretManager().startContainerSuccessful(</span><br><span class="line">          containerTokenIdentifier);</span><br><span class="line">        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,</span><br><span class="line">          <span class="string">&quot;ContainerManageImpl&quot;</span>, applicationID, containerId);</span><br><span class="line">        <span class="comment">// TODO launchedContainer misplaced -&gt; doesn&#x27;t necessarily mean a container</span></span><br><span class="line">        <span class="comment">// launch. A finished Application will not launch containers.</span></span><br><span class="line">        metrics.launchedContainer();</span><br><span class="line">        metrics.allocateContainer(containerTokenIdentifier.getResource());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> YarnException(</span><br><span class="line">            <span class="string">&quot;Container start failed as the NodeManager is &quot;</span> +</span><br><span class="line">            <span class="string">&quot;in the process of shutting down&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationEventType.INIT_APPLICATION 事件的状态转换过程，状态由 NEW 转变为 INITING，对应的状态机为 AppInitTransition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">           <span class="comment">// Transitions from NEW state</span></span><br><span class="line">     .addTransition(ApplicationState.NEW, ApplicationState.INITING,</span><br><span class="line">         ApplicationEventType.INIT_APPLICATION, <span class="keyword">new</span> AppInitTransition())</span><br></pre></td></tr></table></figure>

<p>AppInitTransition 状态机设置 ACL 属性后，并向 LogHandler（目前有两种实现方式，分别是 LogAggregationService 和 NonAggregatingLogHandler 发送一个 LogHandlerEventType.APPLICATION_STARTED 事件。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">SingleArcTransition</span>&lt;<span class="title">ApplicationImpl</span>, <span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ApplicationImpl app, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">      ApplicationInitEvent initEvent = (ApplicationInitEvent)event;</span><br><span class="line">      <span class="comment">// 设置 ACL 属性</span></span><br><span class="line">      app.applicationACLs = initEvent.getApplicationACLs();</span><br><span class="line">      app.aclsManager.addApplication(app.getAppId(), app.applicationACLs);</span><br><span class="line">      <span class="comment">// Inform the logAggregator</span></span><br><span class="line">      app.logAggregationContext = initEvent.getLogAggregationContext();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向 LogHandler 发送 LogHandlerEventType.APPLICATION_STARTED 事件</span></span><br><span class="line">      app.dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> LogHandlerAppStartedEvent(app.appId, app.user,</span><br><span class="line">              app.credentials, ContainerLogsRetentionPolicy.ALL_CONTAINERS,</span><br><span class="line">              app.applicationACLs, app.logAggregationContext)); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里以 LogAggregationService 服务为例，当 LogHandler 收到 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件后，将创建应用程序日志目录、设置目录权限等。然后向 ApplicationImpl 发送一个 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LogHandlerEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> APPLICATION_STARTED:</span><br><span class="line">        LogHandlerAppStartedEvent appStartEvent =</span><br><span class="line">            (LogHandlerAppStartedEvent) event;</span><br><span class="line">        <span class="comment">// 事情处理逻辑</span></span><br><span class="line">        initApp(appStartEvent.getApplicationId(), appStartEvent.getUser(),</span><br><span class="line">            appStartEvent.getCredentials(),</span><br><span class="line">            appStartEvent.getLogRetentionPolicy(),</span><br><span class="line">            appStartEvent.getApplicationAcls(),</span><br><span class="line">            appStartEvent.getLogAggregationContext());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CONTAINER_FINISHED:  <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> APPLICATION_FINISHED:  <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ; <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initApp</span><span class="params">(<span class="keyword">final</span> ApplicationId appId, String user,</span></span></span><br><span class="line"><span class="params"><span class="function">      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">      Map&lt;ApplicationAccessType, String&gt; appAcls,</span></span></span><br><span class="line"><span class="params"><span class="function">      LogAggregationContext logAggregationContext)</span> </span>&#123;</span><br><span class="line">    ApplicationEvent eventResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建应用程序日志目录、设置目录权限等</span></span><br><span class="line">      verifyAndCreateRemoteLogDir(getConfig());</span><br><span class="line">      initAppAggregator(appId, user, credentials, logRetentionPolicy, appAcls,</span><br><span class="line">          logAggregationContext);</span><br><span class="line">      eventResponse = <span class="keyword">new</span> ApplicationEvent(appId,</span><br><span class="line">          ApplicationEventType.APPLICATION_LOG_HANDLING_INITED);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (YarnRuntimeException e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">&quot;Application failed to init aggregation&quot;</span>, e);</span><br><span class="line">      eventResponse = <span class="keyword">new</span> ApplicationEvent(appId,</span><br><span class="line">          ApplicationEventType.APPLICATION_LOG_HANDLING_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向 ApplicationImpl 发送 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件</span></span><br><span class="line">    <span class="keyword">this</span>.dispatcher.getEventHandler().handle(eventResponse);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationImpl 收到 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件后，直接向 ResourceLocalizationService 发送 LocalizationEventType.INIT_APPLICATION_RESOURCES 事件，此时 ApplicationImpl 仍处于 INITING 状态。ResourceLocalizationService 收到事件请求时进入到 handle() 逻辑处理，这里会创建一个 LocalResourcesTrackerImpl 对象，为接下来资源下载做准备，并向 ApplicationImpl 发送一个 ApplicationEventType.APPLICATION_INITED 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> create log dir as $logdir/$user/$appId</span></span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INIT_APPLICATION_RESOURCES:  <span class="comment">// 处理 LocalizationEventType.INIT_APPLICATION_RESOURCES 事件</span></span><br><span class="line">      handleInitApplicationResources(</span><br><span class="line">          ((ApplicationLocalizationEvent)event).getApplication());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INIT_CONTAINER_RESOURCES: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESOURCES_LOCALIZED:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CACHE_CLEANUP:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CLEANUP_CONTAINER_RESOURCES: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> DESTROY_APPLICATION_RESOURCES: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;Unknown localization event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleInitApplicationResources</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line">    String userName = app.getUser();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 LocalResourcesTrackerImpl 对象，为接下来的资源下载做准备</span></span><br><span class="line">    privateRsrc.putIfAbsent(userName, <span class="keyword">new</span> LocalResourcesTrackerImpl(userName,</span><br><span class="line">        <span class="keyword">null</span>, dispatcher, <span class="keyword">true</span>, <span class="keyword">super</span>.getConfig(), stateStore));</span><br><span class="line">    String appIdStr = ConverterUtils.toString(app.getAppId());</span><br><span class="line">    appRsrc.putIfAbsent(appIdStr, <span class="keyword">new</span> LocalResourcesTrackerImpl(app.getUser(),</span><br><span class="line">        app.getAppId(), dispatcher, <span class="keyword">false</span>, <span class="keyword">super</span>.getConfig(), stateStore));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向 ApplicationImpl 发送 ApplicationEventType.APPLICATION_INITED 事件</span></span><br><span class="line">    dispatcher.getEventHandler().handle(<span class="keyword">new</span> ApplicationInitedEvent(</span><br><span class="line">          app.getAppId()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationImpl 收到 ApplicationEventType.APPLICATION_INITED 事件后，依次向该应用程序已经保持的所有 Container 发送一个 INIT_CONTAINER 事件以通知它们进行初始化。此时，ApplicationImpl 运行状态由 INITING 转换为 RUNNING。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitDoneTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">SingleArcTransition</span>&lt;<span class="title">ApplicationImpl</span>, <span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ApplicationImpl app, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Start all the containers waiting for ApplicationInit</span></span><br><span class="line">      <span class="keyword">for</span> (Container container : app.containers.values()) &#123;</span><br><span class="line">        <span class="comment">// 向应用程序保存的 Container 发送 INIT_CONTAINER 事件</span></span><br><span class="line">        app.dispatcher.getEventHandler().handle(<span class="keyword">new</span> ContainerInitEvent(</span><br><span class="line">              container.getContainerId()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerImpl 收到 INIT_CONTAINER 事件后，先向附属服务 AuxServices 发送 APPLICATION_INIT 事件，以通知它有新的应用程序 Container 启动，然后从 ContainerLaunchContext 中获取各类可见性资源，并保存到 ContainerImpl 中特定的数据结构中，之后向 ResourceLocalizationService 发送 LocalizationEventType.INIT_CONTAINER_RESOURCES 事件，此时 ContainerImpl 运行状态已由 NEW 转换为 LOCALIZING。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResourcesTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">MultipleArcTransition</span>&lt;<span class="title">ContainerImpl</span>,<span class="title">ContainerEvent</span>,<span class="title">ContainerState</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContainerState <span class="title">transition</span><span class="params">(ContainerImpl container,</span></span></span><br><span class="line"><span class="params"><span class="function">        ContainerEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 向 AuxService 发送 AuxServicesEventType.CONTAINER_INIT 事件</span></span><br><span class="line">      container.dispatcher.getEventHandler().handle(<span class="keyword">new</span> AuxServicesEvent</span><br><span class="line">          (AuxServicesEventType.CONTAINER_INIT, container));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Inform the AuxServices about the opaque serviceData</span></span><br><span class="line">      Map&lt;String,ByteBuffer&gt; csd = ctxt.getServiceData();</span><br><span class="line">      <span class="keyword">if</span> (csd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This can happen more than once per Application as each container may</span></span><br><span class="line">        <span class="comment">// have distinct service data</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,ByteBuffer&gt; service : csd.entrySet()) &#123;</span><br><span class="line">          container.dispatcher.getEventHandler().handle(</span><br><span class="line">              <span class="keyword">new</span> AuxServicesEvent(AuxServicesEventType.APPLICATION_INIT,</span><br><span class="line">                  container.user, container.containerId</span><br><span class="line">                      .getApplicationAttemptId().getApplicationId(),</span><br><span class="line">                  service.getKey().toString(), service.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      container.containerLocalizationStartTime = clock.getTime();</span><br><span class="line">      <span class="comment">// 从 ContainerLaunchContext 获取各类资源，并保持在数据结构中</span></span><br><span class="line">      Map&lt;String,LocalResource&gt; cntrRsrc = ctxt.getLocalResources();</span><br><span class="line">      <span class="keyword">if</span> (!cntrRsrc.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;String,LocalResource&gt; rsrc : cntrRsrc.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              LocalResourceRequest req =</span><br><span class="line">                  <span class="keyword">new</span> LocalResourceRequest(rsrc.getValue());</span><br><span class="line">              List&lt;String&gt; links = container.pendingResources.get(req);</span><br><span class="line">              <span class="keyword">if</span> (links == <span class="keyword">null</span>) &#123;</span><br><span class="line">                links = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                container.pendingResources.put(req, links);</span><br><span class="line">              &#125;</span><br><span class="line">              links.add(rsrc.getKey());</span><br><span class="line">              <span class="keyword">switch</span> (rsrc.getValue().getVisibility()) &#123;</span><br><span class="line">              <span class="keyword">case</span> PUBLIC:</span><br><span class="line">                container.publicRsrcs.add(req);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> PRIVATE:</span><br><span class="line">                container.privateRsrcs.add(req);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> APPLICATION:</span><br><span class="line">                container.appRsrcs.add(req);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">              LOG.info(<span class="string">&quot;Got exception parsing &quot;</span> + rsrc.getKey()</span><br><span class="line">                  + <span class="string">&quot; and value &quot;</span> + rsrc.getValue());</span><br><span class="line">              <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向 ResourceLocalizationService 发送 LocalizationEventType.INIT_CONTAINER_RESOURCES 事件</span></span><br><span class="line">        container.dispatcher.getEventHandler().handle(</span><br><span class="line">              <span class="keyword">new</span> ContainerLocalizationRequestEvent(container, req));</span><br><span class="line">        <span class="keyword">return</span> ContainerState.LOCALIZING;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这种情况是 Contaienr 已经进行了资源初始化操作，这里直接运行 Container</span></span><br><span class="line">        container.sendLaunchEvent();</span><br><span class="line">        container.metrics.endInitingContainer();</span><br><span class="line">        <span class="keyword">return</span> ContainerState.LOCALIZED;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ResourceLocalizationService 收到 LocalizationEventType.INIT_CONTAINER_RESOURCES 事件后，依次将 Container 所需的资源封装成一个 REQUEST 事件，发送给对应的资源状态追踪器 LocalResourcesTrackerImpl。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> create log dir as $logdir/$user/$appId</span></span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INIT_APPLICATION_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> INIT_CONTAINER_RESOURCES:</span><br><span class="line">       <span class="comment">// 将 Container 所需的资源单独封装成一个 REQUEST 事件，发送给对应的资源状态跟踪器 LocalResourcesTrackerImpl</span></span><br><span class="line">      handleInitContainerResources((ContainerLocalizationRequestEvent) event);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESOURCES_LOCALIZED:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CACHE_CLEANUP:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CLEANUP_CONTAINER_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> DESTROY_APPLICATION_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;Unknown localization event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>LocalResourcesTrackerImpl 收到 REQUEST 事件后，将为对应的资源创建一个状态机对象 LocalizeResource 以跟踪资源的生命周期，并将 REQUEST 事件进一步传送给 LocalizedResource。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/LocalizedResource.java</span></span><br><span class="line">    <span class="comment">// From INIT (ref == 0, awaiting req)</span></span><br><span class="line">    .addTransition(ResourceState.INIT, ResourceState.DOWNLOADING,</span><br><span class="line">        ResourceEventType.REQUEST, <span class="keyword">new</span> FetchResourceTransition())</span><br></pre></td></tr></table></figure>

<p>LocalizedResource 收到 REQUEST 事件后，将待下载资源信息通过 LocalizerEventType.REQUEST_RESOURCE_LOCALIZATION 事件发送给资源下载服务 ResourceLocalizationService，之后 LocalizedResource 状态由 NEW 转换为 DOWNLOADING。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/LocalizedResource.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchResourceTransition</span> <span class="keyword">extends</span> <span class="title">ResourceTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(LocalizedResource rsrc, ResourceEvent event)</span> </span>&#123;</span><br><span class="line">      ResourceRequestEvent req = (ResourceRequestEvent) event;</span><br><span class="line">      LocalizerContext ctxt = req.getContext();</span><br><span class="line">      ContainerId container = ctxt.getContainerId();</span><br><span class="line">      rsrc.ref.add(container);</span><br><span class="line">      rsrc.dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> LocalizerResourceRequestEvent(rsrc, req.getVisibility(), ctxt, </span><br><span class="line">              req.getLocalResourceRequest().getPattern()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ResourceLocalizationService 收到 LocalizerEventType.REQUEST_RESOURCE_LOCALIZATION 事件后，将交给 LocalizerTracker 服务处理，如果是 PUBLIC 资源，则统一交给 PublicLocalizer 处理，否则检查是否已经为该 Container 创建了 LocalizerRunner 线程，如果没有，则创建一个，否则直接添加到该线程的下载队列中。该线程会调用 ContainerExecutor#startLocalizer() 函数下载资源，该函数通过协议 LocalizationProtocol 与 ResourceLocalizationService 通信，以顺序获取待下载资源位置下载。待资源下载完成后，PublicLocalize 或者 LocalizerRunner 都会向 LocalizedResource 发送一个 LOCALIZED 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizerEvent event)</span> </span>&#123;</span><br><span class="line">      String locId = event.getLocalizerId();</span><br><span class="line">      <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> REQUEST_RESOURCE_LOCALIZATION:</span><br><span class="line">        <span class="comment">// 0) find running localizer or start new thread</span></span><br><span class="line">        LocalizerResourceRequestEvent req =</span><br><span class="line">          (LocalizerResourceRequestEvent)event;</span><br><span class="line">        <span class="comment">//根据 REQUEST 资源判断资源的可见性</span></span><br><span class="line">        <span class="keyword">switch</span> (req.getVisibility()) &#123;</span><br><span class="line">        <span class="comment">// 如果是 PUBLIC 资源，则交给线程 PublicLocalizer 处理</span></span><br><span class="line">        <span class="keyword">case</span> PUBLIC:</span><br><span class="line">          publicLocalizer.addResource(req);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PRIVATE:</span><br><span class="line">        <span class="keyword">case</span> APPLICATION:</span><br><span class="line">          <span class="keyword">synchronized</span> (privLocalizers) &#123;</span><br><span class="line">            LocalizerRunner localizer = privLocalizers.get(locId);</span><br><span class="line">            <span class="comment">// 检查是否创建了 LocalizerRunner 线程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == localizer) &#123;</span><br><span class="line">              LOG.info(<span class="string">&quot;Created localizer for &quot;</span> + locId);</span><br><span class="line">              localizer = <span class="keyword">new</span> LocalizerRunner(req.getContext(), locId);</span><br><span class="line">              privLocalizers.put(locId, localizer);</span><br><span class="line">              localizer.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1) propagate event</span></span><br><span class="line">            localizer.addResource(req);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LocalizedResource 收到 LOCALIZED 事件后，会向 ContainerImpl 发送一个 ContainerEventType.RESOURCE_LOCALIZED 事件，并且将状态从 DOWNLOADING 转换为 LOCALIZED。ContainerImpl 收到事件后，会检查所依赖的资源是否全部下载完毕，如果下载完成则向 ContainersLauncher 服务发送一个 LAUNCH_CONTAINER 事件，以启动对应 Container。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/LocalizedResource.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchSuccessTransition</span> <span class="keyword">extends</span> <span class="title">ResourceTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(LocalizedResource rsrc, ResourceEvent event)</span> </span>&#123;</span><br><span class="line">      ResourceLocalizedEvent locEvent = (ResourceLocalizedEvent) event;</span><br><span class="line">      rsrc.localPath =</span><br><span class="line">          Path.getPathWithoutSchemeAndAuthority(locEvent.getLocation());</span><br><span class="line">      rsrc.size = locEvent.getSize();</span><br><span class="line">      <span class="keyword">for</span> (ContainerId container : rsrc.ref) &#123;</span><br><span class="line">        <span class="comment">// 向 ContainerImpl 发送 ContainerEventType.RESOURCE_LOCALIZED 事件</span></span><br><span class="line">        rsrc.dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ContainerResourceLocalizedEvent(</span><br><span class="line">              container, rsrc.rsrc, rsrc.localPath));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，Container 资源本地化资源已下载完毕，接下来就开始启动和运行 Container。</p>
<h2 id="2-3-启动和运行Container"><a href="#2-3-启动和运行Container" class="headerlink" title="2.3 启动和运行Container"></a>2.3 启动和运行Container</h2><p>Container 运行是由 ContainersLauncher 服务实现的，主要过程可概括为：将待运行的 Container 所需的环境和运行命令写到 Shell 脚本 launch_container.sh 脚本中，并将启动该脚本的命令写入 default_container_executro.sh 中，然后通过该脚本启动 Container。之所以要将 Container 运行命令写到脚本中并通过运行脚本来执行它，主要是直接执行命令可能让一些特殊符号发生转义。</p>
<p>上面主要介绍 startContainerInternal() 的第一个事件处理，接下来看第一个事件的处理，以及如何启动和运行 Container。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startContainerInternal</span><span class="params">(NMTokenIdentifier nmTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      ContainerTokenIdentifier containerTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      StartContainerRequest request)</span> <span class="keyword">throws</span> YarnException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略Token认证及ContainerLaunchContext上下文初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!serviceStopped) &#123;</span><br><span class="line">        <span class="comment">// Create the application</span></span><br><span class="line">        Application application =</span><br><span class="line">            <span class="keyword">new</span> ApplicationImpl(dispatcher, user, applicationID, credentials, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 应用程序的初始化，供后续Container使用，这个逻辑只调用一次，通常由来自ApplicationMaster的第一个Container完成</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == context.getApplications().putIfAbsent(applicationID,</span><br><span class="line">          application)) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;Creating a new application reference for app &quot;</span> + applicationID);</span><br><span class="line">          LogAggregationContext logAggregationContext =</span><br><span class="line">              containerTokenIdentifier.getLogAggregationContext();</span><br><span class="line">          Map&lt;ApplicationAccessType, String&gt; appAcls =</span><br><span class="line">              container.getLaunchContext().getApplicationACLs();</span><br><span class="line">          context.getNMStateStore().storeApplication(applicationID,</span><br><span class="line">              buildAppProto(applicationID, user, credentials, appAcls,</span><br><span class="line">                logAggregationContext));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.向 ApplicationImpl 发送 ApplicationEventType.INIT_APPLICATION 事件</span></span><br><span class="line">          dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ApplicationInitEvent(applicationID, appAcls,</span><br><span class="line">              logAggregationContext));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.向 ApplicationImpl 发送 ApplicationEventType.INIT_CONTAINER 事件</span></span><br><span class="line">        <span class="keyword">this</span>.context.getNMStateStore().storeContainer(containerId, request);</span><br><span class="line">        dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> ApplicationContainerInitEvent(container));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.context.getContainerTokenSecretManager().startContainerSuccessful(</span><br><span class="line">          containerTokenIdentifier);</span><br><span class="line">        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,</span><br><span class="line">          <span class="string">&quot;ContainerManageImpl&quot;</span>, applicationID, containerId);</span><br><span class="line">        <span class="comment">// TODO launchedContainer misplaced -&gt; doesn&#x27;t necessarily mean a container</span></span><br><span class="line">        <span class="comment">// launch. A finished Application will not launch containers.</span></span><br><span class="line">        metrics.launchedContainer();</span><br><span class="line">        metrics.allocateContainer(containerTokenIdentifier.getResource());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> YarnException(</span><br><span class="line">            <span class="string">&quot;Container start failed as the NodeManager is &quot;</span> +</span><br><span class="line">            <span class="string">&quot;in the process of shutting down&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里触发了 Application 的事件 ApplicationEventType.INIT_CONTAINER，下面是该事件的状态转换过程及对应注册的状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">    <span class="comment">// Transitions from NEW state</span></span><br><span class="line">    .addTransition(ApplicationState.NEW, ApplicationState.NEW,</span><br><span class="line">        ApplicationEventType.INIT_CONTAINER,</span><br><span class="line">        <span class="keyword">new</span> InitContainerTransition())</span><br></pre></td></tr></table></figure>

<p>InitContainerTransition 状态机的处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InitContainerTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">SingleArcTransition</span>&lt;<span class="title">ApplicationImpl</span>, <span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ApplicationImpl app, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">      ApplicationContainerInitEvent initEvent =</span><br><span class="line">        (ApplicationContainerInitEvent) event;</span><br><span class="line">      Container container = initEvent.getContainer();</span><br><span class="line">      app.containers.put(container.getContainerId(), container);</span><br><span class="line">      LOG.info(<span class="string">&quot;Adding &quot;</span> + container.getContainerId()</span><br><span class="line">          + <span class="string">&quot; to application &quot;</span> + app.toString());</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">switch</span> (app.getApplicationState()) &#123;</span><br><span class="line">      <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="comment">// 应用程序提交后app是RUNNING状态，这里向调度器发送 ContainerEventType.INIT_CONTAINER 事件</span></span><br><span class="line">        app.dispatcher.getEventHandler().handle(<span class="keyword">new</span> ContainerInitEvent(</span><br><span class="line">            container.getContainerId()));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> INITING:</span><br><span class="line">      <span class="keyword">case</span> NEW:</span><br><span class="line">        <span class="comment">// these get queued up and sent out in AppInitDoneTransition</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span> : <span class="string">&quot;Invalid state for InitContainerTransition: &quot;</span> +</span><br><span class="line">            app.getApplicationState();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerEventType.INIT_CONTAINER 事件对应的状态转换及注册的状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">    <span class="comment">// From NEW State</span></span><br><span class="line">    .addTransition(ContainerState.NEW,</span><br><span class="line">        EnumSet.of(ContainerState.LOCALIZING,</span><br><span class="line">            ContainerState.LOCALIZED,</span><br><span class="line">            ContainerState.LOCALIZATION_FAILED,</span><br><span class="line">            ContainerState.DONE),</span><br><span class="line">        ContainerEventType.INIT_CONTAINER, <span class="keyword">new</span> RequestResourcesTransition())</span><br></pre></td></tr></table></figure>

<p>RequestResourcesTransition 状态机行为的关键在于 sendLaunchEvent() 方法的调用，发送 Container 启动的事情请求，向调度器发送 ContainersLauncherEventType.LAUNCH_CONTAINER 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResourcesTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">MultipleArcTransition</span>&lt;<span class="title">ContainerImpl</span>,<span class="title">ContainerEvent</span>,<span class="title">ContainerState</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContainerState <span class="title">transition</span><span class="params">(ContainerImpl container,</span></span></span><br><span class="line"><span class="params"><span class="function">        ContainerEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略一些检查逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点：发送启动Container的操作</span></span><br><span class="line">        container.sendLaunchEvent();</span><br><span class="line">        container.metrics.endInitingContainer();</span><br><span class="line">        <span class="keyword">return</span> ContainerState.LOCALIZED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendLaunchEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ContainersLauncherEventType launcherEvent =</span><br><span class="line">        ContainersLauncherEventType.LAUNCH_CONTAINER;</span><br><span class="line">    <span class="keyword">if</span> (recoveredStatus == RecoveredContainerStatus.LAUNCHED) &#123;</span><br><span class="line">      <span class="comment">// try to recover a container that was previously launched</span></span><br><span class="line">      launcherEvent = ContainersLauncherEventType.RECOVER_CONTAINER;</span><br><span class="line">    &#125;</span><br><span class="line">    containerLaunchStartTime = clock.getTime();</span><br><span class="line">    <span class="comment">// 向调度器发送 ContainersLauncherEventType.LAUNCH_CONTAINER 事件请求</span></span><br><span class="line">    dispatcher.getEventHandler().handle(</span><br><span class="line">        <span class="keyword">new</span> ContainersLauncherEvent(<span class="keyword">this</span>, launcherEvent));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里向调度器发送 ContainersLauncherEventType.LAUNCH_CONTAINER 事件请求，之前发送事件状态转换过程不太一样，在代码中我们找到该事件的状态转换过程及注册状态机，那是由谁来处理这个事件请求呢？我们就需要看看 ContainersLauncherEventType 事件类注册的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ContainerManagerImpl</span><span class="params">(Context context, ContainerExecutor exec,</span></span></span><br><span class="line"><span class="params"><span class="function">      DeletionService deletionContext, NodeStatusUpdater nodeStatusUpdater,</span></span></span><br><span class="line"><span class="params"><span class="function">      NodeManagerMetrics metrics, ApplicationACLsManager aclsManager,</span></span></span><br><span class="line"><span class="params"><span class="function">      LocalDirsHandlerService dirsHandler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dispatcher.register(ContainerEventType.class,</span><br><span class="line">        <span class="keyword">new</span> ContainerEventDispatcher());</span><br><span class="line">    dispatcher.register(ApplicationEventType.class,</span><br><span class="line">        <span class="keyword">new</span> ApplicationEventDispatcher());</span><br><span class="line">    dispatcher.register(LocalizationEventType.class, rsrcLocalizationSrvc);</span><br><span class="line">    dispatcher.register(AuxServicesEventType.class, auxiliaryServices);</span><br><span class="line">    dispatcher.register(ContainersMonitorEventType.class, containersMonitor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContainersLauncherEventType 事件类的注册方法</span></span><br><span class="line">    dispatcher.register(ContainersLauncherEventType.class, containersLauncher);</span><br><span class="line">    </span><br><span class="line">    addService(dispatcher);</span><br><span class="line"></span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">this</span>.readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">this</span>.writeLock = lock.writeLock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 ContainersLauncherEventType 事件类型类注册的事件处理器为 ContainersLauncher 类，那该类又是如何处理 ContainersLauncherEventType.LAUNCH_CONTAINER 事件请求呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：rg/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ContainersLauncherEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> ContainersLauncher launches containers one by one!!</span></span><br><span class="line">    Container container = event.getContainer();</span><br><span class="line">    ContainerId containerId = container.getContainerId();</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> LAUNCH_CONTAINER:</span><br><span class="line">        Application app =</span><br><span class="line">          context.getApplications().get(</span><br><span class="line">              containerId.getApplicationAttemptId().getApplicationId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAUNCH_CONTAINER 事件的处理逻辑，创建 ContainerLaunch 线程并启动线程</span></span><br><span class="line">        ContainerLaunch launch =</span><br><span class="line">            <span class="keyword">new</span> ContainerLaunch(context, getConfig(), dispatcher, exec, app,</span><br><span class="line">              event.getContainer(), dirsHandler, containerManager);</span><br><span class="line">        containerLauncher.submit(launch);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将其加入到运行的 Container 数据结构 running 中</span></span><br><span class="line">        running.put(containerId, launch);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RECOVER_CONTAINER: <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> CLEANUP_CONTAINER: <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的 ContainerLaunch 类是真正启动 Container 的类，ContainerLaunch 类继承自 Callable 类，线程启动的方式是通过 submit() 方法提交，调用 Callable 类的实现方法 call() 来真正执行线程。启动过程主要做了三件事：</p>
<ul>
<li>准备 Container 的执行环境；</li>
<li>更新 Container 状态，从 LOCALIZED 转换为 RUNNING；</li>
<li>调用 ContainerExecutor 对象在 NM 节点上启动 Container</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ContainerLaunchContext launchContext = container.getLaunchContext();</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 启动 Container 前的准备工作：（省略）</span></span><br><span class="line"><span class="comment">      * 1.shell启动脚本的封装与拓展（添加自定义脚本）</span></span><br><span class="line"><span class="comment">      * 2.创建本地工作目录</span></span><br><span class="line"><span class="comment">      * 3.设置token的保存路径</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 由于 call() 方法调用是阻塞的，这里先发送 ContainerEventType.CONTAINER_LAUNCHED 事件，将 Container 状态从LOCALIZED 转换为 RUNNING</span></span><br><span class="line">          dispatcher.getEventHandler().handle(<span class="keyword">new</span> ContainerEvent(</span><br><span class="line">                containerID,</span><br><span class="line">                ContainerEventType.CONTAINER_LAUNCHED));</span><br><span class="line">          context.getNMStateStore().storeContainerLaunched(containerID);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Check if the container is signalled to be killed.</span></span><br><span class="line">          <span class="keyword">if</span> (!shouldLaunchContainer.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;Container &quot;</span> + containerIdStr + <span class="string">&quot; not launched as &quot;</span></span><br><span class="line">                + <span class="string">&quot;cleanup already called&quot;</span>);</span><br><span class="line">            ret = ExitCode.TERMINATED.getExitCode();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 重点：调用 ContainerExecutor 对象启动 Contianer</span></span><br><span class="line">            exec.activateContainer(containerID, pidFilePath);</span><br><span class="line">            ret = exec.launchContainer(container, nmPrivateContainerScriptPath,</span><br><span class="line">                    nmPrivateTokensPath, user, appIdStr, containerWorkDir,</span><br><span class="line">                    localDirs, logDirs);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Container 执行结果返回，判断是否成功执行（省略）</span></span><br><span class="line">    </span><br><span class="line">    LOG.info(<span class="string">&quot;Container &quot;</span> + containerIdStr + <span class="string">&quot; succeeded &quot;</span>);</span><br><span class="line">    dispatcher.getEventHandler().handle(</span><br><span class="line">        <span class="keyword">new</span> ContainerEvent(containerID,</span><br><span class="line">            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> Container 的运行环境已经准备好，接下来就是真正在 NM 上真正启动 Container 的过程，具体启动是调用 ContainerExecutor#launchContainer() 方法。运行 Container 是由插拔式组件 ContainerExecutor 完成，YARN 中提供了三种 ContainerExecutor 实现，一种是 DefaultContainerExecutor，一种是 LinuxContainerExecutor，另一种是 DockerContainerExecutor，由参数 yarn.nodemanager.container-executor.class 控制其具体使用方式。</p>
<h2 id="2-4-Container资源清理"><a href="#2-4-Container资源清理" class="headerlink" title="2.4 Container资源清理"></a>2.4 Container资源清理</h2><p>Container 资源清理是指 Container 运行完成后（可能成功或者失败），NM 需回收它占用的资源，这些资源主要是 Container 运行时使用的临时文件，主要来源是 ResourceLocalizationService 和 ContianerExecutor 两个服务/组件，其中 ResourceLocalizationService 将数据 HDFS 文件下载到本地，ContainerExecutor 为 Container 创建私有工作目录，并保存一些临时文件（比如 Container 进程 pid 文件）。因此，Container 资源清理过程主要是通知这两个组件删除临时目录。</p>
<p>从 ContainerLaunch#call() 方法结束处，当 Container 成功运行完成后，会向调度器发送 ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS 事件。该事件的注册状态转换如下，将 Container 状态 从 RUNNING 转换为 EXITED_WITH_SUCCESS，并触发状态机 ExitedWithSuccessTransition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">    <span class="comment">// From RUNNING State</span></span><br><span class="line">    .addTransition(ContainerState.RUNNING,</span><br><span class="line">        ContainerState.EXITED_WITH_SUCCESS,</span><br><span class="line">        ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS,</span><br><span class="line">        <span class="keyword">new</span> ExitedWithSuccessTransition(<span class="keyword">true</span>))</span><br></pre></td></tr></table></figure>

<p>ExitedWithSuccessTransition 状态过程会发送 ContainersLauncherEventType.CLEANUP_CONTAINER 事件，该事件发送了两个事件：</p>
<ul>
<li>向 ContainerLauncher 发送 ContainersLauncherEventType.CLEANUP_CONTAINER 清理事件；</li>
<li>向 ResourceLocalizationService 发送 LocalizationEventType.CLEANUP_CONTAINER_RESOURCES 清理事件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitedWithSuccessTransition</span> <span class="keyword">extends</span> <span class="title">ContainerTransition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> clCleanupRequired;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExitedWithSuccessTransition</span><span class="params">(<span class="keyword">boolean</span> clCleanupRequired)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.clCleanupRequired = clCleanupRequired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ContainerImpl container, ContainerEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Set exit code to 0 on success        </span></span><br><span class="line">      container.exitCode = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Add containerWorkDir to the deletion service.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (clCleanupRequired) &#123;</span><br><span class="line">          <span class="comment">// 向 ContainerLauncher 发送 ContainersLauncherEventType.CLEANUP_CONTAINER 清理事件</span></span><br><span class="line">        container.dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ContainersLauncherEvent(container,</span><br><span class="line">                ContainersLauncherEventType.CLEANUP_CONTAINER));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向 ResourceLocalizationService 发送 LocalizationEventType.CLEANUP_CONTAINER_RESOURCES 清理事件</span></span><br><span class="line">      container.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看 ContainerLauncher 清理临时目录的过程。ContainersLauncherEventType.CLEANUP_CONTAINER 事件的处理逻辑最终会进入到 ContainersLauncher 的 handle() 方法，将 Container 从正在运行的 Container 列表中移除，并调用 ContainerLaunch#cleanupContainer() 方法清除 Container 占用的临时目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ContainersLauncherEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> ContainersLauncher launches containers one by one!!</span></span><br><span class="line">    Container container = event.getContainer();</span><br><span class="line">    ContainerId containerId = container.getContainerId();</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> LAUNCH_CONTAINER:  <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> RECOVER_CONTAINER: <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> CLEANUP_CONTAINER:</span><br><span class="line">        <span class="comment">// 将 Container 从正在运行 Container 列表中移除</span></span><br><span class="line">        ContainerLaunch launcher = running.remove(containerId);</span><br><span class="line">        <span class="keyword">if</span> (launcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Container not launched. So nothing needs to be done.</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cleanup a container whether it is running/killed/completed, so that</span></span><br><span class="line">        <span class="comment">// no sub-processes are alive.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 清理 Container 占用的临时目录</span></span><br><span class="line">          launcher.cleanupContainer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Got exception while cleaning container &quot;</span> + containerId</span><br><span class="line">              + <span class="string">&quot;. Ignoring.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>再来看看 ResourceLocalizationService 清除 Container 用户工作目录和 NM 私有目录下的 Container 目录。根据发送的发送 LocalizationEventType.CLEANUP_CONTAINER_RESOURCES 清理事件，可以进入到对应的清理逻辑 handleCleanupContainerResources()，执行具体的清理逻辑。该逻辑将会删除用户工作 <code>$&#123;yarn.nodemanager.local-dirs&#125;/usercache/&lt;user&gt;/appcache/$&#123;appid&#125;/$&#123;containerid&#125;</code> 的数据（即从 HDFS 下载的数据）和 <code>$&#123;yarn.nodemanager.local-dirs&#125;/nmPrivate/$&#123;appid&#125;/$&#123;containerid&#125;</code> 私有目录数据，这两个目标都存放了 Tokens 文件和 Shell 运行脚本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INIT_APPLICATION_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> INIT_CONTAINER_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESOURCES_LOCALIZED:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CACHE_CLEANUP:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CLEANUP_CONTAINER_RESOURCES:</span><br><span class="line">      handleCleanupContainerResources((ContainerLocalizationCleanupEvent)event);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DESTROY_APPLICATION_RESOURCES: <span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;Unknown localization event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，Container 资源清理流程已完成。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li> 董西成. 《Hadoop技术内幕 · 深入解析 YARN 架构设计与实现原理》</li>
<li><a href="https://blog.csdn.net/gaopenghigh/article/details/45507765">YARN Container 启动流程分析</a></li>
</ul>
]]></content>
      <categories>
        <category>YARN</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>YARN</tag>
      </tags>
  </entry>
  <entry>
    <title>YARN ApplicationMaster启动原理与源码分析</title>
    <url>/2021/11/07/YARN-ApplicationMaster%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文主要介绍 ApplicationMaster(简称 AM) 的运行流程，并从 AM 的启动、注册/心跳、Container 资源申请与分配三个角度分析相关源码。其中花了大量篇幅介绍 AM 的启动过程，包括任务提交流程、App/Attempt 转换过程，到 AM 的启动，这部分主要是方便读者了解从应用程序提交到启动 AM 再到 AM 申请 Container 运行整个过程，对 YARN 的提交流程有更深入的理解。</p>
<h1 id="1-AM整体架构"><a href="#1-AM整体架构" class="headerlink" title="1. AM整体架构"></a>1. AM整体架构</h1><p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/07/2b3f627b3d8e6055d6964830a07d05df-1372882-20200826172820723-885116646-20211107233952482-e969ea.png" alt="img"></p>
<center>ApplicationMaster 生命周期</center>

<p>ApplicationMaster（AM）管理主要由三个服务构成，分别是 ApplicationMasterLauncher、AMLivelinessMonitor 和 ApplicationMasterService，它们共同管理应用程序的 AM 的生命周期。AM 服务从创建到销毁的流程如下：</p>
<ol>
<li>用户向 ResourceManager 提交应用程序，ResourceManager 收到提交请求后，先向资源调度器申请用以启动 ApplicationMaster 的资源，待申请到资源后，再由 ApplicationMasterLauncher 与对应的 NodeManager 通信，从而启动应用程序的 ApplicationMaster。</li>
<li>ApplicationMaster 启动完成后，ApplicationMasterLauncher 会通过事件的形式，将刚刚启动的 ApplicationMaster 注册到 AMLivelinessMonitor，以启动心跳监控。</li>
<li>ApplicationMaster 启动后，先向 ApplicationMasterService 注册，将自己所在 host、端口号等信息汇报给它。</li>
<li>ApplicationMaster 运行过程中，周期性地向 ApplicationMasterService 汇报“心跳”信息（“心跳”信息中包含想要申请的资源描述）。</li>
<li>ApplicationMasterService 每次收到 ApplicationMaster 的心跳信息后，将通知 AMLivelinessMonitor 更新该应用程序的最近汇报心跳的时间。</li>
<li>当应用程序运行完成后，ApplicationMaster 向 ApplicationMasterService 发送请求，注销自己。</li>
<li>ApplicationMasterService 收到注销请求后，标注应用程序运行状态为完成，同时通知 AMLivelinessMonitor 移除对它的心跳监控。</li>
</ol>
<p>结合 ApplicationMaster 的整体生命周期，我们从 ApplicatioMaster 启动、注册/心跳及资源申请三个角度来剖析相关源码。</p>
<h1 id="2-AM-Container启动"><a href="#2-AM-Container启动" class="headerlink" title="2. AM Container启动"></a>2. AM Container启动</h1><p>这部分主要介绍 AM 生命周期的第一步，即 AM 的启动（AM 的启动本质也是 YARN 的一个 Container 容器）。为了方便理解整个任务执行流程，我们不直接分析 AM 的启动类，而是从应用程序提交，到 APP/Attempt 状态转换（AM 启动前应用程序的一些状态转换过程），再到具体的 AM 启动，以对 YARN 的整个任务提交流程有更深的了解。</p>
<h2 id="2-1-APP提交"><a href="#2-1-APP提交" class="headerlink" title="2.1 APP提交"></a>2.1 APP提交</h2><p>不管是什么类型的应用程序，提交到 YARN 上的入口，都是通过 YARNClient 这个接口 api 提交的，具体提交方法为 submitApplication()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/YARNClient.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ApplicationId <span class="title">submitApplication</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationSubmissionContext appContext)</span> <span class="keyword">throws</span> YARNException,</span></span><br><span class="line"><span class="function">      IOException</span>;</span><br></pre></td></tr></table></figure>

<p>看看其实现类的提交入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/impl/YARNClientImpl.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ApplicationId</span></span><br><span class="line"><span class="function">      <span class="title">submitApplication</span><span class="params">(ApplicationSubmissionContext appContext)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line">    ApplicationId applicationId = appContext.getApplicationId();</span><br><span class="line">    <span class="keyword">if</span> (applicationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationIdNotProvidedException(</span><br><span class="line">          <span class="string">&quot;ApplicationId is not provided in ApplicationSubmissionContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建应用程序请求的上文文信息</span></span><br><span class="line">    SubmitApplicationRequest request =</span><br><span class="line">        Records.newRecord(SubmitApplicationRequest.class);</span><br><span class="line">    request.setApplicationSubmissionContext(appContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Automatically add the timeline DT into the CLC</span></span><br><span class="line">    <span class="comment">// Only when the security and the timeline service are both enabled</span></span><br><span class="line">    <span class="keyword">if</span> (isSecurityEnabled() &amp;&amp; timelineServiceEnabled) &#123;</span><br><span class="line">      addTimelineDelegationToken(appContext.getAMContainerSpec());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Client 真正提交应用程序</span></span><br><span class="line">    rmClient.submitApplication(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">      <span class="comment">// 对未能及时提交的应用程序不断重试</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applicationId;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>YARN Client 与 RM 进行 RPC 通信是通过 ClientRMService 服务实现的，应用程序提交到服务端，会调用 RMAppManager 类的对应方法来处理应用程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SubmitApplicationResponse <span class="title">submitApplication</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      SubmitApplicationRequest request)</span> <span class="keyword">throws</span> YARNException </span>&#123;</span><br><span class="line">    ApplicationSubmissionContext submissionContext = request</span><br><span class="line">        .getApplicationSubmissionContext();</span><br><span class="line">    ApplicationId applicationId = submissionContext.getApplicationId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过神圣的检查工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 重点：调用 RMAppManager 来提交应用程序</span></span><br><span class="line">      rmAppManager.submitApplication(submissionContext,</span><br><span class="line">          System.currentTimeMillis(), user);</span><br><span class="line"></span><br><span class="line">      LOG.info(<span class="string">&quot;Application with id &quot;</span> + applicationId.getId() + </span><br><span class="line">          <span class="string">&quot; submitted by user &quot;</span> + user);</span><br><span class="line">      RMAuditLogger.logSuccess(user, AuditConstants.SUBMIT_APP_REQUEST,</span><br><span class="line">          <span class="string">&quot;ClientRMService&quot;</span>, applicationId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (YARNException e) &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Exception in submitting application with id &quot;</span> +</span><br><span class="line">          applicationId.getId(), e);</span><br><span class="line">      RMAuditLogger.logFailure(user, AuditConstants.SUBMIT_APP_REQUEST,</span><br><span class="line">          e.getMessage(), <span class="string">&quot;ClientRMService&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Exception in submitting application&quot;</span>, applicationId);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubmitApplicationResponse response = recordFactory</span><br><span class="line">        .newRecordInstance(SubmitApplicationResponse.class);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-APP-AppAttempt状态转换"><a href="#2-2-APP-AppAttempt状态转换" class="headerlink" title="2.2 APP/AppAttempt状态转换"></a>2.2 APP/AppAttempt状态转换</h2><p>从 RMAppManager 类的 rmAppManager.submitApplication() 方法，可以看到它向调度器发送 RMAppEventType.START 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">submitApplication</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationSubmissionContext submissionContext, <span class="keyword">long</span> submitTime,</span></span></span><br><span class="line"><span class="params"><span class="function">      String user)</span> <span class="keyword">throws</span> YARNException </span>&#123;</span><br><span class="line">    ApplicationId applicationId = submissionContext.getApplicationId();</span><br><span class="line"></span><br><span class="line">    RMAppImpl application =</span><br><span class="line">        createAndPopulateNewRMApp(submissionContext, submitTime, user, <span class="keyword">false</span>);</span><br><span class="line">    ApplicationId appId = submissionContext.getApplicationId();</span><br><span class="line">    Credentials credentials = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      credentials = parseCredentials(submissionContext);</span><br><span class="line">      <span class="keyword">if</span> (UserGroupInformation.isSecurityEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,</span><br><span class="line">            credentials, submissionContext.getCancelTokensWhenComplete(),</span><br><span class="line">            application.getUser());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 重点：向调度器发送 RMAppEventType.START 事件</span></span><br><span class="line">        <span class="keyword">this</span>.rmContext.getDispatcher().getEventHandler()</span><br><span class="line">            .handle(<span class="keyword">new</span> RMAppEvent(applicationId, RMAppEventType.START));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">&quot;Unable to parse credentials.&quot;</span>, e);</span><br><span class="line">      <span class="comment">// Sending APP_REJECTED is fine, since we assume that the</span></span><br><span class="line">      <span class="comment">// RMApp is in NEW state and thus we haven&#x27;t yet informed the</span></span><br><span class="line">      <span class="comment">// scheduler about the existence of the application</span></span><br><span class="line">      <span class="keyword">assert</span> application.getState() == RMAppState.NEW;</span><br><span class="line">      <span class="keyword">this</span>.rmContext.getDispatcher().getEventHandler()</span><br><span class="line">          .handle(<span class="keyword">new</span> RMAppRejectedEvent(applicationId, e.getMessage()));</span><br><span class="line">      <span class="keyword">throw</span> RPCUtil.getRemoteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RMAppEventType.START 事件在 RMAppImpl 类中有对应的状态转换，即 APP 状态从 NEW 转换为 NEW_SAVING。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java</span></span><br><span class="line">    <span class="comment">// Transitions from NEW state</span></span><br><span class="line">    .addTransition(RMAppState.NEW, RMAppState.NEW_SAVING,</span><br><span class="line">        RMAppEventType.START, <span class="keyword">new</span> RMAppNewlySavingTransition())</span><br></pre></td></tr></table></figure>

<p>注册的 RMAppNewlySavingTransition 状态机做了什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RMAppNewlySavingTransition</span> <span class="keyword">extends</span> <span class="title">RMAppTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(RMAppImpl app, RMAppEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存 APP 的状态信息</span></span><br><span class="line">      LOG.info(<span class="string">&quot;Storing application with id &quot;</span> + app.applicationId);</span><br><span class="line">      app.rmContext.getStateStore().storeNewApplication(app);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>状态机会对 APP 的状态进行保存，将其元数据存储到 ZK 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/RMStateStore.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">storeNewApplication</span><span class="params">(RMApp app)</span> </span>&#123;</span><br><span class="line">    ApplicationSubmissionContext context = app</span><br><span class="line">                                            .getApplicationSubmissionContext();</span><br><span class="line">    <span class="keyword">assert</span> context <span class="keyword">instanceof</span> ApplicationSubmissionContextPBImpl;</span><br><span class="line">    ApplicationStateData appState =</span><br><span class="line">        ApplicationStateData.newInstance(</span><br><span class="line">            app.getSubmitTime(), app.getStartTime(), context, app.getUser());</span><br><span class="line">    <span class="comment">// 向调度器发送 RMStateStoreEventType.STORE_APP 事件</span></span><br><span class="line">    dispatcher.getEventHandler().handle(<span class="keyword">new</span> RMStateStoreAppEvent(appState));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里向调度器发送 RMStateStoreEventType.STORE_APP 事件，并注册了 StoreAppTransition 状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/RMStateStore.java</span></span><br><span class="line">    .addTransition(RMStateStoreState.ACTIVE,</span><br><span class="line">          EnumSet.of(RMStateStoreState.ACTIVE, RMStateStoreState.FENCED),</span><br><span class="line">          RMStateStoreEventType.STORE_APP, <span class="keyword">new</span> StoreAppTransition())</span><br></pre></td></tr></table></figure>

<p>StoreAppTransition 状态机会向调度器发送 RMAppEventType.APP_NEW_SAVED 事件，触发 APP 状态从 NEW_SAVING 到 SUBMITED 的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/recovery/RMStateStore.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreAppTransition</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">MultipleArcTransition</span>&lt;<span class="title">RMStateStore</span>, <span class="title">RMStateStoreEvent</span>,</span></span><br><span class="line"><span class="class">          <span class="title">RMStateStoreState</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RMStateStoreState <span class="title">transition</span><span class="params">(RMStateStore store,</span></span></span><br><span class="line"><span class="params"><span class="function">        RMStateStoreEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> RMStateStoreAppEvent)) &#123;</span><br><span class="line">        <span class="comment">// should never happen</span></span><br><span class="line">        LOG.error(<span class="string">&quot;Illegal event type: &quot;</span> + event.getClass());</span><br><span class="line">        <span class="keyword">return</span> RMStateStoreState.ACTIVE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> isFenced = <span class="keyword">false</span>;</span><br><span class="line">      ApplicationStateData appState =</span><br><span class="line">          ((RMStateStoreAppEvent) event).getAppState();</span><br><span class="line">      ApplicationId appId =</span><br><span class="line">          appState.getApplicationSubmissionContext().getApplicationId();</span><br><span class="line">      LOG.info(<span class="string">&quot;Storing info for app: &quot;</span> + appId);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        store.storeApplicationStateInternal(appId, appState);</span><br><span class="line">        <span class="comment">// 重点：向调度器发送 RMAppEventType.APP_NEW_SAVED 事件</span></span><br><span class="line">        store.notifyApplication(<span class="keyword">new</span> RMAppEvent(appId,</span><br><span class="line">               RMAppEventType.APP_NEW_SAVED));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Error storing app: &quot;</span> + appId, e);</span><br><span class="line">        isFenced = store.notifyStoreOperationFailedInternal(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> finalState(isFenced);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里会向调度器发送 RMAppEventType.APP_NEW_SAVED 事件，该事件会触发 APP 状态从 NEW_SAVING 到 SUBMITED 的转换，并调用 AddApplicationToSchedulerTransition 状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java</span></span><br><span class="line">    .addTransition(RMAppState.NEW_SAVING, RMAppState.SUBMITTED,</span><br><span class="line">        RMAppEventType.APP_NEW_SAVED, <span class="keyword">new</span> AddApplicationToSchedulerTransition())</span><br></pre></td></tr></table></figure>

<p>AddApplicationToSchedulerTransition 状态机会触发 SchedulerEventType.APP_ADDED 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/event/AppAddedSchedulerEvent.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AddApplicationToSchedulerTransition</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">      <span class="title">RMAppTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(RMAppImpl app, RMAppEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 向调度器发送 SchedulerEventType.APP_ADDED 事件</span></span><br><span class="line">      app.handler.handle(<span class="keyword">new</span> AppAddedSchedulerEvent(app.applicationId,</span><br><span class="line">        app.submissionContext.getQueue(), app.user,</span><br><span class="line">        app.submissionContext.getReservationID()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中AppAddedSchedulerEvent 类继承自 SchedulerEvent 类，事件的处理会进入到 FairScheduler 类，来看看对应的 handle() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SchedulerEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> NODE_ADDED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_UPDATE: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_ADDED:</span><br><span class="line">      <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> AppAddedSchedulerEvent)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unexpected event type: &quot;</span> + event);</span><br><span class="line">      &#125;</span><br><span class="line">      AppAddedSchedulerEvent appAddedEvent = (AppAddedSchedulerEvent) event;</span><br><span class="line">      <span class="comment">// APP_ADDED 事件处理逻辑</span></span><br><span class="line">      addApplication(appAddedEvent.getApplicationId(),</span><br><span class="line">        appAddedEvent.getQueue(), appAddedEvent.getUser(),</span><br><span class="line">        appAddedEvent.getIsAppRecovering());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> APP_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_RESOURCE_UPDATE: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_ADDED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_EXPIRED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESCHEDULED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOG.error(<span class="string">&quot;Unknown event arrived at FairScheduler: &quot;</span> + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>addApplication() 方法会对应用程序的提交进行一些前期检查工作，比如队列名是否正确、用户是否有队列访问权限等，检查通过后，会向调度器发送 RMAppEventType.APP_ACCEPTED 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addApplication</span><span class="params">(ApplicationId applicationId,</span></span></span><br><span class="line"><span class="params"><span class="function">      String queueName, String user, <span class="keyword">boolean</span> isAppRecovering)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提交队列信息判断</span></span><br><span class="line">    <span class="keyword">if</span> (queueName == <span class="keyword">null</span> || queueName.isEmpty()) &#123;</span><br><span class="line">      String message = <span class="string">&quot;Reject application &quot;</span> + applicationId +</span><br><span class="line">              <span class="string">&quot; submitted by user &quot;</span> + user + <span class="string">&quot; with an empty queue name.&quot;</span>;</span><br><span class="line">      LOG.info(message);</span><br><span class="line">      rmContext.getDispatcher().getEventHandler()</span><br><span class="line">          .handle(<span class="keyword">new</span> RMAppRejectedEvent(applicationId, message));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queueName.startsWith(<span class="string">&quot;.&quot;</span>) || queueName.endsWith(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">      String message = <span class="string">&quot;Reject application &quot;</span> + applicationId</span><br><span class="line">          + <span class="string">&quot; submitted by user &quot;</span> + user + <span class="string">&quot; with an illegal queue name &quot;</span></span><br><span class="line">          + queueName + <span class="string">&quot;. &quot;</span></span><br><span class="line">          + <span class="string">&quot;The queue name cannot start/end with period.&quot;</span>;</span><br><span class="line">      LOG.info(message);</span><br><span class="line">      rmContext.getDispatcher().getEventHandler()</span><br><span class="line">          .handle(<span class="keyword">new</span> RMAppRejectedEvent(applicationId, message));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RMApp rmApp = rmContext.getRMApps().get(applicationId);</span><br><span class="line">    FSLeafQueue queue = assignToQueue(rmApp, queueName, user);</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的 ACL 访问权限判断</span></span><br><span class="line">    UserGroupInformation userUgi = UserGroupInformation.createRemoteUser(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)</span><br><span class="line">        &amp;&amp; !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) &#123;</span><br><span class="line">      String msg = <span class="string">&quot;User &quot;</span> + userUgi.getUserName() +</span><br><span class="line">              <span class="string">&quot; cannot submit applications to queue &quot;</span> + queue.getName();</span><br><span class="line">      LOG.info(msg);</span><br><span class="line">      rmContext.getDispatcher().getEventHandler()</span><br><span class="line">          .handle(<span class="keyword">new</span> RMAppRejectedEvent(applicationId, msg));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SchedulerApplication&lt;FSAppAttempt&gt; application =</span><br><span class="line">        <span class="keyword">new</span> SchedulerApplication&lt;FSAppAttempt&gt;(queue, user);</span><br><span class="line">    applications.put(applicationId, application);</span><br><span class="line">    queue.getMetrics().submitApp(user);</span><br><span class="line"></span><br><span class="line">    LOG.info(<span class="string">&quot;Accepted application &quot;</span> + applicationId + <span class="string">&quot; from user: &quot;</span> + user</span><br><span class="line">        + <span class="string">&quot;, in queue: &quot;</span> + queue.getName()</span><br><span class="line">        + <span class="string">&quot;, currently num of applications: &quot;</span> + applications.size());</span><br><span class="line">    <span class="keyword">if</span> (isAppRecovering) &#123;</span><br><span class="line">      <span class="comment">// 判断 APP 是否事 Recover 状态（暂时不考虑 Recover 情况）</span></span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(applicationId</span><br><span class="line">            + <span class="string">&quot; is recovering. Skip notifying APP_ACCEPTED&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 重点：向调度器发送 RMAppEventType.APP_ACCEPTED 事件</span></span><br><span class="line">      rmContext.getDispatcher().getEventHandler()</span><br><span class="line">        .handle(<span class="keyword">new</span> RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RMAppEventType.APP_ACCEPTED 事件的注册，会触发 StartAppAttemptTransition 状态机，并将 APP 的状态从 SUBMITED 转换为 ACCEPTED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java</span></span><br><span class="line">    <span class="comment">// Transitions from SUBMITTED state</span></span><br><span class="line">    .addTransition(RMAppState.SUBMITTED, RMAppState.ACCEPTED,</span><br><span class="line">        RMAppEventType.APP_ACCEPTED, <span class="keyword">new</span> StartAppAttemptTransition())</span><br></pre></td></tr></table></figure>

<p>StartAppAttemptTransition 状态机会发送 RMAppAttemptEventType.START 事件，以开始启动 AppAttempt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAppAttemptTransition</span> <span class="keyword">extends</span> <span class="title">RMAppTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(RMAppImpl app, RMAppEvent event)</span> </span>&#123;</span><br><span class="line">      app.createAndStartNewAttempt(<span class="keyword">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始启动 AppAttempt</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndStartNewAttempt</span><span class="params">(<span class="keyword">boolean</span> transferStateFromPreviousAttempt)</span> </span>&#123;</span><br><span class="line">    createNewAttempt();</span><br><span class="line">    <span class="comment">// 向调度器发送 RMAppAttemptEventType.START 事件</span></span><br><span class="line">    handler.handle(<span class="keyword">new</span> RMAppStartAttemptEvent(currentAttempt.getAppAttemptId(),</span><br><span class="line">      transferStateFromPreviousAttempt));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RMAppAttemptEventType.START 事件的注册，会调用 AttemptStartedTransition 状态机，触发 AppAttempt 状态从 NEW 转变为 SUBMITED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line">      <span class="comment">// Transitions from NEW State</span></span><br><span class="line">      .addTransition(RMAppAttemptState.NEW, RMAppAttemptState.SUBMITTED,</span><br><span class="line">          RMAppAttemptEventType.START, <span class="keyword">new</span> AttemptStartedTransition())</span><br></pre></td></tr></table></figure>

<p>AttemptStartedTransition 状态机会触发 AppAttemptAddedSchedulerEvent 事件，发送 SchedulerEventType.APP_ATTEMPT_ADDED 请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptStartedTransition</span> <span class="keyword">extends</span> <span class="title">BaseTransition</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(RMAppAttemptImpl appAttempt,</span></span></span><br><span class="line"><span class="params"><span class="function">        RMAppAttemptEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 跳过一些神圣的检查工作</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向调度器发送 SchedulerEventType.APP_ATTEMPT_ADDED 事件</span></span><br><span class="line">      appAttempt.eventHandler.handle(<span class="keyword">new</span> AppAttemptAddedSchedulerEvent(</span><br><span class="line">        appAttempt.applicationAttemptId, transferStateFromPreviousAttempt));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AppAttemptAddedSchedulerEvent 类继承自 SchedulerEvent 类，进入具体代码看看 SchedulerEventType.APP_ATTEMPT_ADDED 事件的处理逻辑，还是在 handle() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(SchedulerEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> NODE_ADDED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_UPDATE: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_ADDED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> NODE_RESOURCE_UPDATE: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_ADDED:</span><br><span class="line">      <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> AppAttemptAddedSchedulerEvent)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unexpected event type: &quot;</span> + event);</span><br><span class="line">      &#125;</span><br><span class="line">      AppAttemptAddedSchedulerEvent appAttemptAddedEvent =</span><br><span class="line">          (AppAttemptAddedSchedulerEvent) event;</span><br><span class="line">      addApplicationAttempt(appAttemptAddedEvent.getApplicationAttemptId(),</span><br><span class="line">        appAttemptAddedEvent.getTransferStateFromPreviousAttempt(),</span><br><span class="line">        appAttemptAddedEvent.getIsAttemptRecovering());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> APP_ATTEMPT_REMOVED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_EXPIRED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESCHEDULED: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOG.error(<span class="string">&quot;Unknown event arrived at FairScheduler: &quot;</span> + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>addApplicationAttempt() 方法会调度器发送 RMAppAttemptEventType.ATTEMPT_ADDED 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addApplicationAttempt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ApplicationAttemptId applicationAttemptId,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> transferStateFromPreviousAttempt,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">boolean</span> isAttemptRecovering)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 跳过前期的检查和初始化工作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAttemptRecovering) &#123;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(applicationAttemptId</span><br><span class="line">            + <span class="string">&quot; is recovering. Skipping notifying ATTEMPT_ADDED&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 向调度器发送 RMAppAttemptEventType.ATTEMPT_ADDED 事件</span></span><br><span class="line">      rmContext.getDispatcher().getEventHandler().handle(</span><br><span class="line">        <span class="keyword">new</span> RMAppAttemptEvent(applicationAttemptId,</span><br><span class="line">            RMAppAttemptEventType.ATTEMPT_ADDED));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RMAppAttemptEventType.ATTEMPT_ADDED 注册，并触发 ScheduleTransition 状态机，将 AppAttempt 状态从 SUBMITED 转变为 LAUNCHED_UNMANAGED_SAVING 或者 SCHEDULED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line">      <span class="comment">// Transitions from SUBMITTED state</span></span><br><span class="line">      .addTransition(RMAppAttemptState.SUBMITTED, </span><br><span class="line">          EnumSet.of(RMAppAttemptState.LAUNCHED_UNMANAGED_SAVING,</span><br><span class="line">                     RMAppAttemptState.SCHEDULED),</span><br><span class="line">          RMAppAttemptEventType.ATTEMPT_ADDED,</span><br><span class="line">          <span class="keyword">new</span> ScheduleTransition())</span><br></pre></td></tr></table></figure>

<p>看看 ScheduleTransition 状态机，if 语句开关判断是否应该获取管理 AM 的执行，如果为 true，则 RM 不会为 AM 分配一个容器并启动，默认是 false，所以这里返回的状态是 SCHEDULED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTransition</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">MultipleArcTransition</span>&lt;<span class="title">RMAppAttemptImpl</span>, <span class="title">RMAppAttemptEvent</span>, <span class="title">RMAppAttemptState</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RMAppAttemptState <span class="title">transition</span><span class="params">(RMAppAttemptImpl appAttempt,</span></span></span><br><span class="line"><span class="params"><span class="function">        RMAppAttemptEvent event)</span> </span>&#123;</span><br><span class="line">      ApplicationSubmissionContext subCtx = appAttempt.submissionContext;</span><br><span class="line">      <span class="keyword">if</span> (!subCtx.getUnmanagedAM()) &#123;</span><br><span class="line">        <span class="comment">// 跳过一部分操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配 Container，这里暂不做解释</span></span><br><span class="line">        Allocation amContainerAllocation =</span><br><span class="line">            appAttempt.scheduler.allocate(</span><br><span class="line">                appAttempt.applicationAttemptId,</span><br><span class="line">                appAttempt.amReqs,</span><br><span class="line">                EMPTY_CONTAINER_RELEASE_LIST,</span><br><span class="line">                amBlacklist.getAdditions(),</span><br><span class="line">                amBlacklist.getRemovals());</span><br><span class="line">        <span class="keyword">if</span> (amContainerAllocation != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; amContainerAllocation.getContainers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">assert</span> (amContainerAllocation.getContainers().size() == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的状态也会进行状态机转换</span></span><br><span class="line">        <span class="keyword">return</span> RMAppAttemptState.SCHEDULED;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// save state and then go to LAUNCHED state</span></span><br><span class="line">        appAttempt.storeAttempt();</span><br><span class="line">        <span class="keyword">return</span> RMAppAttemptState.LAUNCHED_UNMANAGED_SAVING;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>RMAppAttemptState.SCHEDULED 状态，会触发 RMAppAttemptEventType.CONTAINER_ALLOCATED 事件，使得 AppAttempt 状态从 SCHEDULED 转换到 ALLOCATED_SAVING，对应的处理状态机为 AMContainerAllocatedTransition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line">       <span class="comment">// Transitions from SCHEDULED State</span></span><br><span class="line">      .addTransition(RMAppAttemptState.SCHEDULED,</span><br><span class="line">          EnumSet.of(RMAppAttemptState.ALLOCATED_SAVING,</span><br><span class="line">            RMAppAttemptState.SCHEDULED),</span><br><span class="line">          RMAppAttemptEventType.CONTAINER_ALLOCATED,</span><br><span class="line">          <span class="keyword">new</span> AMContainerAllocatedTransition())</span><br></pre></td></tr></table></figure>

<p>AMContainerAllocatedTransition 状态机主要是 AM 获取分配的资源，并发送 RMAppAttemptState.ALLOCATED_SAVING 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AMContainerAllocatedTransition</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">MultipleArcTransition</span>&lt;<span class="title">RMAppAttemptImpl</span>, <span class="title">RMAppAttemptEvent</span>, <span class="title">RMAppAttemptState</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RMAppAttemptState <span class="title">transition</span><span class="params">(RMAppAttemptImpl appAttempt,</span></span></span><br><span class="line"><span class="params"><span class="function">        RMAppAttemptEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从调度器获取启动 AM 的 Container，这里的 allocate 并没有传入 AM 请求信息，表示先尝试直接获取 Container</span></span><br><span class="line">      Allocation amContainerAllocation =</span><br><span class="line">          appAttempt.scheduler.allocate(appAttempt.applicationAttemptId,</span><br><span class="line">            EMPTY_CONTAINER_REQUEST_LIST, EMPTY_CONTAINER_RELEASE_LIST, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 对 AM 资源进行判空处理，如果没有获取到之前分配的资源，在这里重新进行分配</span></span><br><span class="line">      <span class="keyword">if</span> (amContainerAllocation.getContainers().size() == <span class="number">0</span>) &#123;</span><br><span class="line">        appAttempt.retryFetchingAMContainer(appAttempt);</span><br><span class="line">        <span class="keyword">return</span> RMAppAttemptState.SCHEDULED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set the masterContainer</span></span><br><span class="line">      appAttempt.setMasterContainer(amContainerAllocation.getContainers()</span><br><span class="line">          .get(<span class="number">0</span>));</span><br><span class="line">      RMContainerImpl rmMasterContainer = (RMContainerImpl)appAttempt.scheduler</span><br><span class="line">          .getRMContainer(appAttempt.getMasterContainer().getId());</span><br><span class="line">      rmMasterContainer.setAMContainer(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      appAttempt.rmContext.getNMTokenSecretManager()</span><br><span class="line">        .clearNodeSetForAttempt(appAttempt.applicationAttemptId);</span><br><span class="line">      appAttempt.getSubmissionContext().setResource(</span><br><span class="line">        appAttempt.getMasterContainer().getResource());</span><br><span class="line">      appAttempt.storeAttempt();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向调度器发送 RMAppAttemptState.ALLOCATED_SAVING 事件</span></span><br><span class="line">      <span class="keyword">return</span> RMAppAttemptState.ALLOCATED_SAVING;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>RMAppAttemptState.ALLOCATED_SAVING 事件的注册状态机为 AttemptStoredTransition，此时 AppAttempt 状态已从 ALLOCATED_SAVING 转换为 ALLOCATED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line">       <span class="comment">// Transitions from ALLOCATED_SAVING State</span></span><br><span class="line">      .addTransition(RMAppAttemptState.ALLOCATED_SAVING, </span><br><span class="line">          RMAppAttemptState.ALLOCATED,</span><br><span class="line">          RMAppAttemptEventType.ATTEMPT_NEW_SAVED, <span class="keyword">new</span> AttemptStoredTransition())</span><br></pre></td></tr></table></figure>

<p>我们接着看 AttemptStoredTransition 状态机做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/rmapp/attempt/RMAppAttemptImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptStoredTransition</span> <span class="keyword">extends</span> <span class="title">BaseTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(RMAppAttemptImpl appAttempt, RMAppAttemptEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 运行 AppAttempt</span></span><br><span class="line">      appAttempt.launchAttempt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">launchAttempt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    launchAMStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 重点：发送 AMLauncherEventType.LAUNCH 事件启动 AM Container</span></span><br><span class="line">    eventHandler.handle(<span class="keyword">new</span> AMLauncherEvent(AMLauncherEventType.LAUNCH, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，终于看到了 AM Container 启动的曙光了，可具体是怎么启动的呢？我们接着分析。</p>
<h2 id="2-3-启动AM"><a href="#2-3-启动AM" class="headerlink" title="2.3 启动AM"></a>2.3 启动AM</h2><p>上面的发送的 AMLauncherEventType.LAUNCH 事件是启动 AM 的关键入口，可由谁来处理这个事件呢？这就需要进入到 ApplicationMasterLauncher 类来分析了，我们先来看看这个类的基本属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/amlauncher/ApplicationMasterLauncher.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMasterLauncher</span> <span class="keyword">extends</span> <span class="title">AbstractService</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">EventHandler</span>&lt;<span class="title">AMLauncherEvent</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 创建线程池实例，针对处理的每一个 AM 事件都启动一个线程</span></span><br><span class="line">  <span class="keyword">private</span> ThreadPoolExecutor launcherPool;</span><br><span class="line">  <span class="comment">// 独立线程处理 AM 的 LAUNCH 和 CLEANUP 事件</span></span><br><span class="line">  <span class="keyword">private</span> LauncherThread launcherHandlingThread;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 事件接收和处理的队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; masterEvents</span><br><span class="line">    = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">  <span class="comment">// 资源管理器上下文</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> RMContext context;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ApplicationMasterLauncher</span><span class="params">(RMContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(ApplicationMasterLauncher.class.getName());</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="comment">// 新建事件处理的线程</span></span><br><span class="line">    <span class="keyword">this</span>.launcherHandlingThread = <span class="keyword">new</span> LauncherThread();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serviceInit</span><span class="params">(Configuration conf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> threadCount = conf.getInt(</span><br><span class="line">        YARNConfiguration.RM_AMLAUNCHER_THREAD_COUNT,</span><br><span class="line">        YARNConfiguration.DEFAULT_RM_AMLAUNCHER_THREAD_COUNT);</span><br><span class="line">    ThreadFactory tf = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">&quot;ApplicationMasterLauncher #%d&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 初始化线程池</span></span><br><span class="line">    launcherPool = <span class="keyword">new</span> ThreadPoolExecutor(threadCount, threadCount, <span class="number">1</span>,</span><br><span class="line">        TimeUnit.HOURS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    launcherPool.setThreadFactory(tf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过一些配置初始化操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是创建一些执行环境，包括事件处理的独立线程 launcherHandlingThread、所需的线程池 launcherPool 及一个负责接收和处理 AM 事件的 masterEvents 事件队列。而 ApplicationMasterLauncher 类中主要处理 AM 的两种事件：LAUNCH 和 CLEANUP。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/amlauncher/ApplicationMasterLauncher.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">handle</span><span class="params">(AMLauncherEvent appEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 AMLauncherEvent 的事件类型</span></span><br><span class="line">    AMLauncherEventType event = appEvent.getType();</span><br><span class="line">    RMAppAttempt application = appEvent.getAppAttempt();</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">    <span class="comment">// 处理 AM LAUNCH 事件</span></span><br><span class="line">    <span class="keyword">case</span> LAUNCH:</span><br><span class="line">      launch(application);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 处理 AM CLEANUP 事件</span></span><br><span class="line">    <span class="keyword">case</span> CLEANUP:</span><br><span class="line">      cleanup(application);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面 2.2 小节中最后发送的 AMLauncherEventType.LAUNCH 事件正是在这里处理的，我们就以 LAUNCH 事件为例来看看具体的处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/amlauncher/ApplicationMasterLauncher.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(RMAppAttempt application)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 AMLauncher 实例，AMLauncher 继承自 Runnable</span></span><br><span class="line">    Runnable launcher = createRunnableLauncher(application, </span><br><span class="line">        AMLauncherEventType.LAUNCH);</span><br><span class="line">    <span class="comment">// 将事件添加到 masterEvents 队列中</span></span><br><span class="line">    masterEvents.add(launcher);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Runnable <span class="title">createRunnableLauncher</span><span class="params">(RMAppAttempt application, </span></span></span><br><span class="line"><span class="params"><span class="function">      AMLauncherEventType event)</span> </span>&#123;</span><br><span class="line">    Runnable launcher =</span><br><span class="line">        <span class="keyword">new</span> AMLauncher(context, application, event, getConfig());</span><br><span class="line">    <span class="keyword">return</span> launcher;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>事件被加入到事件队列之后，是如何被处理的呢？这里就是独立线程 launcherHandlingThread 所做的事了，通过消息队列的形式，在线程中逐一被消费处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/amlauncher/ApplicationMasterLauncher.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LauncherThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LauncherThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">&quot;ApplicationMaster Launcher&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isInterrupted()) &#123;   <span class="comment">// 死循环不停地处理事件请求</span></span><br><span class="line">        Runnable toLaunch;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 从事件队列中取出事件</span></span><br><span class="line">          toLaunch = masterEvents.take();</span><br><span class="line">          <span class="comment">// 从线程池中取出一个线程执行事件请求</span></span><br><span class="line">          launcherPool.execute(toLaunch);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          LOG.warn(<span class="keyword">this</span>.getClass().getName() + <span class="string">&quot; interrupted. Returning.&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br></pre></td></tr></table></figure>

<p>取出事件后具体的执行逻辑就交给 AMLaunch 类了，这里的 AMLaunch 类本身就是一个 Runnable 实例，我们直接看其 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">    <span class="keyword">case</span> LAUNCH:</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;Launching master&quot;</span> + application.getAppAttemptId());</span><br><span class="line">        <span class="comment">// 启动 launch() 方法</span></span><br><span class="line">        launch();</span><br><span class="line">        <span class="comment">// 发送 RMAppAttemptEventType.LAUNCHED 事件</span></span><br><span class="line">        handler.handle(<span class="keyword">new</span> RMAppAttemptEvent(application.getAppAttemptId(),</span><br><span class="line">            RMAppAttemptEventType.LAUNCHED));</span><br><span class="line">      &#125; <span class="keyword">catch</span>(Exception ie) &#123;</span><br><span class="line">        String message = <span class="string">&quot;Error launching &quot;</span> + application.getAppAttemptId()</span><br><span class="line">            + <span class="string">&quot;. Got exception: &quot;</span> + StringUtils.stringifyException(ie);</span><br><span class="line">        LOG.info(message);</span><br><span class="line">        handler.handle(<span class="keyword">new</span> RMAppAttemptLaunchFailedEvent(application</span><br><span class="line">            .getAppAttemptId(), message));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CLEANUP: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      LOG.warn(<span class="string">&quot;Received unknown event-type &quot;</span> + eventType + <span class="string">&quot;. Ignoring.&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AMLaunch 类的 launch() 方法操作会调用 RPC 函数与 NodeManager 通信，来启动 AM Container，这里 AM 与 NM 交互是通过 ContainerManagementProtocol 协议来实现 RPC 调用的。launch() 方法运行完成后会向调度器发送 RMAppAttemptEventType.LAUNCHED 事件，并将 AppAttempt 的状态从 ALLOCATED 转换为 LAUNCHED。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span> <span class="keyword">throws</span> IOException, YARNException </span>&#123;</span><br><span class="line">    connect();</span><br><span class="line">    ContainerId masterContainerID = masterContainer.getId();</span><br><span class="line">    ApplicationSubmissionContext applicationContext =</span><br><span class="line">      application.getSubmissionContext();</span><br><span class="line">    LOG.info(<span class="string">&quot;Setting up container &quot;</span> + masterContainer</span><br><span class="line">        + <span class="string">&quot; for AM &quot;</span> + application.getAppAttemptId());  </span><br><span class="line">    ContainerLaunchContext launchContext =</span><br><span class="line">        createAMContainerLaunchContext(applicationContext, masterContainerID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 Container 请求信息</span></span><br><span class="line">    StartContainerRequest scRequest =</span><br><span class="line">        StartContainerRequest.newInstance(launchContext,</span><br><span class="line">          masterContainer.getContainerToken());</span><br><span class="line">    List&lt;StartContainerRequest&gt; list = <span class="keyword">new</span> ArrayList&lt;StartContainerRequest&gt;();</span><br><span class="line">    list.add(scRequest);</span><br><span class="line">    StartContainersRequest allRequests =</span><br><span class="line">        StartContainersRequest.newInstance(list);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重点：调用 RPC 函数启动 Container</span></span><br><span class="line">    StartContainersResponse response =</span><br><span class="line">        containerMgrProxy.startContainers(allRequests);</span><br><span class="line">    <span class="keyword">if</span> (response.getFailedRequests() != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; response.getFailedRequests().containsKey(masterContainerID)) &#123;</span><br><span class="line">      Throwable t =</span><br><span class="line">          response.getFailedRequests().get(masterContainerID).deSerialize();</span><br><span class="line">      parseAndThrowException(t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Done launching container &quot;</span> + masterContainer + <span class="string">&quot; for AM &quot;</span></span><br><span class="line">          + application.getAppAttemptId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，用于运行 ApplicationMaster 的 Container 已经启动，具体的 Container 启动逻辑在这里不做分析，AM Container 在具体的 NodeManager 上启动后，Container 会根据上下文信息启动 ApplicationMaster 进程，ApplicationMaster 生命周期的第一步 ApplicationMaster 启动在这里已经完成了。</p>
<h1 id="3-AM-心跳上报及资源申请"><a href="#3-AM-心跳上报及资源申请" class="headerlink" title="3. AM 心跳上报及资源申请"></a>3. AM 心跳上报及资源申请</h1><p>这部分主要介绍 ApplicationMaster 启动是做了哪些工作，如何向 ResourceManager 进行注册和心跳，以及如何申请 Container 资源。</p>
<h2 id="3-1-AM注册-心跳上报"><a href="#3-1-AM注册-心跳上报" class="headerlink" title="3.1 AM注册/心跳上报"></a>3.1 AM注册/心跳上报</h2><p>Container 的启动会触发 ApplicationMaster 进程的启动，于是我们从 ApplicationMaster 类的 main() 方法作为入口，来看看 ApplicationMaster 启动时做了哪些工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationMaster appMaster = <span class="keyword">new</span> ApplicationMaster();</span><br><span class="line">      LOG.info(<span class="string">&quot;Initializing ApplicationMaster&quot;</span>);</span><br><span class="line">      <span class="keyword">boolean</span> doRun = appMaster.init(args);</span><br><span class="line">      <span class="keyword">if</span> (!doRun) &#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// AM 启动的核心 run() 方法</span></span><br><span class="line">      appMaster.run();</span><br><span class="line">      result = appMaster.finish();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      LOG.fatal(<span class="string">&quot;Error running ApplicationMaster&quot;</span>, t);</span><br><span class="line">      LogManager.shutdown();</span><br><span class="line">      ExitUtil.terminate(<span class="number">1</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Application Master completed successfully. exiting&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Application Master failed. exiting&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>run() 方法是 AM 启动的核心入口方法。这里主要是初始化相关 RPC 客户端实例，并开始向 RM 进行注册和心跳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;Starting ApplicationMaster&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过 tokens 的检查工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 AMRMClientAsync 实例，用于 AM 与 RM 之间进行交互</span></span><br><span class="line">    AMRMClientAsync.CallbackHandler allocListener = <span class="keyword">new</span> RMCallbackHandler();</span><br><span class="line">    amRMClient = AMRMClientAsync.createAMRMClientAsync(<span class="number">1000</span>, allocListener);</span><br><span class="line">    amRMClient.init(conf);</span><br><span class="line">    amRMClient.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 NMClientAsync 实例，用于 AM 与 NM 之间进行交互</span></span><br><span class="line">    containerListener = createNMCallbackHandler();</span><br><span class="line">    nmClientAsync = <span class="keyword">new</span> NMClientAsyncImpl(containerListener);</span><br><span class="line">    nmClientAsync.init(conf);</span><br><span class="line">    nmClientAsync.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点：AM 向 RM 进行注册，这里也会向 RM 发送心跳请求</span></span><br><span class="line">    appMasterHostname = NetUtils.getHostname();</span><br><span class="line">    RegisterApplicationMasterResponse response = amRMClient</span><br><span class="line">        .registerApplicationMaster(appMasterHostname, appMasterRpcPort,</span><br><span class="line">            appMasterTrackingUrl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳过资源限制检查及 Container 状态的记录过程</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AM 与 RM 进行 RPC 通信是通过 ApplicationMasterService 服务实现的，在看服务端 registerApplicationMaster 注册函数前，先来看看客户端的注册函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RegisterApplicationMasterResponse <span class="title">registerApplicationMaster</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      String appHostName, <span class="keyword">int</span> appHostPort, String appTrackingUrl)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// AM 注册</span></span><br><span class="line">    RegisterApplicationMasterResponse response = client</span><br><span class="line">        .registerApplicationMaster(appHostName, appHostPort, appTrackingUrl);</span><br><span class="line">    <span class="comment">// 启动 AM 心跳上报线程</span></span><br><span class="line">    heartbeatThread.start();</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看 AM 注册过程。注册时做了两件事，一个是更新 AM 在 AMLivelinessMonitor 中的最新事件，另一个是发送 RMAppAttemptEventType.REGISTERED 事件，触发 AMRegisteredTransition 状态机，并将 AppAttempt 状态从 LAUNCHED 转换为 RUNNING。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RegisterApplicationMasterResponse <span class="title">registerApplicationMaster</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      RegisterApplicationMasterRequest request)</span> <span class="keyword">throws</span> YARNException,</span></span><br><span class="line"><span class="function">      IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow only one thread in AM to do registerApp at a time.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="comment">// 省略</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 更新 AM 在 AMLivelinessMonitor 中最近汇报心跳的事件</span></span><br><span class="line">      <span class="keyword">this</span>.amLivelinessMonitor.receivedPing(applicationAttemptId);</span><br><span class="line">      RMApp app = <span class="keyword">this</span>.rmContext.getRMApps().get(appID);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Setting the response id to 0 to identify if the</span></span><br><span class="line">      <span class="comment">// application master is register for the respective attemptid</span></span><br><span class="line">      lastResponse.setResponseId(<span class="number">0</span>);</span><br><span class="line">      lock.setAllocateResponse(lastResponse);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// AM 注册关键逻辑，发送 RMAppAttemptEventType.REGISTERED 事件</span></span><br><span class="line">      LOG.info(<span class="string">&quot;AM registration &quot;</span> + applicationAttemptId);</span><br><span class="line">      <span class="keyword">this</span>.rmContext</span><br><span class="line">        .getDispatcher()</span><br><span class="line">        .getEventHandler()</span><br><span class="line">        .handle(</span><br><span class="line">          <span class="keyword">new</span> RMAppAttemptRegistrationEvent(applicationAttemptId, request</span><br><span class="line">            .getHost(), request.getRpcPort(), request.getTrackingUrl()));</span><br><span class="line">      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,</span><br><span class="line">        <span class="string">&quot;ApplicationMasterService&quot;</span>, appID, applicationAttemptId);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接着来看看 AM 心跳上报流程。heartbeatThread 线程是处理 AM 的独立线程，其初始化过程如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMRMClientAsyncImpl</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ContainerRequest</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AMRMClientAsync</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// AM 心跳线程对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HeartbeatThread heartbeatThread;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Private</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AMRMClientAsyncImpl</span><span class="params">(AMRMClient&lt;T&gt; client, <span class="keyword">int</span> intervalMs,</span></span></span><br><span class="line"><span class="params"><span class="function">      CallbackHandler callbackHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(client, intervalMs, callbackHandler);</span><br><span class="line">    <span class="comment">// 初始化 AM 心跳线程实例</span></span><br><span class="line">    heartbeatThread = <span class="keyword">new</span> HeartbeatThread();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AM 向 RM 注册后，周期性地通过 RPC 函数 ApplicationMasterProtocol#allocate() 方法与 RM 通信，该方法主要有以下是三个作用：</p>
<ul>
<li>请求申请；</li>
<li>获取新分配地资源；</li>
<li>形成周期性心跳，告诉 RM 自己还活着。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartbeatThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">&quot;AMRM Heartbeater thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">// 心跳线程死循环的跑</span></span><br><span class="line">        AllocateResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// synchronization ensures we don&#x27;t send heartbeats after unregistering</span></span><br><span class="line">        <span class="keyword">synchronized</span> (unregisterHeartbeatLock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!keepRunning) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重点：心跳线程其实就是周期性的调用 allocate() 方法</span></span><br><span class="line">            response = client.allocate(progress);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ApplicationAttemptNotFoundException e) &#123;</span><br><span class="line">            handler.onShutdownRequest();</span><br><span class="line">            LOG.info(<span class="string">&quot;Shutdown requested. Stopping callback.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Exception on heartbeat&quot;</span>, ex);</span><br><span class="line">            savedException = ex;</span><br><span class="line">            <span class="comment">// interrupt handler thread in case it waiting on the queue</span></span><br><span class="line">            handlerThread.interrupt();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                responseQueue.put(response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Interrupted while waiting to put on response queue&quot;</span>, ex);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(heartbeatIntervalMs.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;Heartbeater interrupted&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，AM 已经完成向 RM 的注册及周期性心跳上报的过程，其中心跳上报是通过周期性地调用 ApplicationMasterProtocol#allocate() 方法来实现的。AM 心跳开始后，便会定期的向 RM 申请资源，以在对应的 NodeManager 上启动 Container 进程，在下一部分中会详细介绍。</p>
<h2 id="3-2-AM资源申请与分配"><a href="#3-2-AM资源申请与分配" class="headerlink" title="3.2 AM资源申请与分配"></a>3.2 AM资源申请与分配</h2><p>AM 资源申请与分配的对象都是针对 Container，下面也是以 Container 的申请与分配作为介绍内容。</p>
<h3 id="3-2-1-原理介绍"><a href="#3-2-1-原理介绍" class="headerlink" title="3.2.1 原理介绍"></a>3.2.1 原理介绍</h3><p> <img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/07/76b28970968e92a0a2ae949cea27599f-1372882-20200826172856403-72149053-b8e974.png" alt="img"></p>
<center>Container 分配与申请流程</center>

<p>如上图，应用程序的 AM 在 NM 上成功启动并向 RM 注册后，向 RM 请求资源（Container）到获取到资源的整个过程，分为两个阶段：</p>
<p>阶段一：AM 汇报资源资源并领取已经分配到的资源；</p>
<ol>
<li>AM 通过 RPC 函数 ApplicationMasterProtocol#allocate 向 RM 汇报资源需求（由于是周期性调用，也叫“心跳”），包括包括新的资源需求描述、待释放的 Container 列表、请求加入黑名单的节点列表、请求移除黑名单的节点列表等；</li>
<li>RM 中的 ApplicationMasterService 负责处理来自 ApplicationMaster 的请求，一旦受到请求，会向 RMAppAttemptImpl 发送一个 RMAppAttemptEventType.STATUS_UPDATE 类型事件，而 RMAppAttempImpl 收到该事件后，将更新应用程序执行进度和 AMLivelinessMonitor 中记录的应用程序最近更新事件。</li>
<li>ApplicationMasterService 调用 ResourceScheduler#allocate 函数，将 ApplicationMaster 资源需求汇报给 ResourceScheduler。</li>
<li>ResourceScheduler 首先读取待释放 Contianer 列表，依次向对应的 RMContainerImpl 发送 RMContainerEventType.RELEASED 类型事件，以杀死正在运行的 Container，然后将新的资源需求更新到对应数据中，并返回已经为该应用程序分配的资源。</li>
</ol>
<p>阶段二：NM 向 RM 汇报各个 Container 运行状态，如果 RM 发现它上面又空闲的资源，则进行一次分配，并将分配的资源保存到 RM 数据结构中，等待下次 AM 发送心跳时获取。</p>
<ol>
<li>NM 通过 RPC 函数 ResourceTracker#nodeHeartbeat 向 RM 汇报各个 Container 运行状态。</li>
<li>RM 中的 ResourceTrackerService 负责处理来自 NM 的请求，一旦收到请求，会向 RMNodeImpl 发送一个 RMNodeEventType.STATUS_UPDATE 事件，而 RMNodeImpl 收到事件后，将更新各个 Container 运行状态，并进一步向 ResourceScheduler 发送一个 SchedulerEventType.NODE_UPDATE 事件。</li>
<li>ResourceScheduler 收到事件后，如果该节点又可分配的空闲资源，则会将这些资源分配给各个应用程序，而分配后的资源仅是记录到对应数据结构中，等待 ApplicationMaster 下次通过心跳机制来领取。</li>
</ol>
<h3 id="3-2-2-源码分析"><a href="#3-2-2-源码分析" class="headerlink" title="3.2.2 源码分析"></a>3.2.2 源码分析</h3><p>客户端调用 AMRMClientAsyncImpl#allocate() 方法会通过 RPC 函数向 RM 汇报资源需求，其通信接口是由 ApplicationMasterProtocol 协议来实现，来看看该协议是如何为客户端申请资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：rg/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AllocateResponse <span class="title">allocate</span><span class="params">(AllocateRequest request)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> YARNException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      AllocateResponse lastResponse = lock.getAllocateResponse();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发送 STATUS_UPDATE 更新 AppAttempt 状态</span></span><br><span class="line">      <span class="keyword">this</span>.rmContext.getDispatcher().getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> RMAppAttemptStatusupdateEvent(appAttemptId, request</span><br><span class="line">              .getProgress()));             </span><br><span class="line">      <span class="comment">// 检查队列中的 memory 和 vcore 是否足够</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        RMServerUtils.normalizeAndValidateRequests(ask,</span><br><span class="line">            rScheduler.getMaximumResourceCapability(), app.getQueue(),</span><br><span class="line">            rScheduler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvalidResourceRequestException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Invalid resource ask by application &quot;</span> + appAttemptId, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 重点：调用调度器的 allocate() 方法向 RM 上报资源需求</span></span><br><span class="line">      Allocation allocation =</span><br><span class="line">          <span class="keyword">this</span>.rScheduler.allocate(appAttemptId, ask, release, </span><br><span class="line">              blacklistAdditions, blacklistRemovals);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新请求的 response 和 AMRMToken 的状态，省略具体流程</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> allocateResponse;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationMasterService#allocate() 方法会调用 YARNScheduler 的 allocate() 分配方法，由于采用是 FairScheduler 调度器，我们来分析下 FairScheduler#allocate() 方法。分配过程的核心在 pullNewlyAllocatedContainersAndNMTokens() 方法，该方法的核心是从 newlyAllocatedContainers 这个 List 数据结构中取 Container，那取到的 Container 是从哪儿来的呢？其实就是 NoddeManager 心跳发生时进行资源分配逻辑分配出来的 Container，是保存在 RM 的内存数据结构 newlyAllocatedContainers 中，AM 则直接从该数据结构中取对应的 Container。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Allocation <span class="title">allocate</span><span class="params">(ApplicationAttemptId appAttemptId,</span></span></span><br><span class="line"><span class="params"><span class="function">      List&lt;ResourceRequest&gt; ask, List&lt;ContainerId&gt; release,</span></span></span><br><span class="line"><span class="params"><span class="function">      List&lt;String&gt; blacklistAdditions, List&lt;String&gt; blacklistRemovals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规整化资源请求</span></span><br><span class="line">    SchedulerUtils.normalizeRequests(ask, DOMINANT_RESOURCE_CALCULATOR,</span><br><span class="line">        getClusterResource(), minimumAllocation, getMaximumResourceCapability(),</span><br><span class="line">        incrAllocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 Container 分配的开始时间</span></span><br><span class="line">    application.recordContainerRequestTime(getClock().getTime());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release containers</span></span><br><span class="line">    releaseContainers(release, application);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (application) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!ask.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;allocate: pre-update&quot;</span> +</span><br><span class="line">              <span class="string">&quot; applicationAttemptId=&quot;</span> + appAttemptId +</span><br><span class="line">              <span class="string">&quot; application=&quot;</span> + application.getApplicationId());</span><br><span class="line">        &#125;</span><br><span class="line">        application.showRequests();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update application requests</span></span><br><span class="line">        application.updateResourceRequests(ask);</span><br><span class="line"></span><br><span class="line">        application.showRequests();</span><br><span class="line">      &#125;</span><br><span class="line">      ... <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重点：对 Container 进行鉴权，并拿到之前为 AppAttempt 分配的 Container 资源</span></span><br><span class="line">      <span class="comment">// 该资源保存在 RM 内存数据结构中，由 assignContainer() 方法分配出来的，具体分配逻辑可以看 YARN 的调度逻辑</span></span><br><span class="line">      ContainersAndNMTokensAllocation allocation =</span><br><span class="line">          application.pullNewlyAllocatedContainersAndNMTokens();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Record container allocation time</span></span><br><span class="line">      <span class="keyword">if</span> (!(allocation.getContainerList().isEmpty())) &#123;</span><br><span class="line">        application.recordContainerAllocationTime(getClock().getTime());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将分配的 Container 资源返回给客户端（AM）</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Allocation(allocation.getContainerList(),</span><br><span class="line">        application.getHeadroom(), preemptionContainerIds, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">        allocation.getNMTokenList());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，AM 周期性心跳进行资源申请的逻辑在这里已经拿到了 Container，那拿到 Container 后又怎样启动呢，不同任务类型的启动方式不太一样，这里就不做详细介绍。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>董西成，《Hadoop技术内幕：深入分析YARN架构设计与实现原理》</li>
<li><a href="https://blog.csdn.net/weixin_42642341/article/details/81636135">YARN源码剖析（三）— ApplicationMaster的启动</a></li>
<li><a href="https://blog.csdn.net/Androidlushangderen/article/details/48128955">YARN源码分析(一)—–ApplicationMaster</a></li>
<li><a href="https://blog.csdn.net/weixin_42642341/article/details/82354964">Yarn源码剖析（四）– AM的注册与资源调度申请Container及启动</a></li>
</ul>
]]></content>
      <categories>
        <category>YARN</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>YARN</tag>
      </tags>
  </entry>
</search>
