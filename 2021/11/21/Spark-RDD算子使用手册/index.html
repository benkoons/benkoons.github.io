<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Spark 的 RDD 算子分为 Transformation 算子和 Action 算子，其中Transformation 操作是延迟计算（又叫惰性计算，lazy execution）的，也就是说从一个 RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算。Action 算子会触发 SparkContext 提交 Job 作业，并将数据输出">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark RDD算子使用手册">
<meta property="og:url" content="http://yoursite.com/2021/11/21/Spark-RDD%E7%AE%97%E5%AD%90%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="笨小康的博客">
<meta property="og:description" content="Spark 的 RDD 算子分为 Transformation 算子和 Action 算子，其中Transformation 操作是延迟计算（又叫惰性计算，lazy execution）的，也就是说从一个 RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算。Action 算子会触发 SparkContext 提交 Job 作业，并将数据输出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/21/c805d9665b3b320d46be35da36ba5ac9-image-20211121223351191-bd288a.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/21/a62d5348a80c73b5c4d83851bc068b5c-image-20211121223405459-be7562.png">
<meta property="article:published_time" content="2021-11-21T14:18:57.000Z">
<meta property="article:modified_time" content="2021-11-21T15:19:28.550Z">
<meta property="article:author" content="笨小康">
<meta property="article:tag" content="大数据">
<meta property="article:tag" content="Spark">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/21/c805d9665b3b320d46be35da36ba5ac9-image-20211121223351191-bd288a.png">

<link rel="canonical" href="http://yoursite.com/2021/11/21/Spark-RDD%E7%AE%97%E5%AD%90%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spark RDD算子使用手册 | 笨小康的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">笨小康的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">星辰大海, 如期而至</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签云</a>

  </li>
        <li class="menu-item menu-item-photography">

    <a href="/categories/photography/" rel="section"><i class="fa fa-camera fa-fw"></i>摄影集</a>

  </li>
        <li class="menu-item menu-item-flomo">

    <a href="/categories/flomo/" rel="section"><i class="fa fa-lightbulb fa-fw"></i>随想录</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜文章
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/21/Spark-RDD%E7%AE%97%E5%AD%90%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="笨小康">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="笨小康的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spark RDD算子使用手册
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-21 22:18:57" itemprop="dateCreated datePublished" datetime="2021-11-21T22:18:57+08:00">2021-11-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spark/" itemprop="url" rel="index"><span itemprop="name">Spark</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Spark 的 RDD 算子分为 Transformation 算子和 Action 算子，其中Transformation 操作是延迟计算（又叫惰性计算，lazy execution）的，也就是说从一个 RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算。Action 算子会触发 SparkContext 提交 Job 作业，并将数据输出 Spark系统。</p>
<h1 id="1-RDD概览"><a href="#1-RDD概览" class="headerlink" title="1. RDD概览"></a>1. RDD概览</h1><p>从大方向来看，Spark RDD 算子氛围 Transformation 算子和 Action 算子，从小方向来看：RDD 算子又可分为以下三类:</p>
<ul>
<li><p>针对 value 数据类型的Transformation算子，这种变换并不触发提交作业，处理的数据项是 value 型的数据。</p>
</li>
<li><p>针对 key-value数据类型的 Transfromation 算子，这种变换并不触发提交作业，处理的数据项是 key-value 型的数据对。</p>
</li>
<li><p>Action算子，这类算子会触发 SparkContext 提交 Job 作业。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/21/c805d9665b3b320d46be35da36ba5ac9-image-20211121223351191-bd288a.png" alt="image-20211121223351191"></p>
<p><img src="https://cdn.jsdelivr.net/gh/benkoons/blog-imgs/blog-imgs/2021/11/21/a62d5348a80c73b5c4d83851bc068b5c-image-20211121223405459-be7562.png" alt="image-20211121223405459"></p>
<h1 id="2-RDD的创建"><a href="#2-RDD的创建" class="headerlink" title="2. RDD的创建"></a>2. RDD的创建</h1><h2 id="2-1-从集合创建RDD"><a href="#2-1-从集合创建RDD" class="headerlink" title="2.1 从集合创建RDD"></a>2.1 从集合创建RDD</h2><h3 id="parallelize"><a href="#parallelize" class="headerlink" title="parallelize"></a>parallelize</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parallelize</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      seq: <span class="type">Seq</span>[<span class="type">T</span>],</span><br><span class="line">      numSlices: <span class="type">Int</span> = defaultParallelism): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">sparkcontext.parallelize(<span class="number">1</span> to <span class="number">10</span>, <span class="number">3</span>)	<span class="comment">// 创建数据为(1,2,3,4,5,6,7,8,9,10)，分区数为3的RDD</span></span><br></pre></td></tr></table></figure>

<h3 id="makeRDD"><a href="#makeRDD" class="headerlink" title="makeRDD"></a>makeRDD</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeRDD</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      seq: <span class="type">Seq</span>[<span class="type">T</span>],</span><br><span class="line">      numSlices: <span class="type">Int</span> = defaultParallelism): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">sparkcontext.parallelize(<span class="number">1</span> to <span class="number">10</span>, <span class="number">3</span>)	<span class="comment">// 创建数据为(1,2,3,4,5,6,7,8,9,10)，分区数为3的RDD</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-从外部存储创建RDD"><a href="#2-2-从外部存储创建RDD" class="headerlink" title="2.2 从外部存储创建RDD"></a>2.2 从外部存储创建RDD</h2><p>从外部存储创建RDD，可以从存储系统文件创建，也可以从Hadoop接口API创建，所有的调用主体均为 <code>SparkContext</code>。</p>
<ul>
<li><p>从HDFS/本地文件格式创建：</p>
</li>
<li><ul>
<li>textFile</li>
<li>hadoopFile</li>
</ul>
</li>
<li><ul>
<li>sequenceFile</li>
<li>objectFile</li>
</ul>
</li>
<li><ul>
<li>newAPIHadoopFile</li>
</ul>
</li>
<li><p>从Hadoop接口API创建：</p>
</li>
<li><ul>
<li>hadoopRDD</li>
<li>newAPIHadoopRDD</li>
</ul>
</li>
</ul>
<p>用法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sparkcontext.textFile(<span class="string">&quot;/Users/11085245/Documents/code/personal/data/&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="3-Transformation算子"><a href="#3-Transformation算子" class="headerlink" title="3. Transformation算子"></a>3. Transformation算子</h1><h2 id="3-1-单个RDD转换"><a href="#3-1-单个RDD转换" class="headerlink" title="3.1 单个RDD转换"></a>3.1 单个RDD转换</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>将一个RDD中的每个数据项，通过map中的函数映射变为一个新的元素。输入分区与输出分区一对一，即：有多少个输入分区，就有多少个输出分区。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------map-------------------&quot;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * map</span></span><br><span class="line"><span class="comment">  * f: Int =&gt; U</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * foreach</span></span><br><span class="line"><span class="comment">  * f: Int =&gt; Unit</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">val</span> array1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> rdd1: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize(array1)</span><br><span class="line"><span class="keyword">val</span> res1: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd1.map(x =&gt; x*x)</span><br><span class="line">res1.foreach(x =&gt; println(x))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------------------map-------------------</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>第一步和map一样，最后将所有的输出分区合并成一个。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">TraversableOnce</span>[<span class="type">U</span>]): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>

<p>程序例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------flatMap-------------------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> array4 = <span class="type">Array</span>(<span class="string">&quot;hello spark&quot;</span>, <span class="string">&quot;hello hadoop&quot;</span>, <span class="string">&quot;hello scala&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> rdd4: <span class="type">RDD</span>[<span class="type">String</span>] = sc.parallelize(array4)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * flatMap</span></span><br><span class="line"><span class="comment">    * f: String =&gt; TraversableOnce[U]</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * flatMap 与 map 的区别</span></span><br><span class="line"><span class="comment">    *   - flatMap 返回 RDD[String] 数组，成员为 String</span></span><br><span class="line"><span class="comment">    *   - map 返回 RDD[List[String]] 数组，成员为 List[String]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">println(<span class="string">&quot;-------flapMap输出--------&quot;</span>) </span><br><span class="line">  <span class="keyword">val</span> res4: <span class="type">RDD</span>[<span class="type">String</span>] = rdd4.flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>).toList)</span><br><span class="line">  res4.foreach(x =&gt; println(x))</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;-------map输出--------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> res4_1: <span class="type">RDD</span>[<span class="type">List</span>[<span class="type">String</span>]] = rdd4.map(line =&gt; line.split(<span class="string">&quot; &quot;</span>).toList)</span><br><span class="line">  res4_1.foreach(x =&gt; println(x))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--------------------flatMap-------------------</span><br><span class="line">println(&quot;-------flatMap输出--------&quot;) </span><br><span class="line">hello</span><br><span class="line">spark</span><br><span class="line">hello</span><br><span class="line">hadoop</span><br><span class="line">hello</span><br><span class="line">scala</span><br><span class="line">println(&quot;-------map输出--------&quot;)</span><br><span class="line">List(hello, spark)</span><br><span class="line">List(hello, hadoop)</span><br><span class="line">List(hello, scala)</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>将 RDD 中的每个数据项，根据 filter 映射函数中的过滤条件过滤数据，返回一个 RDD 对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">传入一个映射函数，如果函数返回 <span class="literal">true</span>，则保留元素，返回 <span class="literal">false</span> 则过滤掉元素</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------filter-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array3 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> rdd3: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize(array3)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * filter</span></span><br><span class="line"><span class="comment">  * f: Int =&gt; Boolean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">val</span> res3: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd3.filter(x =&gt; <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span>)</span><br><span class="line">res3.foreach(x =&gt; println(x))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------------------filter-------------------</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="mapPartitions"><a href="#mapPartitions" class="headerlink" title="mapPartitions"></a>mapPartitions</h3><p>该函数和map函数类似，只不过映射函数的参数由RDD中的每一个元素变成了RDD中每一个分区的迭代器。如果在映射的过程中需要频繁创建额外的对象，使用mapPartitions要比map高效的过。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitions</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      f: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],</span><br><span class="line">      preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">f: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">Iterator</span>[<span class="type">U</span>] 表示映射函数</span><br><span class="line">preservesPartitioning 表示是否保留父<span class="type">RDD</span>的partitioner分区信息</span><br></pre></td></tr></table></figure>

<p>程序例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------mapPartition-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array2 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 创建具有2个分区的RDD</span></span><br><span class="line"><span class="keyword">val</span> rdd2: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize(array2, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * mapPartitons</span></span><br><span class="line"><span class="comment">  * f: Iterator[Int] =&gt; Iterator[U]</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * mapPartitions 与 map 的区别</span></span><br><span class="line"><span class="comment">  *   - mapPartitions 每次处理一个分区的数据</span></span><br><span class="line"><span class="comment">  *   - map 操作每次处理一个元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> println(<span class="string">&quot;------mapPartitions输出----&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> res2: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd2.mapPartitions((x: <span class="type">Iterator</span>[<span class="type">Int</span>]) =&gt; &#123;</span><br><span class="line">  println(<span class="string">&quot;执行了一次mapPartitions操作&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> newList: <span class="type">List</span>[<span class="type">Int</span>] = x.toList.map(y =&gt; y*y)</span><br><span class="line">  newList.toIterator</span><br><span class="line">&#125;)</span><br><span class="line">res2.foreach(x =&gt; println(x))</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;------map输出----&quot;</span>)</span><br><span class="line">rdd2.map(x =&gt; &#123;</span><br><span class="line">  println(<span class="string">&quot;执行一次map操作&quot;</span>)</span><br><span class="line">  x</span><br><span class="line">&#125;).foreach(println)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--------------------mapPartition-------------------</span><br><span class="line">------mapPartitions输出----</span><br><span class="line">执行了一次mapPartitions操作</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">执行了一次mapPartitions操作</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">------map输出----</span><br><span class="line">执行一次map操作</span><br><span class="line">1</span><br><span class="line">执行一次map操作</span><br><span class="line">2</span><br><span class="line">执行一次map操作</span><br><span class="line">3</span><br><span class="line">执行一次map操作</span><br><span class="line">4</span><br><span class="line">执行一次map操作</span><br><span class="line">5</span><br><span class="line">执行一次map操作</span><br><span class="line">6</span><br><span class="line">执行一次map操作</span><br><span class="line">7</span><br><span class="line">执行一次map操作</span><br><span class="line">8</span><br><span class="line">执行一次map操作</span><br><span class="line">9</span><br><span class="line">执行一次map操作</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="mapPartitionsWithIndex"><a href="#mapPartitionsWithIndex" class="headerlink" title="mapPartitionsWithIndex"></a>mapPartitionsWithIndex</h3><p>函数作用同mapPartitions，不过提供了两个参数，第一个参数为分区的索引。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mapPartitionsWithIndex</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      f: (<span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],</span><br><span class="line">      preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">和map类似，只是多了一个 <span class="type">Int</span> 表示分区索引</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------mapPartitionsWithIndex-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array5 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> rdd5: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize(array5, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * f: (Int, Iterator[String]) =&gt; Iterator[U]</span></span><br><span class="line"><span class="comment">  * 函数 f 中的 Int 就是分区编号，分区编号从 0 开始</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">val</span> res5: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd5.mapPartitionsWithIndex((index: <span class="type">Int</span>, data: <span class="type">Iterator</span>[<span class="type">Int</span>]) =&gt; &#123;</span><br><span class="line">  println(<span class="string">&quot;当前处理分区编号为: &quot;</span> + index)</span><br><span class="line">  <span class="keyword">val</span> newList: <span class="type">List</span>[<span class="type">Int</span>] = data.map(x =&gt; x * x).toList</span><br><span class="line">  newList.toIterator</span><br><span class="line">&#125;)</span><br><span class="line">res5.foreach(x =&gt; println(x))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--------------------mapPartitionsWithIndex-------------------</span><br><span class="line">当前处理分区编号为: 0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">当前处理分区编号为: 1</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">当前处理分区编号为: 2</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h2 id="3-2-组合其他RDD"><a href="#3-2-组合其他RDD" class="headerlink" title="3.2 组合其他RDD"></a>3.2 组合其他RDD</h2><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>将两个RDD进行合并，不去重。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">other：求和的其他 <span class="type">RDD</span></span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------union-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array1_1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> array1_2 = <span class="type">Array</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">val</span> rdd1_1 = sc.parallelize(array1_1)</span><br><span class="line"><span class="keyword">val</span> rdd1_2 = sc.parallelize(array1_2)</span><br><span class="line"><span class="keyword">val</span> res1: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd1_1.union(rdd1_2)</span><br><span class="line">res1.foreach(println)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------------------union-------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join相当于SQL中的内关联join，根据key关联两个 RDD 的结果，只返回两个RDD key可以关联上的结果，关联不上的不输出，join只能用于两个RDD之间的关联，如果要多个RDD关联，多关联几次即可。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">W</span>))]</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)], numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">W</span>))]</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)], partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">W</span>))]</span><br><span class="line"></span><br><span class="line">参数说明</span><br><span class="line">other		表示关联的其他 <span class="type">RDD</span></span><br><span class="line">numPartitions 表示关联后的分区数</span><br><span class="line">partitioner	 	表示关联的分区函数</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------join-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list2_1 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>),(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> list2_2 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="string">&quot;hello&quot;</span>),(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;hadoop&quot;</span>),(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;spark&quot;</span>),(<span class="string">&quot;e&quot;</span>,<span class="string">&quot;flink&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> rdd2_1 = sc.parallelize(list2_1)</span><br><span class="line"><span class="keyword">val</span> rdd2_2 = sc.parallelize(list2_2)</span><br><span class="line"><span class="keyword">val</span> res2: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">String</span>))] = rdd2_1.join(rdd2_2)</span><br><span class="line">res2.foreach(x =&gt; println(x))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--------------------join-------------------</span><br><span class="line">(a,(1,hello))</span><br><span class="line">(b,(2,hadoop))</span><br><span class="line">(c,(3,spark))</span><br></pre></td></tr></table></figure>

<h3 id="cogroup"><a href="#cogroup" class="headerlink" title="cogroup"></a>cogroup</h3><p>cogroup相当于SQL中的全外关联full outer join，返回左右RDD中的记录，关联不上的用 null 表示。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"># 参数为一个<span class="type">RDD</span></span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W</span>]))]</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)], partitioner: <span class="type">Partitioner</span>)</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W</span>]))]</span><br><span class="line"></span><br><span class="line"># 参数为两个<span class="type">RDD</span></span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W1</span>, <span class="type">W2</span>](other1: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W1</span>)], other2: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W2</span>)])</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W1</span>], <span class="type">Iterable</span>[<span class="type">W2</span>]))]</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W1</span>, <span class="type">W2</span>](other1: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W1</span>)], other2: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W2</span>)], numPartitions: <span class="type">Int</span>)</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W1</span>], <span class="type">Iterable</span>[<span class="type">W2</span>]))]</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W1</span>, <span class="type">W2</span>](other1: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W1</span>)], other2: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W2</span>)], partitioner: <span class="type">Partitioner</span>)</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W1</span>], <span class="type">Iterable</span>[<span class="type">W2</span>]))]</span><br><span class="line"></span><br><span class="line"># 参数为三个<span class="type">RDD</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W1</span>, <span class="type">W2</span>, <span class="type">W3</span>](other1: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W1</span>)], other2: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W2</span>)], other3: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W3</span>)])</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W1</span>], <span class="type">Iterable</span>[<span class="type">W2</span>], <span class="type">Iterable</span>[<span class="type">W3</span>]))]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W1</span>, <span class="type">W2</span>, <span class="type">W3</span>](other1: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W1</span>)],</span><br><span class="line">      other2: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W2</span>)],</span><br><span class="line">      other3: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W3</span>)],</span><br><span class="line">      numPartitions: <span class="type">Int</span>)</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W1</span>], <span class="type">Iterable</span>[<span class="type">W2</span>], <span class="type">Iterable</span>[<span class="type">W3</span>]))]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W1</span>, <span class="type">W2</span>, <span class="type">W3</span>](other1: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W1</span>)],</span><br><span class="line">      other2: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W2</span>)],</span><br><span class="line">      other3: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W3</span>)],</span><br><span class="line">      partitioner: <span class="type">Partitioner</span>)</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W1</span>], <span class="type">Iterable</span>[<span class="type">W2</span>], <span class="type">Iterable</span>[<span class="type">W3</span>]))]</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line"><span class="type">RDD</span>[<span class="type">K</span>, <span class="type">W</span>] 	表示cogroup的<span class="type">RDD</span>对象</span><br><span class="line">numPartitions		用于指定结果的分区数</span><br><span class="line">partitioner		用于指定分区函数</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------cogroup-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list3_1 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>),(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> list3_2 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="string">&quot;hello&quot;</span>),(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;hadoop&quot;</span>),(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;spark&quot;</span>),(<span class="string">&quot;e&quot;</span>,<span class="string">&quot;flink&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> rdd3_1 = sc.parallelize(list3_1)</span><br><span class="line"><span class="keyword">val</span> rdd3_2 = sc.parallelize(list3_2)</span><br><span class="line"><span class="keyword">val</span> res3: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">String</span>]))] = rdd3_1.cogroup(rdd3_2)</span><br><span class="line">res3.foreach(x =&gt; println(<span class="string">&quot;(&quot;</span> + x._1 + <span class="string">&quot;,(&quot;</span> + x._2._1.toList + <span class="string">&quot;,&quot;</span> + x._2._2.toList + <span class="string">&quot;))&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------------------cogroup-------------------</span><br><span class="line">(d,(List(4),List()))</span><br><span class="line">(e,(List(),List(flink)))</span><br><span class="line">(a,(List(1),List(hello)))</span><br><span class="line">(b,(List(2),List(hadoop)))</span><br><span class="line">(c,(List(3),List(spark)))</span><br></pre></td></tr></table></figure>

<h3 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h3><p>该函数返回两个RDD的交集，并去重。通过函数签名的方法1可以看到，intersection 底层调用 cogroup，按 key 进行关联，关联得上的返回 key，关联不上返回空的过滤掉。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">函数签名：方法<span class="number">1</span>底层调用cogroup，方法<span class="number">2</span>底层调用方法<span class="number">3</span>，方法<span class="number">3</span>底层也是调用cogroup</span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">this</span>.map(v =&gt; (v, <span class="literal">null</span>)).cogroup(other.map(v =&gt; (v, <span class="literal">null</span>)))</span><br><span class="line">        .filter &#123; <span class="keyword">case</span> (_, (leftGroup, rightGroup)) =&gt; leftGroup.nonEmpty &amp;&amp; rightGroup.nonEmpty &#125;</span><br><span class="line">        .keys</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>], numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(</span><br><span class="line">      other: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      partitioner: <span class="type">Partitioner</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">other 表示求交集的目标<span class="type">RDD</span></span><br><span class="line">numPartitions		用于指定结果的分区数</span><br><span class="line">partitioner		用于指定分区函数</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------intersection-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array4_1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">val</span> array4_2 = <span class="type">Array</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">val</span> rdd4_1 = sc.parallelize(array4_1)</span><br><span class="line"><span class="keyword">val</span> rdd4_2 = sc.parallelize(array4_2)</span><br><span class="line"><span class="keyword">val</span> res4: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd4_1.intersection(rdd4_2)</span><br><span class="line">res4.foreach(println)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--------------------intersection-------------------</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="cartesian"><a href="#cartesian" class="headerlink" title="cartesian"></a>cartesian</h3><p>求RDD的笛卡尔积。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cartesian</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](other: <span class="type">RDD</span>[<span class="type">U</span>]): <span class="type">RDD</span>[(<span class="type">T</span>, <span class="type">U</span>)]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">other 表示求笛卡尔积的目标<span class="type">RDD</span></span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------cartesian-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array5_1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> array5_2 = <span class="type">Array</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">val</span> rdd5_1 = sc.parallelize(array5_1)</span><br><span class="line"><span class="keyword">val</span> rdd5_2 = sc.parallelize(array5_2)</span><br><span class="line"><span class="keyword">val</span> res5: <span class="type">RDD</span>[(<span class="type">Int</span>,<span class="type">Int</span>)] = rdd5_1.cartesian(rdd5_2)</span><br><span class="line">res5.foreach(println)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--------------------cartesian-------------------</span><br><span class="line">(1,5)</span><br><span class="line">(1,6)</span><br><span class="line">(1,7)</span><br><span class="line">(1,8)</span><br><span class="line">(2,5)</span><br><span class="line">(2,6)</span><br><span class="line">(2,7)</span><br><span class="line">(2,8)</span><br><span class="line">(3,5)</span><br><span class="line">(3,6)</span><br><span class="line">(3,7)</span><br><span class="line">(3,8)</span><br><span class="line">(4,5)</span><br><span class="line">(4,6)</span><br><span class="line">(4,7)</span><br><span class="line">(4,8)</span><br></pre></td></tr></table></figure>

<h2 id="3-3-数据采样"><a href="#3-3-数据采样" class="headerlink" title="3.3 数据采样"></a>3.3 数据采样</h2><h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p>对 RDD 中的数据进行采样。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(</span><br><span class="line">    withReplacement: <span class="type">Boolean</span>,</span><br><span class="line">    fraction: <span class="type">Double</span>,</span><br><span class="line">    seed: <span class="type">Long</span> = <span class="type">Utils</span>.random.nextLong): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">withReplacement: <span class="type">Boolean</span>,  表示之前采样的样本是否放回</span><br><span class="line">fraction: <span class="type">Double</span>,   表示采样样本的数据占总数据的比例</span><br><span class="line">seed: <span class="type">Long</span>   表示采样规则的种子值</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------sample-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list1 = (<span class="number">1</span> to <span class="number">100</span>).toList</span><br><span class="line"><span class="keyword">val</span> rdd1 = sc.parallelize(list1)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * withReplacement: Boolean,  表示之前采样的样本是否放回</span></span><br><span class="line"><span class="comment">  * fraction: Double,   表示采样样本的数据占总数据的比例</span></span><br><span class="line"><span class="comment">  * seed: Long   表示采样规则的种子值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">val</span> res1: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd1.sample(<span class="literal">true</span>, <span class="number">0.05</span>, <span class="number">0</span>)</span><br><span class="line">res1.foreach(println)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--------------------sample-------------------</span><br><span class="line">20</span><br><span class="line">45</span><br><span class="line">48</span><br><span class="line">67</span><br><span class="line">96</span><br></pre></td></tr></table></figure>

<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>对RDD中的元素进行去重操作。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数签名：方法<span class="number">1</span>底层调用方法<span class="number">2</span></span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">def</span> <span class="title">distinct</span></span>(): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">def</span> <span class="title">distinct</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">numPartitions 表示去重后的分区数。</span><br><span class="line"><span class="keyword">implicit</span> ord 表示隐式排序器，在 sortByKey 算子中也有这样的隐式排序器，可自定义</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------distinct-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array6 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> rdd6: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize(array6, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> res6: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd6.distinct(<span class="number">1</span>)</span><br><span class="line">println(<span class="string">&quot;初始分区数 = &quot;</span> + rdd6.partitions.size + <span class="string">&quot;; distince后分区数 = &quot;</span> + res6.partitions.size)</span><br><span class="line">res6.foreach(println)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--------------------distinct-------------------</span><br><span class="line">初始分区数 = 2; distince后分区数 = 1</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="3-4-数据重分布"><a href="#3-4-数据重分布" class="headerlink" title="3.4 数据重分布"></a>3.4 数据重分布</h2><h3 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h3><p>该函数用于将RDD进行重分区，使用HashPartitioner。coalesce 通常用来缩小分区，但也可以通过是否触发 shuffle 来扩大分区。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coalesce</span></span>(numPartitions: <span class="type">Int</span>, shuffle: <span class="type">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">               partitionCoalescer: <span class="type">Option</span>[<span class="type">PartitionCoalescer</span>] = <span class="type">Option</span>.empty)</span><br><span class="line">              (<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">numPartitions 表示 coalesce 后的分区数</span><br><span class="line">shuffle 表示是否触发 shuffle</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------coalesce-------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> array1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.parallelize(array1, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> res1_1 = rdd1.coalesce(<span class="number">2</span>).partitions.size</span><br><span class="line">    <span class="keyword">val</span> res1_2 = rdd1.coalesce(<span class="number">8</span>).partitions.size</span><br><span class="line">    <span class="keyword">val</span> res1_3 = rdd1.coalesce(<span class="number">8</span>, <span class="literal">true</span>).partitions.size</span><br><span class="line">    println(<span class="string">&quot;原始RDD分区:&quot;</span> + rdd1.partitions.size +</span><br><span class="line">      <span class="string">&quot;\n1. coalesce 不触发shuffle缩小分区: &quot;</span> + res1_1 +</span><br><span class="line">      <span class="string">&quot;\n2. coalesce 不触发shuffle扩大分区: &quot;</span> + res1_2 + <span class="string">&quot;(不shuffle无法扩大分区)&quot;</span> +</span><br><span class="line">      <span class="string">&quot;\n3. coalesce 触发shuffle扩大分区:&quot;</span> + res1_3)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------------coalesce-------------------</span><br><span class="line">原始RDD分区:4</span><br><span class="line">1. coalesce 不触发shuffle缩小分区: 2</span><br><span class="line">2. coalesce 不触发shuffle扩大分区: 4(不shuffle无法扩大分区)</span><br><span class="line">3. coalesce 触发shuffle扩大分区:8</span><br></pre></td></tr></table></figure>

<h3 id="repartition"><a href="#repartition" class="headerlink" title="repartition"></a>repartition</h3><p>该函数其实就是coalesce函数第二个参数shuffle为true的实现。由于 repartition 默认会触发 shuffle 操作，所以既可以用来缩小分区，又可以用来扩大分区。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数签名：底层调用 coalesce 的 shuffle 模式</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repartition</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">    coalesce(numPartitions, shuffle = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">numPartitions 表示 repartition 后的分区数</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------repartition-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array2 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> rdd2 = sc.parallelize(array2, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> res2_1 = rdd2.repartition(<span class="number">8</span>).partitions.size</span><br><span class="line"><span class="keyword">val</span> res2_2 = rdd2.repartition(<span class="number">2</span>).partitions.size</span><br><span class="line">println(<span class="string">&quot;原始RDD分区:&quot;</span> + rdd2.partitions.size +</span><br><span class="line">  <span class="string">&quot;\n1. repartition 扩大分区: &quot;</span> + res2_1 +</span><br><span class="line">  <span class="string">&quot;\n2. repartition 缩小分区: &quot;</span> + res2_2)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--------------------repartition-------------------</span><br><span class="line">原始RDD分区:4</span><br><span class="line">1. repartition 扩大分区: 8</span><br><span class="line">2. repartition 缩小分区: 2</span><br></pre></td></tr></table></figure>

<h3 id="repartitionAndSortWithinPartitions"><a href="#repartitionAndSortWithinPartitions" class="headerlink" title="repartitionAndSortWithinPartitions"></a>repartitionAndSortWithinPartitions</h3><p>对 RDD 执行边 repartition 和 边 sort 的操作，这里需要自定义排序规则。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repartitionAndSortWithinPartitions</span></span>(partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = self.withScope &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ShuffledRDD</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">V</span>](self, partitioner).setKeyOrdering(ordering)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">partitioner: <span class="type">Partitioner</span> 表示自定义排序器</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  println(<span class="string">&quot;--------------------repartitionAndSortWithinPartitions-------------------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> list3: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;math&quot;</span>, <span class="number">90</span>), (<span class="string">&quot;english&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;chinese&quot;</span>, <span class="number">88</span>),</span><br><span class="line">    (<span class="string">&quot;math&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;english&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;chinese&quot;</span>, <span class="number">82</span>))</span><br><span class="line">  <span class="keyword">val</span> rdd3 = sc.parallelize(list3,<span class="number">3</span>)</span><br><span class="line">  println(<span class="string">&quot;------打印原始分区信息------&quot;</span>)</span><br><span class="line">  rdd3.foreachPartition(x =&gt; println(x.toList))</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;------自定义分区器repartitionAndSortWithinPartitions后------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> res3: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = rdd3.repartitionAndSortWithinPartitions(<span class="keyword">new</span> <span class="type">MyPartitioner</span>(<span class="number">2</span>))</span><br><span class="line">  res3.foreachPartition(x =&gt; println(x.toList))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义分区器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span>(<span class="params">ptn: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 分区个数</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = ptn</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分区逻辑</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> ptn_idx = math.abs(key.hashCode()) % ptn</span><br><span class="line">    ptn_idx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--------------------repartitionAndSortWithinPartitions-------------------</span><br><span class="line">------打印原始分区信息------</span><br><span class="line">List((math,90), (english,95))</span><br><span class="line">List((chinese,88), (math,95))</span><br><span class="line">List((english,88), (chinese,82))</span><br><span class="line">------自定义分区器repartitionAndSortWithinPartitions后------</span><br><span class="line">List((english,95), (english,88), (math,90), (math,95))</span><br><span class="line">List((chinese,88), (chinese,82))</span><br></pre></td></tr></table></figure>

<h2 id="3-5-单个RDD数据聚合"><a href="#3-5-单个RDD数据聚合" class="headerlink" title="3.5 单个RDD数据聚合"></a>3.5 单个RDD数据聚合</h2><h3 id="groupByKey"><a href="#groupByKey" class="headerlink" title="groupByKey"></a>groupByKey</h3><p>该函数用于将RDD[K,V]中每个K对应的V值，合并到一个集合Iterable[V]中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数签名：函数<span class="number">1</span>和<span class="number">2</span>底层都是调用<span class="number">3</span></span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">numPartitions 用于指定分区数</span><br><span class="line">partitioner 用于指定分区函数</span><br></pre></td></tr></table></figure>

<p>程序例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  println(<span class="string">&quot;--------------------groupByKey-------------------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> list1: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;math&quot;</span>,<span class="number">90</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">86</span>),(<span class="string">&quot;chinese&quot;</span>, <span class="number">80</span>),</span><br><span class="line">      (<span class="string">&quot;math&quot;</span>,<span class="number">96</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;chinese&quot;</span>,<span class="number">82</span>))</span><br><span class="line">  <span class="keyword">val</span> rdd1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = sc.makeRDD(list1)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;before groupby, rdd partition size = &quot;</span> + rdd1.partitions.size)</span><br><span class="line">  <span class="keyword">val</span> res1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = rdd1.groupByKey(<span class="number">2</span>)</span><br><span class="line">  println(<span class="string">&quot;after groupby, rdd partition size = &quot;</span> + res1.partitions.size)</span><br><span class="line">  </span><br><span class="line">println(<span class="string">&quot;----各个成绩分类汇总-----&quot;</span>)</span><br><span class="line">  res1.foreach(x =&gt; &#123;</span><br><span class="line">    println(x._1 + <span class="string">&quot;\t&quot;</span> + x._2.toList.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;----求各科平均分-----&quot;</span>)</span><br><span class="line">  res1.map(x =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> avgscore = x._2.sum.toDouble / x._2.toList.size</span><br><span class="line">    (x._1, avgscore)</span><br><span class="line">  &#125;).foreach(x =&gt; println(x._1 + <span class="string">&quot;\t&quot;</span> + x._2))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------------------groupByKey-------------------</span><br><span class="line">before groupby, rdd partition size = 1</span><br><span class="line">after groupby, rdd partition size = 2</span><br><span class="line">----各个成绩分类汇总-----</span><br><span class="line">math	90,96</span><br><span class="line">english	86,88</span><br><span class="line">chinese	80,82</span><br><span class="line">----求各科平均分-----</span><br><span class="line">math	93.0</span><br><span class="line">english	87.0</span><br><span class="line">chinese	81.0</span><br></pre></td></tr></table></figure>

<h3 id="reduceBykey"><a href="#reduceBykey" class="headerlink" title="reduceBykey"></a>reduceBykey</h3><p>该函数用于将RDD[K,V]中每个K对应的V值根据映射函数来运算。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数签名：函数<span class="number">1</span>和<span class="number">2</span>底层都是调用<span class="number">3</span>，<span class="number">3</span>最终调用combineByKeyWithClassTag</span><br><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>, numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(partitioner: <span class="type">Partitioner</span>, func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span> 用于指定映射函数</span><br><span class="line">numPartitions 用于指定分区数</span><br><span class="line">partitioner 用于指定分区函数</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------reduceByKey-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list2: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;math&quot;</span>,<span class="number">90</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">86</span>),(<span class="string">&quot;chinese&quot;</span>, <span class="number">80</span>),</span><br><span class="line">  (<span class="string">&quot;math&quot;</span>,<span class="number">96</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;chinese&quot;</span>,<span class="number">82</span>))</span><br><span class="line"><span class="keyword">val</span> rdd2: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = sc.makeRDD(list2)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;----各科成绩总和-----&quot;</span>)</span><br><span class="line">rdd2.reduceByKey((x,y) =&gt; &#123;</span><br><span class="line">  x+y</span><br><span class="line">&#125;).foreach(x =&gt; println(x._1 + <span class="string">&quot;\t&quot;</span> + x._2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//.foreach(x =&gt; println(x._1 + &quot;\t&quot; + x._2))</span></span><br><span class="line">println(<span class="string">&quot;----求各科平均分-----&quot;</span>)</span><br><span class="line"><span class="comment">// reduceByKey对values处理，没法得到各科成绩数量</span></span><br><span class="line">rdd2.map(x =&gt; (x._1,(x._2.toInt, <span class="number">1</span>)))   <span class="comment">// score 添加计数器</span></span><br><span class="line">  .reduceByKey((a,b) =&gt; (a._1 + b._1, a._2 + b._2)) <span class="comment">// 对values(score,count) 分别求和，返回 (sumscore,totalcount)</span></span><br><span class="line">  .map(x =&gt; (x._1, x._2._1.toDouble / x._2._2))   <span class="comment">// avgscore = sumscore / totalcount</span></span><br><span class="line">  .foreach(x =&gt; println(x._1 + <span class="string">&quot;\t&quot;</span> + x._2))</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------------------reduceByKey-------------------</span><br><span class="line">----各科成绩总和-----</span><br><span class="line">math	186</span><br><span class="line">chinese	162</span><br><span class="line">english	174</span><br><span class="line">----求各科平均分-----</span><br><span class="line">math	93.0</span><br><span class="line">chinese	81.0</span><br><span class="line">english	87.0</span><br></pre></td></tr></table></figure>

<h3 id="aggregateByKey"><a href="#aggregateByKey" class="headerlink" title="aggregateByKey"></a>aggregateByKey</h3><p>aggregateByKey对PairRDD中相同的Key值进行聚合操作，函数最终返回的类型还是PairRDD，对应的结果是Key和聚合后的值，而aggregate函数直接返回的是非RDD的结果。（<strong>可以先看下文 Action 算子 aggregate 详解，会有助于理解 aggregateByKey</strong>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line">def aggregateByKey[U: ClassTag](zeroValue: U)(seqOp: (U, V) =&gt; U,</span><br><span class="line">      combOp: (U, U) =&gt; U): RDD[(K, U)]</span><br><span class="line">     </span><br><span class="line">def aggregateByKey[U: ClassTag](zeroValue: U, partitioner: Partitioner)(seqOp: (U, V) =&gt; U,</span><br><span class="line">      combOp: (U, U) =&gt; U): RDD[(K, U)]</span><br><span class="line">      </span><br><span class="line">def aggregateByKey[U: ClassTag](zeroValue: U, numPartitions: Int)(seqOp: (U, V) =&gt; U,</span><br><span class="line">      combOp: (U, U) =&gt; U): RDD[(K, U)]</span><br><span class="line">      </span><br><span class="line">参数介绍：（参数详细介绍可参考 aggregate 算子）</span><br><span class="line">zeroValue: U	表示聚合的初始值</span><br><span class="line">seqOp: (U, T) =&gt; U	表示迭代操作，拿RDD中每个元素与初始值进行合并</span><br><span class="line">combOp: (U, U) =&gt; U	表示分区结果数据的最终合并</span><br><span class="line">partitioner: Partitioner)	用于指定分区函数</span><br><span class="line">numPartitions: Int	用于指定分区属</span><br></pre></td></tr></table></figure>

<p>程序例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------aggregateByKey-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list3: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;math&quot;</span>,<span class="number">90</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">86</span>),(<span class="string">&quot;chinese&quot;</span>, <span class="number">80</span>),</span><br><span class="line">  (<span class="string">&quot;math&quot;</span>,<span class="number">96</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;chinese&quot;</span>,<span class="number">82</span>))</span><br><span class="line"><span class="keyword">val</span> rdd3 = sc.parallelize(list3)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * aggregate：针对RDD的单个元素进行聚合</span></span><br><span class="line"><span class="comment">  * aggregate = groupByKey + aggregate：对每个 group 的 values 进行聚合。</span></span><br><span class="line"><span class="comment">  *           针对 key-value 类型的 RDD，对每一组的 values 进行 aggreage 操作。</span></span><br><span class="line"><span class="comment">  *           因此，聚合逻辑可以直接 copy aggreate 的传参</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">val</span> res3: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd3.aggregateByKey((<span class="number">0</span>, <span class="number">0</span>))((u: (<span class="type">Int</span>, <span class="type">Int</span>), y) =&gt; (u._1 + y, u._2 + <span class="number">1</span>),</span><br><span class="line">  (x: (<span class="type">Int</span>, <span class="type">Int</span>), y: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; (x._1 + y._1, x._2 + y._2))</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;----求各科平均分-----&quot;</span>)</span><br><span class="line">res3.map(x =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> avscore = x._2._1.toDouble / x._2._2</span><br><span class="line">  (x._1, avscore)</span><br><span class="line">&#125;).foreach(x =&gt; println(x._1 + <span class="string">&quot;\t&quot;</span> + x._2))</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----求各科平均分-----</span><br><span class="line">math	93.0</span><br><span class="line">chinese	81.0</span><br><span class="line">english	87.0</span><br></pre></td></tr></table></figure>

<h3 id="sortByKey-sortBy"><a href="#sortByKey-sortBy" class="headerlink" title="sortByKey/sortBy"></a>sortByKey/sortBy</h3><p>sortBy是对标准的RDD进行排序，sortByKey函数作用于Key-Value形式的PairRDD，并对Key进行排序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line">sortBy</span><br><span class="line">def sortBy[K](</span><br><span class="line">  f: (T) =&gt; K,</span><br><span class="line">  ascending: Boolean = true,</span><br><span class="line">  numPartitions: Int = this.partitions.length)</span><br><span class="line">  (implicit ord: Ordering[K], ctag: ClassTag[K]): RDD[T] = withScope &#123;</span><br><span class="line">    this.keyBy[K](f)</span><br><span class="line">	    .sortByKey(ascending, numPartitions)</span><br><span class="line">	    .values</span><br><span class="line">&#125;</span><br><span class="line"> 参数说明：</span><br><span class="line"> f: (T) =&gt; K  表示排序的规则，即自定义排序</span><br><span class="line"></span><br><span class="line">sortByKey</span><br><span class="line">def sortByKey(ascending: Boolean = true, numPartitions: Int = self.partitions.length)</span><br><span class="line">  : RDD[(K, V)] = self.withScope</span><br><span class="line">&#123;</span><br><span class="line">	val part = new RangePartitioner(numPartitions, self, ascending)</span><br><span class="line">	new ShuffledRDD[K, V, V](self, part)</span><br><span class="line">	  .setKeyOrdering(if (ascending) ordering else ordering.reverse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据参数可以看到 sortBy 可以自定义排序，而 sortByKey 参数默认并没有指定排序规则的参数，是不是就不能进行自定义排序呢？答案是可以的，在 sortByKey 内部实现中有一个 setKeyOrdering 方法，方法就是对 OrderedRDDFunctions 类的变量 ordering 进行设置，它就是默认的排序规则，可以通过重写该排序规则实现 sortByKey 的自定义排序，具体实现我们后面再单独讨论。</p>
<p>程序例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  println(<span class="string">&quot;--------------------sortByKey-------------------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> list4: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;math&quot;</span>,<span class="number">90</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">95</span>),(<span class="string">&quot;chinese&quot;</span>, <span class="number">88</span>),</span><br><span class="line">    (<span class="string">&quot;math&quot;</span>,<span class="number">95</span>),(<span class="string">&quot;english&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;chinese&quot;</span>,<span class="number">82</span>))</span><br><span class="line">  <span class="keyword">val</span> rdd4 = sc.parallelize(list4)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;----sortBy按成绩降序排序-----&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> res4: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = rdd4.sortBy(x =&gt; x._2, <span class="literal">false</span>)</span><br><span class="line">  res4.foreach(x =&gt; println(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按成绩降序排序（问题：如何先按成绩降序，再按科目生序排序呢？即如何实现二次排序？ sortBy 可以指定多个排序变量）</span></span><br><span class="line">  println(<span class="string">&quot;----sortBy按成绩降序，并按科目降序-----&quot;</span>)</span><br><span class="line">  rdd4.sortBy(x =&gt; (x._2, x._1),<span class="literal">false</span>).foreach(println)</span><br><span class="line"></span><br><span class="line">  println(<span class="string">&quot;----sortByKey按成绩降序排序-----&quot;</span>)</span><br><span class="line">  <span class="comment">// 默认按 Key 排序，所以先要将 &lt;k,v&gt; 位置交换后 sortByKey 后再交换回来</span></span><br><span class="line">  <span class="keyword">val</span> res4_1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = rdd4.map(x =&gt; (x._2, x._1))</span><br><span class="line">                                        .sortByKey(<span class="literal">false</span>)</span><br><span class="line">                                        .map(x =&gt; (x._2, x._1))</span><br><span class="line">  <span class="comment">// 问题：排序方式是先排序分区数据，再对多个分区归并排序？还是直接全局归并排序？</span></span><br><span class="line">  res4_1.foreach(x =&gt; println(x))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--------------------sortByKey-------------------</span><br><span class="line">----sortBy按成绩降序排序-----</span><br><span class="line">(english,95)</span><br><span class="line">(math,95)</span><br><span class="line">(math,90)</span><br><span class="line">(chinese,88)</span><br><span class="line">(english,88)</span><br><span class="line">(chinese,82)</span><br><span class="line">----sortBy按成绩降序，并按科目降序-----</span><br><span class="line">(math,95)</span><br><span class="line">(english,95)</span><br><span class="line">(math,90)</span><br><span class="line">(english,88)</span><br><span class="line">(chinese,88)</span><br><span class="line">(chinese,82)</span><br><span class="line">----sortByKey按成绩降序排序-----</span><br><span class="line">(english,95)</span><br><span class="line">(math,95)</span><br><span class="line">(math,90)</span><br><span class="line">(chinese,88)</span><br><span class="line">(english,88)</span><br><span class="line">(chinese,82)</span><br></pre></td></tr></table></figure>

<h1 id="4-Action算子"><a href="#4-Action算子" class="headerlink" title="4. Action算子"></a>4. Action算子</h1><h2 id="4-1-收集数据到Driver"><a href="#4-1-收集数据到Driver" class="headerlink" title="4.1 收集数据到Driver"></a>4.1 收集数据到Driver</h2><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>用于将一个RDD转换成数组。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collect</span></span>(): <span class="type">Array</span>[<span class="type">T</span>] </span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------collect-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> rdd1 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">rdd1.collect().foreach(println)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--------------------collect-------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><p>返回RDD中的第一个元素，不排序。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数签名：first()底层调用take(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(): <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------first-------------------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> rdd2 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">  <span class="keyword">val</span> res2: <span class="type">Int</span> = rdd2.first()</span><br><span class="line">  println(<span class="string">&quot;first 返回值 = &quot;</span> + res2)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------------first-------------------</span><br><span class="line">first 返回值 = 1</span><br></pre></td></tr></table></figure>

<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>用于获取RDD中从0到num-1下标的元素，不排序。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(num: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------take-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> rdd3 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">val</span> res3: <span class="type">Array</span>[<span class="type">Int</span>] = rdd3.take(<span class="number">4</span>)</span><br><span class="line">println(<span class="string">&quot;take(4) 返回值 = &quot;</span> + res3.toList)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------------take-------------------</span><br><span class="line">take(4) 返回值 = List(1, 2, 3, 4)</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>返回RDD中的元素数量。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(): <span class="type">Long</span></span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------count-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> rdd4 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">val</span> res4: <span class="type">Long</span> = rdd4.count()</span><br><span class="line">println(<span class="string">&quot;count 返回值 = &quot;</span> + res4)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------------count-------------------</span><br><span class="line">count 返回值 = 8</span><br></pre></td></tr></table></figure>

<h3 id="takeSample"><a href="#takeSample" class="headerlink" title="takeSample"></a>takeSample</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeSample</span></span>(</span><br><span class="line">    withReplacement: <span class="type">Boolean</span>,</span><br><span class="line">    num: <span class="type">Int</span>,</span><br><span class="line">    seed: <span class="type">Long</span> = <span class="type">Utils</span>.random.nextLong): <span class="type">Array</span>[<span class="type">T</span>] </span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">withReplacement: <span class="type">Boolean</span>,  表示之前采样的样本是否放回</span><br><span class="line">fraction: <span class="type">Double</span>,   表示采样样本的数据占总数据的比例</span><br><span class="line">seed: <span class="type">Long</span>   表示采样规则的种子值</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------takeSample-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> rdd5 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">val</span> res5: <span class="type">Array</span>[<span class="type">Int</span>] = rdd5.takeSample(<span class="literal">true</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">println(<span class="string">&quot;takeSample(5) 返回值 = &quot;</span> + res5.toList)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------------takeSample-------------------</span><br><span class="line">takeSample(5) 返回值 = List(1, 3, 8, 7, 2)</span><br></pre></td></tr></table></figure>

<h3 id="takeOrdered"><a href="#takeOrdered" class="headerlink" title="takeOrdered"></a>takeOrdered</h3><p>和 take 作用类似，只是可以指定 ordering 排序规则。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeOrdered</span></span>(num: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">Array</span>[<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">num 表示取数的数目</span><br><span class="line">ord 表示隐式排序规则</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    println(<span class="string">&quot;--------------------takeOrder-------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> rdd6 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">    <span class="comment">// 指定排序规则，ordering1 和 ordering2 效果一样，都是逆序排序</span></span><br><span class="line"><span class="comment">//    implicit val ordering1 = Ordering[Int].on[Int](x =&gt; -x)</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> ordering2 = implicitly[<span class="type">Ordering</span>[<span class="type">Int</span>]].reverse</span><br><span class="line">    <span class="keyword">val</span> res6: <span class="type">Array</span>[<span class="type">Int</span>] = rdd6.takeOrdered(<span class="number">4</span>)</span><br><span class="line">    println(<span class="string">&quot;takeOrdered(4) 返回值 = &quot;</span> + res6.toList)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--------------------takeOrder-------------------</span><br><span class="line">takeOrdered(4) 返回值 = List(8, 7, 6, 5)</span><br></pre></td></tr></table></figure>

<h2 id="4-2-数据持久化到存储系统"><a href="#4-2-数据持久化到存储系统" class="headerlink" title="4.2 数据持久化到存储系统"></a>4.2 数据持久化到存储系统</h2><h3 id="saveAsTextFile"><a href="#saveAsTextFile" class="headerlink" title="saveAsTextFile"></a>saveAsTextFile</h3><p>saveAsTextFile用于将RDD以文本文件的格式存储到文件系统中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsTextFile</span></span>(path: <span class="type">String</span>, codec: <span class="type">Class</span>[_ &lt;: <span class="type">CompressionCodec</span>]): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">path 表示要保存的文件系统路径</span><br><span class="line">codec 表示指定的压缩类名</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------saveAsTextFile-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> rdd1 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">rdd1.saveAsTextFile(<span class="string">&quot;/Users/11085245/Documents/code/personal/data/1&quot;</span>,</span><br><span class="line">                    classOf[com.hadoop.compression.lzo.<span class="type">LzopCodec</span>])</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本地文件系统数据：</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /Users/11085245/Documents/code/personal/data/1</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 11085245  707420648   0 11 21 17:41 _SUCCESS</span><br><span class="line">-rw-r--r--  1 11085245  707420648  66 11 21 17:41 part-00000.lzo</span><br></pre></td></tr></table></figure>

<h3 id="saveAsSequenceFile"><a href="#saveAsSequenceFile" class="headerlink" title="saveAsSequenceFile"></a>saveAsSequenceFile</h3><p>saveAsSequenceFile用于将RDD以SequenceFile的文件格式保存到文件系统中。注意，saveAsSequenceFile 针对的对象为 &lt;key, value&gt; 类型的 RDD是，普通 RDD 不能直接调用该 API。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsSequenceFile</span></span>(</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    codec: <span class="type">Option</span>[<span class="type">Class</span>[_ &lt;: <span class="type">CompressionCodec</span>]] = <span class="type">None</span>): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">path 表示要保存的文件系统路径</span><br><span class="line">codec 表示指定的压缩类名</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------saveAsSequenceFile-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="string">&quot;hello&quot;</span>),(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;hadoop&quot;</span>),(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;spark&quot;</span>),(<span class="string">&quot;e&quot;</span>,<span class="string">&quot;flink&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> rdd2 = sc.parallelize(list2)</span><br><span class="line">rdd2.saveAsSequenceFile(<span class="string">&quot;/Users/11085245/Documents/code/personal/data/2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本地文件系统数据：</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /Users/11085245/Documents/code/personal/data/2</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 11085245  707420648    0 11 21 17:41 _SUCCESS</span><br><span class="line">-rw-r--r--  1 11085245  707420648  143 11 21 17:41 part-00000</span><br></pre></td></tr></table></figure>

<h3 id="saveAsObjectFile"><a href="#saveAsObjectFile" class="headerlink" title="saveAsObjectFile"></a>saveAsObjectFile</h3><p>saveAsObjectFile用于将RDD中的元素序列化成对象，存储到文件中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数签名：（底层调用 saveAsSequenceFile <span class="type">API</span>）</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">saveAsObjectFile</span></span>(path: <span class="type">String</span>): <span class="type">Unit</span> = withScope &#123;</span><br><span class="line">    <span class="keyword">this</span>.mapPartitions(iter =&gt; iter.grouped(<span class="number">10</span>).map(_.toArray))</span><br><span class="line">      .map(x =&gt; (<span class="type">NullWritable</span>.get(), <span class="keyword">new</span> <span class="type">BytesWritable</span>(<span class="type">Utils</span>.serialize(x))))</span><br><span class="line">      .saveAsSequenceFile(path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">path 表示要保存的文件系统路径</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------saveAsObjectFile-------------------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> rdd3 = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line">  rdd3.saveAsObjectFile(<span class="string">&quot;/Users/11085245/Documents/code/personal/data/3&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">本地文件系统数据：</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l /Users/11085245/Documents/code/personal/data/3</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 11085245  707420648    0 11 21 17:41 _SUCCESS</span><br><span class="line">-rw-r--r--  1 11085245  707420648  166 11 21 17:41 part-00000</span><br></pre></td></tr></table></figure>

<h2 id="4-3-聚合操作"><a href="#4-3-聚合操作" class="headerlink" title="4.3 聚合操作"></a>4.3 聚合操作</h2><h3 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h3><p>将每个分区里面的元素进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line">def aggregate[U: ClassTag](zeroValue: U)(seqOp: (U, T) =&gt; U, combOp: (U, U) =&gt; U): U</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">zeroValue: U	表示聚合的初始值</span><br><span class="line">seqOp: (U, T) =&gt; U	表示迭代操作，拿RDD中每个元素与初始值进行合并</span><br><span class="line">combOp: (U, U) =&gt; U	表示分区结果数据的最终合并</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">1. seqOp操作会聚合各分区中的元素，然后combOp操作把所有分区的聚合结果再次聚合，两个操作的初始值都是zeroValue。</span><br><span class="line">2. seqOp的操作是遍历分区中的所有元素(T)，第一个T跟zeroValue(U)做操作，结果(U)再作为与第二个T做操作的zeroValue，直到遍历完整个分区。</span><br><span class="line">3. combOp操作是把各分区聚合的结果，再聚合。</span><br></pre></td></tr></table></figure>

<p>怎么理解呢？在写代码前先来看一个文字叙述过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">假设有三个分区。分区0: (1,2,3,4), 分区1: (5,6,7,8), 分区2: (9,10)</span><br><span class="line">rdd = sc.parallelize(Array(1,2,3,4,5,6,7,8,9,10), 3)</span><br><span class="line">调用：rdd.aggregate((0, 0))((u: (Int, Int), y) =&gt; (u._1 + y, u._2 + 1),</span><br><span class="line">      (x: (Int, Int), y: (Int, Int)) =&gt; (x._1 + y._1, x._2 + y._2))</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> seqOp聚合各个分区中的元素</span></span><br><span class="line">针对分区0:(1,2,3,4)</span><br><span class="line">初始值：(0,0)</span><br><span class="line">分区0第一个元素：(0+1, 0+1) = (1,1)</span><br><span class="line">分区0第二个元素：(1+2, 1+1) = (3,2)</span><br><span class="line">分区0第三个元素：(3+3, 2+1) = (6,3)</span><br><span class="line">分区0第四个元素：(6+4, 3+1) = (10,4)</span><br><span class="line"></span><br><span class="line">针对分区1:(5,6,7,8)</span><br><span class="line">初始值：(0,0)</span><br><span class="line">分区1第一个元素：(0+5, 0+1) = (5,1)</span><br><span class="line">分区1第二个元素：(5+6, 1+1) = (11,2)</span><br><span class="line">分区1第三个元素：(11+7, 2+1) = (18,3)</span><br><span class="line">分区1第四个元素：（18+8, 3+1) = (26,4)</span><br><span class="line"></span><br><span class="line">针对分区2:(9,10)</span><br><span class="line">初始值：(0,0)</span><br><span class="line">分区2第一个元素：(0+9, 0+1) = (9,1)</span><br><span class="line">分区2第二个元素：(9+10, 1+1) = (19,2)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> combOp把所有分区的聚合结果再次聚合</span></span><br><span class="line">第一次聚合：合并分区0和分区1: (10,4) + (26,4) = (36,8)</span><br><span class="line">第二次聚合：合并上次结果和分区2: (36,8) + (19,2) = (55,10)</span><br></pre></td></tr></table></figure>

<p>程序例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  println(<span class="string">&quot;--------------------aggregate-------------------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> array1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">val</span> rdd1: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize(array1, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * (zeroValue: U)(seqOp: (U, T) =&gt; U, combOp: (U, U) =&gt; U)</span></span><br><span class="line"><span class="comment">    * zeroValue: U   聚合的初始值</span></span><br><span class="line"><span class="comment">    * seqOp: (U, Int) =&gt; U   迭代操作，拿RDD中的每个元素跟初始值进行合并</span></span><br><span class="line"><span class="comment">    * combOp: (U, U) =&gt; U   分区结果数据最终合并</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  println(<span class="string">&quot;---------求和----------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> sum: <span class="type">Int</span> = rdd1.aggregate(<span class="number">0</span>)((x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x+y,</span><br><span class="line">    (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x+y)</span><br><span class="line">  println(<span class="string">&quot;总和:&quot;</span> + sum)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * seqOp: (U, Int) =&gt; U</span></span><br><span class="line"><span class="comment">    *     (10,4) + 5 = (10,4) + (5,1) = (15,5)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  println(<span class="string">&quot;---------求平均值----------&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> res1: (<span class="type">Int</span>, <span class="type">Int</span>) = rdd1.aggregate((<span class="number">0</span>, <span class="number">0</span>))((u: (<span class="type">Int</span>, <span class="type">Int</span>), y) =&gt; (u._1 + y, u._2 + <span class="number">1</span>),</span><br><span class="line">    (x: (<span class="type">Int</span>, <span class="type">Int</span>), y: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; (x._1 + y._1, x._2 + y._2))</span><br><span class="line">  <span class="keyword">val</span> avgscore: <span class="type">Double</span> = res1._1.toDouble / res1._2</span><br><span class="line">  println(<span class="string">&quot;平均分: &quot;</span> + avgscore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------------aggregate-------------------</span><br><span class="line">---------求和----------</span><br><span class="line">总和:55</span><br><span class="line">---------求平均值----------</span><br><span class="line">平均分: 5.5</span><br></pre></td></tr></table></figure>



<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>根据映射函数f，对RDD中的元素进行二元计算，返回计算结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line">def reduce(f: (T, T) =&gt; T): T</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------reduce-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> array2 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> rdd2: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.parallelize(array2, <span class="number">2</span>)</span><br><span class="line">println(<span class="string">&quot;---------求平均值----------&quot;</span>)</span><br><span class="line"><span class="comment">// 求和前先将用map每个元素的count计为1</span></span><br><span class="line"><span class="keyword">val</span> res2: (<span class="type">Int</span>, <span class="type">Int</span>) = rdd2.map(x =&gt; (x, <span class="number">1</span>)).reduce((x: (<span class="type">Int</span>, <span class="type">Int</span>), y: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; &#123;</span><br><span class="line">  (x._1 + y._1, x._2 + y._2)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">val</span> avgscore2 = res2._1.toDouble / res2._2</span><br><span class="line">println(<span class="string">&quot;平均值：&quot;</span> + avgscore2)</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--------------------reduce-------------------</span><br><span class="line">---------求平均值----------</span><br><span class="line">平均值：5.5</span><br></pre></td></tr></table></figure>

<h3 id="countByKey"><a href="#countByKey" class="headerlink" title="countByKey"></a>countByKey</h3><p>对 &lt;key, value&gt; 类型的RDD按 key 统计。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countByKey</span></span>(): <span class="type">Map</span>[<span class="type">K</span>, <span class="type">Long</span>]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">无参，返回<span class="type">Map</span>类型键值对</span><br></pre></td></tr></table></figure>

<p>程序例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;--------------------countByKey-------------------&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list3 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="string">&quot;hello&quot;</span>),(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;hadoop&quot;</span>),(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;spark1&quot;</span>),(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;spark2&quot;</span>),(<span class="string">&quot;e&quot;</span>,<span class="string">&quot;flink&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> rdd3 = sc.parallelize(list3)</span><br><span class="line"><span class="keyword">val</span> res3: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = rdd3.countByKey()</span><br><span class="line">res3.foreach(x =&gt; println(x))</span><br></pre></td></tr></table></figure>

<p>结果输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--------------------countByKey-------------------</span><br><span class="line">(e,1)</span><br><span class="line">(a,2)</span><br><span class="line">(c,2)</span><br></pre></td></tr></table></figure>

<h2 id="4-4-函数式编程辅助操作"><a href="#4-4-函数式编程辅助操作" class="headerlink" title="4.4 函数式编程辅助操作"></a>4.4 函数式编程辅助操作</h2><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach用于遍历RDD，将映射函数应用于每一个元素，前面算子输出结果用得比较多，这里就不展开介绍。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数签名：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">f: <span class="type">T</span> =&gt; <span class="type">Unit</span>  表示传入的映射函数，返回类型为 <span class="type">Unit</span></span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://spark.apache.org/docs/2.4.7/rdd-programming-guide.html#transformations">Spark官网</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://lxw1234.com/archives/2015/07/363.htm">Spark算子系列文章</a></p>
</li>
</ul>

    </div>

    
    
    

    <div>
      
      <div>
	 
		<div style="text-align:center;color:#bfbfbf;font-size:16px;"> 
			<span>-------- 本文结束 </span> <i class="fa fa-paw"></i> <span> 感谢阅读 --------</span>
		</div> 
	
</div>
      
    </div>
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    请我喝杯咖啡~
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="笨小康 微信打赏">
        <p>微信打赏</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="笨小康 支付宝打赏">
        <p>支付宝打赏</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"><i class="fa fa-tag"></i> 大数据</a>
              <a href="/tags/Spark/" rel="tag"><i class="fa fa-tag"></i> Spark</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/17/PicGo-Typora%E9%85%8D%E7%BD%AEGithub%E5%9B%BE%E5%BA%8A%E6%89%8B%E5%86%8C/" rel="prev" title="PicGo+Typora配置Github图床手册">
      <i class="fa fa-chevron-left"></i> PicGo+Typora配置Github图床手册
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/22/Spark-RDD%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B/" rel="next" title="Spark RDD编程实例">
      Spark RDD编程实例 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  




          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-RDD%E6%A6%82%E8%A7%88"><span class="nav-text">1. RDD概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-RDD%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">2. RDD的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E4%BB%8E%E9%9B%86%E5%90%88%E5%88%9B%E5%BB%BARDD"><span class="nav-text">2.1 从集合创建RDD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#parallelize"><span class="nav-text">parallelize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#makeRDD"><span class="nav-text">makeRDD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E4%BB%8E%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%88%9B%E5%BB%BARDD"><span class="nav-text">2.2 从外部存储创建RDD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Transformation%E7%AE%97%E5%AD%90"><span class="nav-text">3. Transformation算子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%8D%95%E4%B8%AARDD%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.1 单个RDD转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMap"><span class="nav-text">flatMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-text">filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mapPartitions"><span class="nav-text">mapPartitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mapPartitionsWithIndex"><span class="nav-text">mapPartitionsWithIndex</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%BB%84%E5%90%88%E5%85%B6%E4%BB%96RDD"><span class="nav-text">3.2 组合其他RDD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#union"><span class="nav-text">union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join"><span class="nav-text">join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cogroup"><span class="nav-text">cogroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#intersection"><span class="nav-text">intersection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cartesian"><span class="nav-text">cartesian</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7"><span class="nav-text">3.3 数据采样</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sample"><span class="nav-text">sample</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distinct"><span class="nav-text">distinct</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%95%B0%E6%8D%AE%E9%87%8D%E5%88%86%E5%B8%83"><span class="nav-text">3.4 数据重分布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#coalesce"><span class="nav-text">coalesce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#repartition"><span class="nav-text">repartition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#repartitionAndSortWithinPartitions"><span class="nav-text">repartitionAndSortWithinPartitions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%8D%95%E4%B8%AARDD%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="nav-text">3.5 单个RDD数据聚合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#groupByKey"><span class="nav-text">groupByKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduceBykey"><span class="nav-text">reduceBykey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aggregateByKey"><span class="nav-text">aggregateByKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sortByKey-sortBy"><span class="nav-text">sortByKey&#x2F;sortBy</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Action%E7%AE%97%E5%AD%90"><span class="nav-text">4. Action算子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE%E5%88%B0Driver"><span class="nav-text">4.1 收集数据到Driver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#collect"><span class="nav-text">collect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#first"><span class="nav-text">first</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#take"><span class="nav-text">take</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count"><span class="nav-text">count</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#takeSample"><span class="nav-text">takeSample</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#takeOrdered"><span class="nav-text">takeOrdered</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%88%B0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">4.2 数据持久化到存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#saveAsTextFile"><span class="nav-text">saveAsTextFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#saveAsSequenceFile"><span class="nav-text">saveAsSequenceFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#saveAsObjectFile"><span class="nav-text">saveAsObjectFile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-text">4.3 聚合操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aggregate"><span class="nav-text">aggregate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduce"><span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#countByKey"><span class="nav-text">countByKey</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%BE%85%E5%8A%A9%E6%93%8D%E4%BD%9C"><span class="nav-text">4.4 函数式编程辅助操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach"><span class="nav-text">foreach</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">笨小康</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">笨小康</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
