<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在 《YARN ApplicationMaster启动原理及源码分析》文章中，AM 向 RM 注册后，会周期性地通过 RPC 函数 ApplicationMaster#allocate() 与 RM 通信，通信目的包括请求资源、获取新分配的资源及形成周期性心跳，本文中我们重点看看 AM 向 RM 申请到 Container 资源后，如何在 NM 节点上启动 Container，接下来会详细介绍 C">
<meta property="og:type" content="article">
<meta property="og:title" content="YARN Container启动原理源码分析">
<meta property="og:url" content="http://yoursite.com/2021/11/07/YARN-Container%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="笨小康的博客">
<meta property="og:description" content="在 《YARN ApplicationMaster启动原理及源码分析》文章中，AM 向 RM 注册后，会周期性地通过 RPC 函数 ApplicationMaster#allocate() 与 RM 通信，通信目的包括请求资源、获取新分配的资源及形成周期性心跳，本文中我们重点看看 AM 向 RM 申请到 Container 资源后，如何在 NM 节点上启动 Container，接下来会详细介绍 C">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-07T15:30:45.850Z">
<meta property="article:modified_time" content="2021-11-07T16:13:11.324Z">
<meta property="article:author" content="笨小康">
<meta property="article:tag" content="大数据">
<meta property="article:tag" content="YARN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/11/07/YARN-Container%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>YARN Container启动原理源码分析 | 笨小康的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">笨小康的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">星辰大海, 如期而至</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签云</a>

  </li>
        <li class="menu-item menu-item-photography">

    <a href="/categories/photography/" rel="section"><i class="fa fa-camera fa-fw"></i>摄影集</a>

  </li>
        <li class="menu-item menu-item-flomo">

    <a href="/categories/flomo/" rel="section"><i class="fa fa-lightbulb fa-fw"></i>碎碎念</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜文章
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/07/YARN-Container%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="笨小康">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="笨小康的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          YARN Container启动原理源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-07 23:30:45" itemprop="dateCreated datePublished" datetime="2021-11-07T23:30:45+08:00">2021-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/YARN/" itemprop="url" rel="index"><span itemprop="name">YARN</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在 《YARN ApplicationMaster启动原理及源码分析》文章中，AM 向 RM 注册后，会周期性地通过 RPC 函数 ApplicationMaster#allocate() 与 RM 通信，通信目的包括请求资源、获取新分配的资源及形成周期性心跳，本文中我们重点看看 AM 向 RM 申请到 Container 资源后，如何在 NM 节点上启动 Container，接下来会详细介绍 Container 从申请资源、启动到资源清理整个过程的源码。</p>
<h1 id="1-Container启动流程介绍"><a href="#1-Container启动流程介绍" class="headerlink" title="1. Container启动流程介绍"></a>1. Container启动流程介绍</h1><p>Container 启动是由 ApplicationMaster 通过 RPC 函数 ContainerManagementProtocol#startContainers() 向 NM 发起的，NM 中的 ContainerManagerImpl 组件负责接收并处理该请求。Container 启动过程主要经历三个阶段：资源本地化、启动并运行 Container和资源清理。</p>
<ul>
<li><strong>资源本地化</strong>主要是指分布式缓存机制完成的工作，功能包括初始化各种服务组件、创建工作目录、从 HDFS 下载运行所需的各种资源（比如文本文件、JAR 包、可执行文件）等。资源本地化主要有两部分组成，分别是应用程序初始化和 Container 本地化。其中，应用程序初始化的主要工作是初始化各类必需的服务组件（比如日志记录组件 LogHandler、资源状态追踪器 LocalResourceTrackerImpl等），供后续 Container 使用，通常由 Application 的第一个 Container 完成；Container 本地化则是创建工作目录，从 HDFS 下载各类文件资源。</li>
<li><strong>Container 启动</strong>是由 ContainerLauncher 服务完成，该服务将进一步调用插拔式组件 ContainerExecutor。YARN 中提供了三种 ContainerExecutor 实现，一种是 DefaultContainerExecutor，一种是 LinuxContainerExecutor，另一种是 DockerContainerExecutor，由参数 yarn.nodemanager.container-executor.class 控制具体采用的方式。</li>
<li><strong>资源清理</strong>则是资源本地化的逆过程，它负责清理各类资源，均由 ResourceLocalizationService 服务完成。</li>
</ul>
<h1 id="2-Container启动源码分析"><a href="#2-Container启动源码分析" class="headerlink" title="2. Container启动源码分析"></a>2. Container启动源码分析</h1><h2 id="2-1-AM调用api请求启动Container"><a href="#2-1-AM调用api请求启动Container" class="headerlink" title="2.1 AM调用api请求启动Container"></a>2.1 AM调用api请求启动Container</h2><p>在介绍 Container 启动前，我们先来看看 AM 在心跳时如何根据申请到的资源来请求 Container 的启动。AM 通过 RPC 函数 ApplicationMaster#allocate() 周期性向 RM 申请资源，并将申请到的资源保存在阻塞队列 responseQueue 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartbeatThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">&quot;AMRM Heartbeater thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">// 心跳线程死循环的跑</span></span><br><span class="line">        AllocateResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// synchronization ensures we don&#x27;t send heartbeats after unregistering</span></span><br><span class="line">        <span class="keyword">synchronized</span> (unregisterHeartbeatLock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!keepRunning) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重点：心跳线程其实就是周期性的调用 allocate() 方法，将分配出来的 Container 保存在 AllocateResponse 实例中</span></span><br><span class="line">            response = client.allocate(progress);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ApplicationAttemptNotFoundException e) &#123;</span><br><span class="line">            handler.onShutdownRequest();</span><br><span class="line">            LOG.info(<span class="string">&quot;Shutdown requested. Stopping callback.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Exception on heartbeat&quot;</span>, ex);</span><br><span class="line">            savedException = ex;</span><br><span class="line">            <span class="comment">// interrupt handler thread in case it waiting on the queue</span></span><br><span class="line">            handlerThread.interrupt();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 将 RM 返回的 AllocateResponse 对象资源添加到阻塞队列 responseQueue 中</span></span><br><span class="line">                responseQueue.put(response);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Interrupted while waiting to put on response queue&quot;</span>, ex);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(heartbeatIntervalMs.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">          LOG.debug(<span class="string">&quot;Heartbeater interrupted&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>那 responseQueue 队列保存申请到的 Container 资源怎么使用呢？通过查看 responseQueue.take() 函数，可以发现 AMRMClientAsyncImpl 类中的独立线程 CallbackHandlerThread 会不断地从队列中取出 AllocateResponse 对象进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackHandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallbackHandlerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">&quot;AMRM Callback Handler Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;    <span class="comment">// 死循环取出申请到的 Container 资源并进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (!keepRunning) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          AllocateResponse response;</span><br><span class="line">          <span class="keyword">if</span>(savedException != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Stopping callback due to: &quot;</span>, savedException);</span><br><span class="line">            handler.onError(savedException);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 从阻塞队列 responseQueue 取出 Container 资源</span></span><br><span class="line">            response = responseQueue.take();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;Interrupted while waiting for queue&quot;</span>, ex);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;NodeReport&gt; updatedNodes = response.getUpdatedNodes();</span><br><span class="line">          <span class="keyword">if</span> (!updatedNodes.isEmpty()) &#123;</span><br><span class="line">            handler.onNodesUpdated(updatedNodes);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          List&lt;ContainerStatus&gt; completed =</span><br><span class="line">              response.getCompletedContainersStatuses();</span><br><span class="line">          <span class="keyword">if</span> (!completed.isEmpty()) &#123;</span><br><span class="line">            handler.onContainersCompleted(completed);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          List&lt;Container&gt; allocated = response.getAllocatedContainers();</span><br><span class="line">          <span class="keyword">if</span> (!allocated.isEmpty()) &#123;</span><br><span class="line">              <span class="comment">// 重点：处理分配出来的 Container</span></span><br><span class="line">            handler.onContainersAllocated(allocated);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 更新 Container 的执行进度</span></span><br><span class="line">          progress = handler.getProgress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          handler.onError(ex);</span><br><span class="line">          <span class="comment">// re-throw exception to end the thread</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handler.onContainersAllocated(allocated) 方法会对分配出来的 Container 资源进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContainersAllocated</span><span class="params">(List&lt;Container&gt; allocatedContainers)</span> </span>&#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Got response from RM for container ask, allocatedCnt=&quot;</span></span><br><span class="line">          + allocatedContainers.size());</span><br><span class="line">      numAllocatedContainers.addAndGet(allocatedContainers.size());</span><br><span class="line">      <span class="keyword">for</span> (Container allocatedContainer : allocatedContainers) &#123;</span><br><span class="line">        String yarnShellId = Integer.toString(yarnShellIdCounter);</span><br><span class="line">        yarnShellIdCounter++;</span><br><span class="line">        LOG.info(<span class="string">&quot;Launching shell command on a new container.&quot;</span></span><br><span class="line">            + <span class="string">&quot;, containerId=&quot;</span> + allocatedContainer.getId()</span><br><span class="line">            + <span class="string">&quot;, yarnShellId=&quot;</span> + yarnShellId</span><br><span class="line">            + <span class="string">&quot;, containerNode=&quot;</span> + allocatedContainer.getNodeId().getHost()</span><br><span class="line">            + <span class="string">&quot;:&quot;</span> + allocatedContainer.getNodeId().getPort()</span><br><span class="line">            + <span class="string">&quot;, containerNodeURI=&quot;</span> + allocatedContainer.getNodeHttpAddress()</span><br><span class="line">            + <span class="string">&quot;, containerResourceMemory&quot;</span></span><br><span class="line">            + allocatedContainer.getResource().getMemory()</span><br><span class="line">            + <span class="string">&quot;, containerResourceVirtualCores&quot;</span></span><br><span class="line">            + allocatedContainer.getResource().getVirtualCores());</span><br><span class="line">        <span class="comment">// + &quot;, containerToken&quot;</span></span><br><span class="line">        <span class="comment">// +allocatedContainer.getContainerToken().getIdentifier().toString());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建运行 Container 的 LaunchContainerRunnable 线程</span></span><br><span class="line">        Thread launchThread = createLaunchContainerThread(allocatedContainer,</span><br><span class="line">            yarnShellId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// launch and start the container on a separate thread to keep</span></span><br><span class="line">        <span class="comment">// the main thread unblocked</span></span><br><span class="line">        <span class="comment">// as all containers may not be allocated at one go.</span></span><br><span class="line">        launchThreads.add(launchThread);</span><br><span class="line">        launchedContainers.add(allocatedContainer.getId());</span><br><span class="line">        <span class="comment">// 启动 LaunchContainerRunnable 线程</span></span><br><span class="line">        launchThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="function">Thread <span class="title">createLaunchContainerThread</span><span class="params">(Container allocatedContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">        String shellId)</span> </span>&#123;</span><br><span class="line">      LaunchContainerRunnable runnableLaunchContainer =</span><br><span class="line">          <span class="keyword">new</span> LaunchContainerRunnable(allocatedContainer, containerListener,</span><br><span class="line">              shellId);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Thread(runnableLaunchContainer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的逻辑启动了一个 LaunchContainerRunnable 线程，LaunchContainerRunnable 是 ApplicationMaster 类的内部类，继承自 Runnable 接口，通过该类的 run() 方法，可以知道该类主要做了两件事：</p>
<ul>
<li>初始化 Contianer 的本地资源，并构建 Container 的启动脚本</li>
<li>调用 NMClientAsync#startContainerAsync() api 接口启动 Container。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      LOG.info(<span class="string">&quot;Setting up container launch container for containerid=&quot;</span></span><br><span class="line">          + container.getId() + <span class="string">&quot; with shellid=&quot;</span> + shellId);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略构建 Container 启动脚本逻辑</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set up ContainerLaunchContext, setting local resource, environment,</span></span><br><span class="line">      <span class="comment">// command and token for constructor.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Note for tokens: Set up tokens for the container too. Today, for normal</span></span><br><span class="line">      <span class="comment">// shell commands, the container in distribute-shell doesn&#x27;t need any</span></span><br><span class="line">      <span class="comment">// tokens. We are populating them mainly for NodeManagers to be able to</span></span><br><span class="line">      <span class="comment">// download anyfiles in the distributed file-system. The tokens are</span></span><br><span class="line">      <span class="comment">// otherwise also useful in cases, for e.g., when one is running a</span></span><br><span class="line">      <span class="comment">// &quot;hadoop dfs&quot; command inside the distributed shell.</span></span><br><span class="line">      Map&lt;String, String&gt; myShellEnv = <span class="keyword">new</span> HashMap&lt;String, String&gt;(shellEnv);</span><br><span class="line">      myShellEnv.put(YARN_SHELL_ID, shellId);</span><br><span class="line">      ContainerLaunchContext ctx = ContainerLaunchContext.newInstance(</span><br><span class="line">        localResources, myShellEnv, commands, <span class="keyword">null</span>, allTokens.duplicate(),</span><br><span class="line">          <span class="keyword">null</span>);</span><br><span class="line">      containerListener.addContainer(container.getId(), container);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 重点：通过 NMClientAsync api 启动分配出来的 Container</span></span><br><span class="line">      nmClientAsync.startContainerAsync(container, ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 nmClientAsync.startContainerAsync() 方法并没有真正启动 Container，而是将 ContainerEventType.START_CONTAINER 事件封装成 ContainerEvent 对象（StartContainerEvent 类继承自 ContainerEvent 类），并添加到 Container 事件处理的阻塞队列 events 中，具体操作处理流程由 events 队列的消费逻辑处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startContainerAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Container container, ContainerLaunchContext containerLaunchContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (containers.putIfAbsent(container.getId(),</span><br><span class="line">        <span class="keyword">new</span> StatefulContainer(<span class="keyword">this</span>, container.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      callbackHandler.onStartContainerError(container.getId(),</span><br><span class="line">          RPCUtil.getRemoteException(<span class="string">&quot;Container &quot;</span> + container.getId() +</span><br><span class="line">              <span class="string">&quot; is already started or scheduled to start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      events.put(<span class="keyword">new</span> StartContainerEvent(container, containerLaunchContext));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">&quot;Exception when scheduling the event of starting Container &quot;</span> +</span><br><span class="line">          container.getId());</span><br><span class="line">      callbackHandler.onStartContainerError(container.getId(), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那这里的阻塞队列 events 又是怎么处理呢？还是来找找 events.take() 方法，发现在 NMClientAsyncImpl 类执行 serviceStart() 方法时会启动一个线程去消费 events 队列的事件，队列取出来的事件对象为内部封装有 ContainerEventType.START_CONTAINER 事件的 ContainerEvent 对象，通过 getContainerEventProcessor(event) 方法，获取对应的 ContainerEvent 对象的处理器 ContainerEventProcessor，并以线程池的方式运行该处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">serviceStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    client.start();</span><br><span class="line"></span><br><span class="line">    ThreadFactory tf = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(</span><br><span class="line">        <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot; #%d&quot;</span>).setDaemon(<span class="keyword">true</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with a default core-pool size and change it dynamically.</span></span><br><span class="line">    <span class="keyword">int</span> initSize = Math.min(INITIAL_THREAD_POOL_SIZE, maxThreadPoolSize);</span><br><span class="line">    threadPool = <span class="keyword">new</span> ThreadPoolExecutor(initSize, Integer.MAX_VALUE, <span class="number">1</span>,</span><br><span class="line">        TimeUnit.HOURS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), tf);</span><br><span class="line"></span><br><span class="line">    eventDispatcherThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ContainerEvent event = <span class="keyword">null</span>;</span><br><span class="line">        Set&lt;String&gt; allNodes = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stopped.get() &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 从阻塞队列 events 中取出 ContainerEvent 事件</span></span><br><span class="line">            event = events.take();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stopped.get()) &#123;</span><br><span class="line">              LOG.error(<span class="string">&quot;Returning, thread interrupted&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          allNodes.add(event.getNodeId().toString());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> threadPoolSize = threadPool.getCorePoolSize();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can increase the pool size only if haven&#x27;t reached the maximum</span></span><br><span class="line">          <span class="comment">// limit yet.</span></span><br><span class="line">          <span class="keyword">if</span> (threadPoolSize != maxThreadPoolSize) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nodes where containers will run at *this* point of time. This is</span></span><br><span class="line">            <span class="comment">// *not* the cluster size and doesn&#x27;t need to be.</span></span><br><span class="line">            <span class="keyword">int</span> nodeNum = allNodes.size();</span><br><span class="line">            <span class="keyword">int</span> idealThreadPoolSize = Math.min(maxThreadPoolSize, nodeNum);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (threadPoolSize &lt; idealThreadPoolSize) &#123;</span><br><span class="line">              <span class="comment">// Bump up the pool size to idealThreadPoolSize +</span></span><br><span class="line">              <span class="comment">// INITIAL_POOL_SIZE, the later is just a buffer so we are not</span></span><br><span class="line">              <span class="comment">// always increasing the pool-size</span></span><br><span class="line">              <span class="keyword">int</span> newThreadPoolSize = Math.min(maxThreadPoolSize,</span><br><span class="line">                  idealThreadPoolSize + INITIAL_THREAD_POOL_SIZE);</span><br><span class="line">              LOG.info(<span class="string">&quot;Set NMClientAsync thread pool size to &quot;</span> +</span><br><span class="line">                  newThreadPoolSize + <span class="string">&quot; as the number of nodes to talk to is &quot;</span></span><br><span class="line">                  + nodeNum);</span><br><span class="line">              threadPool.setCorePoolSize(newThreadPoolSize);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 重点：根据获取到的 Container 事件类型为 ContainerEventType.START_CONTAINER</span></span><br><span class="line">          <span class="comment">// getContainerEventProcessor(event) 返回一个 ContainerEventProcessor 线程对象，并在线程池中启动</span></span><br><span class="line">          threadPool.execute(getContainerEventProcessor(event));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    eventDispatcherThread.setName(<span class="string">&quot;Container  Event Dispatcher&quot;</span>);</span><br><span class="line">    eventDispatcherThread.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">    eventDispatcherThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.serviceStart();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerEventProcessor 处理器类是 NMClientAsyncImpl 类的内部类，继承自 Runnable 类，那我们来看看该类的 run() 方法，根据事件类型 ContainerEventType.START_CONTAINER 进入到对应的执行逻辑中，并通过 handle() 方法交给对应的状态机执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ContainerId containerId = event.getContainerId();</span><br><span class="line">      LOG.info(<span class="string">&quot;Processing Event &quot;</span> + event + <span class="string">&quot; for Container &quot;</span> + containerId);</span><br><span class="line">      <span class="comment">// 对 ContainerEventType.QUERY_CONTAINER 事件单独处理</span></span><br><span class="line">      <span class="keyword">if</span> (event.getType() == ContainerEventType.QUERY_CONTAINER) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ContainerStatus containerStatus = client.getContainerStatus(</span><br><span class="line">              containerId, event.getNodeId());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            callbackHandler.onContainerStatusReceived(</span><br><span class="line">                containerId, containerStatus);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t process user created unchecked exception</span></span><br><span class="line">            LOG.info(</span><br><span class="line">                <span class="string">&quot;Unchecked exception is thrown from onContainerStatusReceived&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; for Container &quot;</span> + event.getContainerId(), thr);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">          onExceptionRaised(containerId, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          onExceptionRaised(containerId, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          onExceptionRaised(containerId, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// ContainerEventType.START_CONTAINER 和 ContainerEventType.STOP_CONTAINER 事件处理逻辑</span></span><br><span class="line">        StatefulContainer container = containers.get(containerId);</span><br><span class="line">        <span class="keyword">if</span> (container == <span class="keyword">null</span>) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;Container &quot;</span> + containerId + <span class="string">&quot; is already stopped or failed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据事件类型交给对应的状态机处理</span></span><br><span class="line">          container.handle(event);</span><br><span class="line">          <span class="keyword">if</span> (isCompletelyDone(container)) &#123;</span><br><span class="line">            containers.remove(containerId);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerEventType.START_CONTAINER 事件的注册状态机为 StartContainerTransition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">    <span class="comment">// Transitions from PREP state</span></span><br><span class="line">    .addTransition(ContainerState.PREP,</span><br><span class="line">        EnumSet.of(ContainerState.RUNNING, ContainerState.FAILED),</span><br><span class="line">        ContainerEventType.START_CONTAINER,</span><br><span class="line">        <span class="keyword">new</span> StartContainerTransition())</span><br></pre></td></tr></table></figure>

<p>StartContainerTransition 状态机里的转换方法 transition()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/client/api/async/impl/NMClientAsyncImpl.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> ContainerState <span class="title">transition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          StatefulContainer container, ContainerEvent event)</span> </span>&#123;</span><br><span class="line">        ContainerId containerId = event.getContainerId();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          StartContainerEvent scEvent = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (event <span class="keyword">instanceof</span> StartContainerEvent) &#123;</span><br><span class="line">            scEvent = (StartContainerEvent) event;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">assert</span> scEvent != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//重点：调用 NMClient 类的 startContainer() 启动 Container</span></span><br><span class="line">          Map&lt;String, ByteBuffer&gt; allServiceResponse =</span><br><span class="line">              container.nmClientAsync.getClient().startContainer(</span><br><span class="line">                  scEvent.getContainer(), scEvent.getContainerLaunchContext());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 通过回调的方式更新 Container 状态</span></span><br><span class="line">            container.nmClientAsync.getCallbackHandler().onContainerStarted(</span><br><span class="line">                containerId, allServiceResponse);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t process user created unchecked exception</span></span><br><span class="line">            LOG.info(<span class="string">&quot;Unchecked exception is thrown from onContainerStarted for &quot;</span></span><br><span class="line">                + <span class="string">&quot;Container &quot;</span> + containerId, thr);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 返回 Container 的 RUNNING 状态</span></span><br><span class="line">          <span class="keyword">return</span> ContainerState.RUNNING;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">          <span class="keyword">return</span> onExceptionRaised(container, event, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="keyword">return</span> onExceptionRaised(container, event, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="keyword">return</span> onExceptionRaised(container, event, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在这里看到了激动人心的 startContainer() 方法，不过别急，这里还没有到真正的启动 Container 的时候，这里首先获取到 AM 真正与 NM 交互的客户端 NMClient，并调用其实现类 NMClientImpl 的 startContainer() 方法，获取到与 NM 交互的 RPC 协议 ContainerManagementProtocol，并通过其协议的 startContainers() 方法实现 RPC 远程调用，来实现 Container 的启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置：org/apache/hadoop/yarn/client/api/impl/NMClientImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, ByteBuffer&gt; <span class="title">startContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Container container, ContainerLaunchContext containerLaunchContext)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> YarnException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 构建 StartContainer 对象</span></span><br><span class="line">    StartedContainer startingContainer =</span><br><span class="line">        <span class="keyword">new</span> StartedContainer(container.getId(), container.getNodeId());</span><br><span class="line">    <span class="keyword">synchronized</span> (startingContainer) &#123;</span><br><span class="line">      addStartingContainer(startingContainer);</span><br><span class="line">      </span><br><span class="line">      Map&lt;String, ByteBuffer&gt; allServiceResponse;</span><br><span class="line">      ContainerManagementProtocolProxyData proxy = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        proxy =</span><br><span class="line">            cmProxy.getProxy(container.getNodeId().toString(),</span><br><span class="line">                container.getId());</span><br><span class="line">        StartContainerRequest scRequest =</span><br><span class="line">            StartContainerRequest.newInstance(containerLaunchContext,</span><br><span class="line">              container.getContainerToken());</span><br><span class="line">        List&lt;StartContainerRequest&gt; list = <span class="keyword">new</span> ArrayList&lt;StartContainerRequest&gt;();</span><br><span class="line">        list.add(scRequest);</span><br><span class="line">        StartContainersRequest allRequests =</span><br><span class="line">            StartContainersRequest.newInstance(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点：获取到 RPC 调用协议 ContainerManagementProtocol，并通过 RPC 函数 startContainers 启动 Container</span></span><br><span class="line">        StartContainersResponse response =</span><br><span class="line">            proxy</span><br><span class="line">                .getContainerManagementProtocol().startContainers(allRequests);</span><br><span class="line">        <span class="keyword">if</span> (response.getFailedRequests() != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; response.getFailedRequests().containsKey(container.getId())) &#123;</span><br><span class="line">          Throwable t =</span><br><span class="line">              response.getFailedRequests().get(container.getId()).deSerialize();</span><br><span class="line">          parseAndThrowException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        allServiceResponse = response.getAllServicesMetaData();</span><br><span class="line">        startingContainer.state = ContainerState.RUNNING;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">        <span class="comment">// 省略异常的状态返回</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">          cmProxy.mayBeCloseProxy(proxy);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> allServiceResponse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>NMClient 调用 RPC 函数 ContainerManagementProtocol#startContainers() 启动 Container。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StartContainersResponse</span></span><br><span class="line"><span class="function">      <span class="title">startContainers</span><span class="params">(StartContainersRequest requests)</span> <span class="keyword">throws</span> YarnException,</span></span><br><span class="line"><span class="function">          IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blockNewContainerRequests.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NMNotYetReadyException(</span><br><span class="line">        <span class="string">&quot;Rejecting new containers as NodeManager has not&quot;</span></span><br><span class="line">            + <span class="string">&quot; yet connected with ResourceManager&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    UserGroupInformation remoteUgi = getRemoteUgi();</span><br><span class="line">    NMTokenIdentifier nmTokenIdentifier = selectNMTokenIdentifier(remoteUgi);</span><br><span class="line">    authorizeUser(remoteUgi,nmTokenIdentifier);</span><br><span class="line">    List&lt;ContainerId&gt; succeededContainers = <span class="keyword">new</span> ArrayList&lt;ContainerId&gt;();</span><br><span class="line">    Map&lt;ContainerId, SerializedException&gt; failedContainers =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;ContainerId, SerializedException&gt;();</span><br><span class="line">    <span class="keyword">for</span> (StartContainerRequest request : requests.getStartContainerRequests()) &#123;</span><br><span class="line">      ContainerId containerId = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ContainerTokenIdentifier containerTokenIdentifier =</span><br><span class="line">            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());</span><br><span class="line">        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),</span><br><span class="line">          containerTokenIdentifier);</span><br><span class="line">        containerId = containerTokenIdentifier.getContainerID();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 Contain 的内部逻辑</span></span><br><span class="line">        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,</span><br><span class="line">          request);</span><br><span class="line">        succeededContainers.add(containerId);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (YarnException e) &#123;</span><br><span class="line">        failedContainers.put(containerId, SerializedException.newInstance(e));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvalidToken ie) &#123;</span><br><span class="line">        failedContainers.put(containerId, SerializedException.newInstance(ie));</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RPCUtil.getRemoteException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StartContainersResponse.newInstance(getAuxServiceMetaData(),</span><br><span class="line">      succeededContainers, failedContainers);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，AM 与 NM 的交互流程已实现，通过  RPC 函数 ContainerManagementProtocol#startContainers() 来启动 Container，那 Container 又是如何在 NM 上启动的呢？这一块我们留在后面介绍。</p>
<h2 id="2-2-Container资源本地化"><a href="#2-2-Container资源本地化" class="headerlink" title="2.2 Container资源本地化"></a>2.2 Container资源本地化</h2><p>上面过程中 AM 通过调用 RPC 函数 ContainerManagementProtocol#startContainers() 开始启动 Container，这部分我们来看看具体的启动逻辑，即 startContainerInternal() 方法。这里做了两件事</p>
<ul>
<li>发送 ApplicationEventType.INIT_APPLICATION 事件，对应用程序资源的初始化，主要是初始化各类必需的服务组件（如日志记录组件 LogHandler、资源状态追踪组件 LocalResourcesTrackerImpl等），供后续 Container 启动，通常来自 ApplicationMaster 的第一个 Container 完成，后续的 Container 跳过这段 Application 初始化过程。</li>
<li>发送 ApplicationEventType.INIT_CONTAINER 事件，对 Container 进行初始化操作。（这部分事件留在 Container 启动环节介绍）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startContainerInternal</span><span class="params">(NMTokenIdentifier nmTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      ContainerTokenIdentifier containerTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      StartContainerRequest request)</span> <span class="keyword">throws</span> YarnException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略Token认证及ContainerLaunchContext上下文初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!serviceStopped) &#123;</span><br><span class="line">        <span class="comment">// Create the application</span></span><br><span class="line">        Application application =</span><br><span class="line">            <span class="keyword">new</span> ApplicationImpl(dispatcher, user, applicationID, credentials, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 应用程序的初始化，供后续Container使用，这个逻辑只调用一次，通常由来自ApplicationMaster的第一个Container完成</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == context.getApplications().putIfAbsent(applicationID,</span><br><span class="line">          application)) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;Creating a new application reference for app &quot;</span> + applicationID);</span><br><span class="line">          LogAggregationContext logAggregationContext =</span><br><span class="line">              containerTokenIdentifier.getLogAggregationContext();</span><br><span class="line">          Map&lt;ApplicationAccessType, String&gt; appAcls =</span><br><span class="line">              container.getLaunchContext().getApplicationACLs();</span><br><span class="line">          context.getNMStateStore().storeApplication(applicationID,</span><br><span class="line">              buildAppProto(applicationID, user, credentials, appAcls,</span><br><span class="line">                logAggregationContext));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.向 ApplicationImpl 发送 ApplicationEventType.INIT_APPLICATION 事件</span></span><br><span class="line">          dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ApplicationInitEvent(applicationID, appAcls,</span><br><span class="line">              logAggregationContext));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.向 ApplicationImpl 发送 ApplicationEventType.INIT_CONTAINER 事件</span></span><br><span class="line">        <span class="keyword">this</span>.context.getNMStateStore().storeContainer(containerId, request);</span><br><span class="line">        dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> ApplicationContainerInitEvent(container));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.context.getContainerTokenSecretManager().startContainerSuccessful(</span><br><span class="line">          containerTokenIdentifier);</span><br><span class="line">        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,</span><br><span class="line">          <span class="string">&quot;ContainerManageImpl&quot;</span>, applicationID, containerId);</span><br><span class="line">        <span class="comment">// TODO launchedContainer misplaced -&gt; doesn&#x27;t necessarily mean a container</span></span><br><span class="line">        <span class="comment">// launch. A finished Application will not launch containers.</span></span><br><span class="line">        metrics.launchedContainer();</span><br><span class="line">        metrics.allocateContainer(containerTokenIdentifier.getResource());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> YarnException(</span><br><span class="line">            <span class="string">&quot;Container start failed as the NodeManager is &quot;</span> +</span><br><span class="line">            <span class="string">&quot;in the process of shutting down&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationEventType.INIT_APPLICATION 事件的状态转换过程，状态由 NEW 转变为 INITING，对应的状态机为 AppInitTransition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">           <span class="comment">// Transitions from NEW state</span></span><br><span class="line">     .addTransition(ApplicationState.NEW, ApplicationState.INITING,</span><br><span class="line">         ApplicationEventType.INIT_APPLICATION, <span class="keyword">new</span> AppInitTransition())</span><br></pre></td></tr></table></figure>

<p>AppInitTransition 状态机设置 ACL 属性后，并向 LogHandler（目前有两种实现方式，分别是 LogAggregationService 和 NonAggregatingLogHandler 发送一个 LogHandlerEventType.APPLICATION_STARTED 事件。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">SingleArcTransition</span>&lt;<span class="title">ApplicationImpl</span>, <span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ApplicationImpl app, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">      ApplicationInitEvent initEvent = (ApplicationInitEvent)event;</span><br><span class="line">      <span class="comment">// 设置 ACL 属性</span></span><br><span class="line">      app.applicationACLs = initEvent.getApplicationACLs();</span><br><span class="line">      app.aclsManager.addApplication(app.getAppId(), app.applicationACLs);</span><br><span class="line">      <span class="comment">// Inform the logAggregator</span></span><br><span class="line">      app.logAggregationContext = initEvent.getLogAggregationContext();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向 LogHandler 发送 LogHandlerEventType.APPLICATION_STARTED 事件</span></span><br><span class="line">      app.dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> LogHandlerAppStartedEvent(app.appId, app.user,</span><br><span class="line">              app.credentials, ContainerLogsRetentionPolicy.ALL_CONTAINERS,</span><br><span class="line">              app.applicationACLs, app.logAggregationContext)); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里以 LogAggregationService 服务为例，当 LogHandler 收到 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件后，将创建应用程序日志目录、设置目录权限等。然后向 ApplicationImpl 发送一个 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LogHandlerEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> APPLICATION_STARTED:</span><br><span class="line">        LogHandlerAppStartedEvent appStartEvent =</span><br><span class="line">            (LogHandlerAppStartedEvent) event;</span><br><span class="line">        <span class="comment">// 事情处理逻辑</span></span><br><span class="line">        initApp(appStartEvent.getApplicationId(), appStartEvent.getUser(),</span><br><span class="line">            appStartEvent.getCredentials(),</span><br><span class="line">            appStartEvent.getLogRetentionPolicy(),</span><br><span class="line">            appStartEvent.getApplicationAcls(),</span><br><span class="line">            appStartEvent.getLogAggregationContext());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CONTAINER_FINISHED:  <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> APPLICATION_FINISHED:  <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ; <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initApp</span><span class="params">(<span class="keyword">final</span> ApplicationId appId, String user,</span></span></span><br><span class="line"><span class="params"><span class="function">      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,</span></span></span><br><span class="line"><span class="params"><span class="function">      Map&lt;ApplicationAccessType, String&gt; appAcls,</span></span></span><br><span class="line"><span class="params"><span class="function">      LogAggregationContext logAggregationContext)</span> </span>&#123;</span><br><span class="line">    ApplicationEvent eventResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建应用程序日志目录、设置目录权限等</span></span><br><span class="line">      verifyAndCreateRemoteLogDir(getConfig());</span><br><span class="line">      initAppAggregator(appId, user, credentials, logRetentionPolicy, appAcls,</span><br><span class="line">          logAggregationContext);</span><br><span class="line">      eventResponse = <span class="keyword">new</span> ApplicationEvent(appId,</span><br><span class="line">          ApplicationEventType.APPLICATION_LOG_HANDLING_INITED);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (YarnRuntimeException e) &#123;</span><br><span class="line">      LOG.warn(<span class="string">&quot;Application failed to init aggregation&quot;</span>, e);</span><br><span class="line">      eventResponse = <span class="keyword">new</span> ApplicationEvent(appId,</span><br><span class="line">          ApplicationEventType.APPLICATION_LOG_HANDLING_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向 ApplicationImpl 发送 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件</span></span><br><span class="line">    <span class="keyword">this</span>.dispatcher.getEventHandler().handle(eventResponse);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationImpl 收到 ApplicationEventType.APPLICATION_LOG_HANDLING_INITED 事件后，直接向 ResourceLocalizationService 发送 LocalizationEventType.INIT_APPLICATION_RESOURCES 事件，此时 ApplicationImpl 仍处于 INITING 状态。ResourceLocalizationService 收到事件请求时进入到 handle() 逻辑处理，这里会创建一个 LocalResourcesTrackerImpl 对象，为接下来资源下载做准备，并向 ApplicationImpl 发送一个 ApplicationEventType.APPLICATION_INITED 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> create log dir as $logdir/$user/$appId</span></span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INIT_APPLICATION_RESOURCES:  <span class="comment">// 处理 LocalizationEventType.INIT_APPLICATION_RESOURCES 事件</span></span><br><span class="line">      handleInitApplicationResources(</span><br><span class="line">          ((ApplicationLocalizationEvent)event).getApplication());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> INIT_CONTAINER_RESOURCES: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESOURCES_LOCALIZED:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CACHE_CLEANUP:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CLEANUP_CONTAINER_RESOURCES: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> DESTROY_APPLICATION_RESOURCES: <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;Unknown localization event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleInitApplicationResources</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line">    String userName = app.getUser();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 LocalResourcesTrackerImpl 对象，为接下来的资源下载做准备</span></span><br><span class="line">    privateRsrc.putIfAbsent(userName, <span class="keyword">new</span> LocalResourcesTrackerImpl(userName,</span><br><span class="line">        <span class="keyword">null</span>, dispatcher, <span class="keyword">true</span>, <span class="keyword">super</span>.getConfig(), stateStore));</span><br><span class="line">    String appIdStr = ConverterUtils.toString(app.getAppId());</span><br><span class="line">    appRsrc.putIfAbsent(appIdStr, <span class="keyword">new</span> LocalResourcesTrackerImpl(app.getUser(),</span><br><span class="line">        app.getAppId(), dispatcher, <span class="keyword">false</span>, <span class="keyword">super</span>.getConfig(), stateStore));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向 ApplicationImpl 发送 ApplicationEventType.APPLICATION_INITED 事件</span></span><br><span class="line">    dispatcher.getEventHandler().handle(<span class="keyword">new</span> ApplicationInitedEvent(</span><br><span class="line">          app.getAppId()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationImpl 收到 ApplicationEventType.APPLICATION_INITED 事件后，依次向该应用程序已经保持的所有 Container 发送一个 INIT_CONTAINER 事件以通知它们进行初始化。此时，ApplicationImpl 运行状态由 INITING 转换为 RUNNING。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitDoneTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">SingleArcTransition</span>&lt;<span class="title">ApplicationImpl</span>, <span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ApplicationImpl app, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Start all the containers waiting for ApplicationInit</span></span><br><span class="line">      <span class="keyword">for</span> (Container container : app.containers.values()) &#123;</span><br><span class="line">        <span class="comment">// 向应用程序保存的 Container 发送 INIT_CONTAINER 事件</span></span><br><span class="line">        app.dispatcher.getEventHandler().handle(<span class="keyword">new</span> ContainerInitEvent(</span><br><span class="line">              container.getContainerId()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerImpl 收到 INIT_CONTAINER 事件后，先向附属服务 AuxServices 发送 APPLICATION_INIT 事件，以通知它有新的应用程序 Container 启动，然后从 ContainerLaunchContext 中获取各类可见性资源，并保存到 ContainerImpl 中特定的数据结构中，之后向 ResourceLocalizationService 发送 LocalizationEventType.INIT_CONTAINER_RESOURCES 事件，此时 ContainerImpl 运行状态已由 NEW 转换为 LOCALIZING。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResourcesTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">MultipleArcTransition</span>&lt;<span class="title">ContainerImpl</span>,<span class="title">ContainerEvent</span>,<span class="title">ContainerState</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContainerState <span class="title">transition</span><span class="params">(ContainerImpl container,</span></span></span><br><span class="line"><span class="params"><span class="function">        ContainerEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 向 AuxService 发送 AuxServicesEventType.CONTAINER_INIT 事件</span></span><br><span class="line">      container.dispatcher.getEventHandler().handle(<span class="keyword">new</span> AuxServicesEvent</span><br><span class="line">          (AuxServicesEventType.CONTAINER_INIT, container));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Inform the AuxServices about the opaque serviceData</span></span><br><span class="line">      Map&lt;String,ByteBuffer&gt; csd = ctxt.getServiceData();</span><br><span class="line">      <span class="keyword">if</span> (csd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// This can happen more than once per Application as each container may</span></span><br><span class="line">        <span class="comment">// have distinct service data</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,ByteBuffer&gt; service : csd.entrySet()) &#123;</span><br><span class="line">          container.dispatcher.getEventHandler().handle(</span><br><span class="line">              <span class="keyword">new</span> AuxServicesEvent(AuxServicesEventType.APPLICATION_INIT,</span><br><span class="line">                  container.user, container.containerId</span><br><span class="line">                      .getApplicationAttemptId().getApplicationId(),</span><br><span class="line">                  service.getKey().toString(), service.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      container.containerLocalizationStartTime = clock.getTime();</span><br><span class="line">      <span class="comment">// 从 ContainerLaunchContext 获取各类资源，并保持在数据结构中</span></span><br><span class="line">      Map&lt;String,LocalResource&gt; cntrRsrc = ctxt.getLocalResources();</span><br><span class="line">      <span class="keyword">if</span> (!cntrRsrc.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (Map.Entry&lt;String,LocalResource&gt; rsrc : cntrRsrc.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              LocalResourceRequest req =</span><br><span class="line">                  <span class="keyword">new</span> LocalResourceRequest(rsrc.getValue());</span><br><span class="line">              List&lt;String&gt; links = container.pendingResources.get(req);</span><br><span class="line">              <span class="keyword">if</span> (links == <span class="keyword">null</span>) &#123;</span><br><span class="line">                links = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                container.pendingResources.put(req, links);</span><br><span class="line">              &#125;</span><br><span class="line">              links.add(rsrc.getKey());</span><br><span class="line">              <span class="keyword">switch</span> (rsrc.getValue().getVisibility()) &#123;</span><br><span class="line">              <span class="keyword">case</span> PUBLIC:</span><br><span class="line">                container.publicRsrcs.add(req);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> PRIVATE:</span><br><span class="line">                container.privateRsrcs.add(req);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> APPLICATION:</span><br><span class="line">                container.appRsrcs.add(req);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">              LOG.info(<span class="string">&quot;Got exception parsing &quot;</span> + rsrc.getKey()</span><br><span class="line">                  + <span class="string">&quot; and value &quot;</span> + rsrc.getValue());</span><br><span class="line">              <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向 ResourceLocalizationService 发送 LocalizationEventType.INIT_CONTAINER_RESOURCES 事件</span></span><br><span class="line">        container.dispatcher.getEventHandler().handle(</span><br><span class="line">              <span class="keyword">new</span> ContainerLocalizationRequestEvent(container, req));</span><br><span class="line">        <span class="keyword">return</span> ContainerState.LOCALIZING;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这种情况是 Contaienr 已经进行了资源初始化操作，这里直接运行 Container</span></span><br><span class="line">        container.sendLaunchEvent();</span><br><span class="line">        container.metrics.endInitingContainer();</span><br><span class="line">        <span class="keyword">return</span> ContainerState.LOCALIZED;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ResourceLocalizationService 收到 LocalizationEventType.INIT_CONTAINER_RESOURCES 事件后，依次将 Container 所需的资源封装成一个 REQUEST 事件，发送给对应的资源状态追踪器 LocalResourcesTrackerImpl。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> create log dir as $logdir/$user/$appId</span></span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INIT_APPLICATION_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> INIT_CONTAINER_RESOURCES:</span><br><span class="line">       <span class="comment">// 将 Container 所需的资源单独封装成一个 REQUEST 事件，发送给对应的资源状态跟踪器 LocalResourcesTrackerImpl</span></span><br><span class="line">      handleInitContainerResources((ContainerLocalizationRequestEvent) event);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESOURCES_LOCALIZED:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CACHE_CLEANUP:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CLEANUP_CONTAINER_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> DESTROY_APPLICATION_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;Unknown localization event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>LocalResourcesTrackerImpl 收到 REQUEST 事件后，将为对应的资源创建一个状态机对象 LocalizeResource 以跟踪资源的生命周期，并将 REQUEST 事件进一步传送给 LocalizedResource。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/LocalizedResource.java</span></span><br><span class="line">    <span class="comment">// From INIT (ref == 0, awaiting req)</span></span><br><span class="line">    .addTransition(ResourceState.INIT, ResourceState.DOWNLOADING,</span><br><span class="line">        ResourceEventType.REQUEST, <span class="keyword">new</span> FetchResourceTransition())</span><br></pre></td></tr></table></figure>

<p>LocalizedResource 收到 REQUEST 事件后，将待下载资源信息通过 LocalizerEventType.REQUEST_RESOURCE_LOCALIZATION 事件发送给资源下载服务 ResourceLocalizationService，之后 LocalizedResource 状态由 NEW 转换为 DOWNLOADING。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/LocalizedResource.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchResourceTransition</span> <span class="keyword">extends</span> <span class="title">ResourceTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(LocalizedResource rsrc, ResourceEvent event)</span> </span>&#123;</span><br><span class="line">      ResourceRequestEvent req = (ResourceRequestEvent) event;</span><br><span class="line">      LocalizerContext ctxt = req.getContext();</span><br><span class="line">      ContainerId container = ctxt.getContainerId();</span><br><span class="line">      rsrc.ref.add(container);</span><br><span class="line">      rsrc.dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> LocalizerResourceRequestEvent(rsrc, req.getVisibility(), ctxt, </span><br><span class="line">              req.getLocalResourceRequest().getPattern()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ResourceLocalizationService 收到 LocalizerEventType.REQUEST_RESOURCE_LOCALIZATION 事件后，将交给 LocalizerTracker 服务处理，如果是 PUBLIC 资源，则统一交给 PublicLocalizer 处理，否则检查是否已经为该 Container 创建了 LocalizerRunner 线程，如果没有，则创建一个，否则直接添加到该线程的下载队列中。该线程会调用 ContainerExecutor#startLocalizer() 函数下载资源，该函数通过协议 LocalizationProtocol 与 ResourceLocalizationService 通信，以顺序获取待下载资源位置下载。待资源下载完成后，PublicLocalize 或者 LocalizerRunner 都会向 LocalizedResource 发送一个 LOCALIZED 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizerEvent event)</span> </span>&#123;</span><br><span class="line">      String locId = event.getLocalizerId();</span><br><span class="line">      <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> REQUEST_RESOURCE_LOCALIZATION:</span><br><span class="line">        <span class="comment">// 0) find running localizer or start new thread</span></span><br><span class="line">        LocalizerResourceRequestEvent req =</span><br><span class="line">          (LocalizerResourceRequestEvent)event;</span><br><span class="line">        <span class="comment">//根据 REQUEST 资源判断资源的可见性</span></span><br><span class="line">        <span class="keyword">switch</span> (req.getVisibility()) &#123;</span><br><span class="line">        <span class="comment">// 如果是 PUBLIC 资源，则交给线程 PublicLocalizer 处理</span></span><br><span class="line">        <span class="keyword">case</span> PUBLIC:</span><br><span class="line">          publicLocalizer.addResource(req);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PRIVATE:</span><br><span class="line">        <span class="keyword">case</span> APPLICATION:</span><br><span class="line">          <span class="keyword">synchronized</span> (privLocalizers) &#123;</span><br><span class="line">            LocalizerRunner localizer = privLocalizers.get(locId);</span><br><span class="line">            <span class="comment">// 检查是否创建了 LocalizerRunner 线程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == localizer) &#123;</span><br><span class="line">              LOG.info(<span class="string">&quot;Created localizer for &quot;</span> + locId);</span><br><span class="line">              localizer = <span class="keyword">new</span> LocalizerRunner(req.getContext(), locId);</span><br><span class="line">              privLocalizers.put(locId, localizer);</span><br><span class="line">              localizer.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1) propagate event</span></span><br><span class="line">            localizer.addResource(req);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LocalizedResource 收到 LOCALIZED 事件后，会向 ContainerImpl 发送一个 ContainerEventType.RESOURCE_LOCALIZED 事件，并且将状态从 DOWNLOADING 转换为 LOCALIZED。ContainerImpl 收到事件后，会检查所依赖的资源是否全部下载完毕，如果下载完成则向 ContainersLauncher 服务发送一个 LAUNCH_CONTAINER 事件，以启动对应 Container。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/LocalizedResource.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchSuccessTransition</span> <span class="keyword">extends</span> <span class="title">ResourceTransition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(LocalizedResource rsrc, ResourceEvent event)</span> </span>&#123;</span><br><span class="line">      ResourceLocalizedEvent locEvent = (ResourceLocalizedEvent) event;</span><br><span class="line">      rsrc.localPath =</span><br><span class="line">          Path.getPathWithoutSchemeAndAuthority(locEvent.getLocation());</span><br><span class="line">      rsrc.size = locEvent.getSize();</span><br><span class="line">      <span class="keyword">for</span> (ContainerId container : rsrc.ref) &#123;</span><br><span class="line">        <span class="comment">// 向 ContainerImpl 发送 ContainerEventType.RESOURCE_LOCALIZED 事件</span></span><br><span class="line">        rsrc.dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ContainerResourceLocalizedEvent(</span><br><span class="line">              container, rsrc.rsrc, rsrc.localPath));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，Container 资源本地化资源已下载完毕，接下来就开始启动和运行 Container。</p>
<h2 id="2-3-启动和运行Container"><a href="#2-3-启动和运行Container" class="headerlink" title="2.3 启动和运行Container"></a>2.3 启动和运行Container</h2><p>Container 运行是由 ContainersLauncher 服务实现的，主要过程可概括为：将待运行的 Container 所需的环境和运行命令写到 Shell 脚本 launch_container.sh 脚本中，并将启动该脚本的命令写入 default_container_executro.sh 中，然后通过该脚本启动 Container。之所以要将 Container 运行命令写到脚本中并通过运行脚本来执行它，主要是直接执行命令可能让一些特殊符号发生转义。</p>
<p>上面主要介绍 startContainerInternal() 的第一个事件处理，接下来看第一个事件的处理，以及如何启动和运行 Container。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startContainerInternal</span><span class="params">(NMTokenIdentifier nmTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      ContainerTokenIdentifier containerTokenIdentifier,</span></span></span><br><span class="line"><span class="params"><span class="function">      StartContainerRequest request)</span> <span class="keyword">throws</span> YarnException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略Token认证及ContainerLaunchContext上下文初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!serviceStopped) &#123;</span><br><span class="line">        <span class="comment">// Create the application</span></span><br><span class="line">        Application application =</span><br><span class="line">            <span class="keyword">new</span> ApplicationImpl(dispatcher, user, applicationID, credentials, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 应用程序的初始化，供后续Container使用，这个逻辑只调用一次，通常由来自ApplicationMaster的第一个Container完成</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == context.getApplications().putIfAbsent(applicationID,</span><br><span class="line">          application)) &#123;</span><br><span class="line">          LOG.info(<span class="string">&quot;Creating a new application reference for app &quot;</span> + applicationID);</span><br><span class="line">          LogAggregationContext logAggregationContext =</span><br><span class="line">              containerTokenIdentifier.getLogAggregationContext();</span><br><span class="line">          Map&lt;ApplicationAccessType, String&gt; appAcls =</span><br><span class="line">              container.getLaunchContext().getApplicationACLs();</span><br><span class="line">          context.getNMStateStore().storeApplication(applicationID,</span><br><span class="line">              buildAppProto(applicationID, user, credentials, appAcls,</span><br><span class="line">                logAggregationContext));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.向 ApplicationImpl 发送 ApplicationEventType.INIT_APPLICATION 事件</span></span><br><span class="line">          dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ApplicationInitEvent(applicationID, appAcls,</span><br><span class="line">              logAggregationContext));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.向 ApplicationImpl 发送 ApplicationEventType.INIT_CONTAINER 事件</span></span><br><span class="line">        <span class="keyword">this</span>.context.getNMStateStore().storeContainer(containerId, request);</span><br><span class="line">        dispatcher.getEventHandler().handle(</span><br><span class="line">          <span class="keyword">new</span> ApplicationContainerInitEvent(container));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.context.getContainerTokenSecretManager().startContainerSuccessful(</span><br><span class="line">          containerTokenIdentifier);</span><br><span class="line">        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,</span><br><span class="line">          <span class="string">&quot;ContainerManageImpl&quot;</span>, applicationID, containerId);</span><br><span class="line">        <span class="comment">// TODO launchedContainer misplaced -&gt; doesn&#x27;t necessarily mean a container</span></span><br><span class="line">        <span class="comment">// launch. A finished Application will not launch containers.</span></span><br><span class="line">        metrics.launchedContainer();</span><br><span class="line">        metrics.allocateContainer(containerTokenIdentifier.getResource());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> YarnException(</span><br><span class="line">            <span class="string">&quot;Container start failed as the NodeManager is &quot;</span> +</span><br><span class="line">            <span class="string">&quot;in the process of shutting down&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里触发了 Application 的事件 ApplicationEventType.INIT_CONTAINER，下面是该事件的状态转换过程及对应注册的状态机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">    <span class="comment">// Transitions from NEW state</span></span><br><span class="line">    .addTransition(ApplicationState.NEW, ApplicationState.NEW,</span><br><span class="line">        ApplicationEventType.INIT_CONTAINER,</span><br><span class="line">        <span class="keyword">new</span> InitContainerTransition())</span><br></pre></td></tr></table></figure>

<p>InitContainerTransition 状态机的处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/application/ApplicationImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InitContainerTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">SingleArcTransition</span>&lt;<span class="title">ApplicationImpl</span>, <span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ApplicationImpl app, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">      ApplicationContainerInitEvent initEvent =</span><br><span class="line">        (ApplicationContainerInitEvent) event;</span><br><span class="line">      Container container = initEvent.getContainer();</span><br><span class="line">      app.containers.put(container.getContainerId(), container);</span><br><span class="line">      LOG.info(<span class="string">&quot;Adding &quot;</span> + container.getContainerId()</span><br><span class="line">          + <span class="string">&quot; to application &quot;</span> + app.toString());</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">switch</span> (app.getApplicationState()) &#123;</span><br><span class="line">      <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="comment">// 应用程序提交后app是RUNNING状态，这里向调度器发送 ContainerEventType.INIT_CONTAINER 事件</span></span><br><span class="line">        app.dispatcher.getEventHandler().handle(<span class="keyword">new</span> ContainerInitEvent(</span><br><span class="line">            container.getContainerId()));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> INITING:</span><br><span class="line">      <span class="keyword">case</span> NEW:</span><br><span class="line">        <span class="comment">// these get queued up and sent out in AppInitDoneTransition</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span> : <span class="string">&quot;Invalid state for InitContainerTransition: &quot;</span> +</span><br><span class="line">            app.getApplicationState();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ContainerEventType.INIT_CONTAINER 事件对应的状态转换及注册的状态机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">    <span class="comment">// From NEW State</span></span><br><span class="line">    .addTransition(ContainerState.NEW,</span><br><span class="line">        EnumSet.of(ContainerState.LOCALIZING,</span><br><span class="line">            ContainerState.LOCALIZED,</span><br><span class="line">            ContainerState.LOCALIZATION_FAILED,</span><br><span class="line">            ContainerState.DONE),</span><br><span class="line">        ContainerEventType.INIT_CONTAINER, <span class="keyword">new</span> RequestResourcesTransition())</span><br></pre></td></tr></table></figure>

<p>RequestResourcesTransition 状态机行为的关键在于 sendLaunchEvent() 方法的调用，发送 Container 启动的事情请求，向调度器发送 ContainersLauncherEventType.LAUNCH_CONTAINER 事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResourcesTransition</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">MultipleArcTransition</span>&lt;<span class="title">ContainerImpl</span>,<span class="title">ContainerEvent</span>,<span class="title">ContainerState</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContainerState <span class="title">transition</span><span class="params">(ContainerImpl container,</span></span></span><br><span class="line"><span class="params"><span class="function">        ContainerEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略一些检查逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点：发送启动Container的操作</span></span><br><span class="line">        container.sendLaunchEvent();</span><br><span class="line">        container.metrics.endInitingContainer();</span><br><span class="line">        <span class="keyword">return</span> ContainerState.LOCALIZED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendLaunchEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ContainersLauncherEventType launcherEvent =</span><br><span class="line">        ContainersLauncherEventType.LAUNCH_CONTAINER;</span><br><span class="line">    <span class="keyword">if</span> (recoveredStatus == RecoveredContainerStatus.LAUNCHED) &#123;</span><br><span class="line">      <span class="comment">// try to recover a container that was previously launched</span></span><br><span class="line">      launcherEvent = ContainersLauncherEventType.RECOVER_CONTAINER;</span><br><span class="line">    &#125;</span><br><span class="line">    containerLaunchStartTime = clock.getTime();</span><br><span class="line">    <span class="comment">// 向调度器发送 ContainersLauncherEventType.LAUNCH_CONTAINER 事件请求</span></span><br><span class="line">    dispatcher.getEventHandler().handle(</span><br><span class="line">        <span class="keyword">new</span> ContainersLauncherEvent(<span class="keyword">this</span>, launcherEvent));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里向调度器发送 ContainersLauncherEventType.LAUNCH_CONTAINER 事件请求，之前发送事件状态转换过程不太一样，在代码中我们找到该事件的状态转换过程及注册状态机，那是由谁来处理这个事件请求呢？我们就需要看看 ContainersLauncherEventType 事件类注册的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ContainerManagerImpl</span><span class="params">(Context context, ContainerExecutor exec,</span></span></span><br><span class="line"><span class="params"><span class="function">      DeletionService deletionContext, NodeStatusUpdater nodeStatusUpdater,</span></span></span><br><span class="line"><span class="params"><span class="function">      NodeManagerMetrics metrics, ApplicationACLsManager aclsManager,</span></span></span><br><span class="line"><span class="params"><span class="function">      LocalDirsHandlerService dirsHandler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dispatcher.register(ContainerEventType.class,</span><br><span class="line">        <span class="keyword">new</span> ContainerEventDispatcher());</span><br><span class="line">    dispatcher.register(ApplicationEventType.class,</span><br><span class="line">        <span class="keyword">new</span> ApplicationEventDispatcher());</span><br><span class="line">    dispatcher.register(LocalizationEventType.class, rsrcLocalizationSrvc);</span><br><span class="line">    dispatcher.register(AuxServicesEventType.class, auxiliaryServices);</span><br><span class="line">    dispatcher.register(ContainersMonitorEventType.class, containersMonitor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContainersLauncherEventType 事件类的注册方法</span></span><br><span class="line">    dispatcher.register(ContainersLauncherEventType.class, containersLauncher);</span><br><span class="line">    </span><br><span class="line">    addService(dispatcher);</span><br><span class="line"></span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">this</span>.readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">this</span>.writeLock = lock.writeLock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 ContainersLauncherEventType 事件类型类注册的事件处理器为 ContainersLauncher 类，那该类又是如何处理 ContainersLauncherEventType.LAUNCH_CONTAINER 事件请求呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：rg/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ContainersLauncherEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> ContainersLauncher launches containers one by one!!</span></span><br><span class="line">    Container container = event.getContainer();</span><br><span class="line">    ContainerId containerId = container.getContainerId();</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> LAUNCH_CONTAINER:</span><br><span class="line">        Application app =</span><br><span class="line">          context.getApplications().get(</span><br><span class="line">              containerId.getApplicationAttemptId().getApplicationId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAUNCH_CONTAINER 事件的处理逻辑，创建 ContainerLaunch 线程并启动线程</span></span><br><span class="line">        ContainerLaunch launch =</span><br><span class="line">            <span class="keyword">new</span> ContainerLaunch(context, getConfig(), dispatcher, exec, app,</span><br><span class="line">              event.getContainer(), dirsHandler, containerManager);</span><br><span class="line">        containerLauncher.submit(launch);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将其加入到运行的 Container 数据结构 running 中</span></span><br><span class="line">        running.put(containerId, launch);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RECOVER_CONTAINER: <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> CLEANUP_CONTAINER: <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的 ContainerLaunch 类是真正启动 Container 的类，ContainerLaunch 类继承自 Callable 类，线程启动的方式是通过 submit() 方法提交，调用 Callable 类的实现方法 call() 来真正执行线程。启动过程主要做了三件事：</p>
<ul>
<li>准备 Container 的执行环境；</li>
<li>更新 Container 状态，从 LOCALIZED 转换为 RUNNING；</li>
<li>调用 ContainerExecutor 对象在 NM 节点上启动 Container</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerLaunch.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ContainerLaunchContext launchContext = container.getLaunchContext();</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 启动 Container 前的准备工作：（省略）</span></span><br><span class="line"><span class="comment">      * 1.shell启动脚本的封装与拓展（添加自定义脚本）</span></span><br><span class="line"><span class="comment">      * 2.创建本地工作目录</span></span><br><span class="line"><span class="comment">      * 3.设置token的保存路径</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">   </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 由于 call() 方法调用是阻塞的，这里先发送 ContainerEventType.CONTAINER_LAUNCHED 事件，将 Container 状态从LOCALIZED 转换为 RUNNING</span></span><br><span class="line">          dispatcher.getEventHandler().handle(<span class="keyword">new</span> ContainerEvent(</span><br><span class="line">                containerID,</span><br><span class="line">                ContainerEventType.CONTAINER_LAUNCHED));</span><br><span class="line">          context.getNMStateStore().storeContainerLaunched(containerID);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Check if the container is signalled to be killed.</span></span><br><span class="line">          <span class="keyword">if</span> (!shouldLaunchContainer.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;Container &quot;</span> + containerIdStr + <span class="string">&quot; not launched as &quot;</span></span><br><span class="line">                + <span class="string">&quot;cleanup already called&quot;</span>);</span><br><span class="line">            ret = ExitCode.TERMINATED.getExitCode();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 重点：调用 ContainerExecutor 对象启动 Contianer</span></span><br><span class="line">            exec.activateContainer(containerID, pidFilePath);</span><br><span class="line">            ret = exec.launchContainer(container, nmPrivateContainerScriptPath,</span><br><span class="line">                    nmPrivateTokensPath, user, appIdStr, containerWorkDir,</span><br><span class="line">                    localDirs, logDirs);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Container 执行结果返回，判断是否成功执行（省略）</span></span><br><span class="line">    </span><br><span class="line">    LOG.info(<span class="string">&quot;Container &quot;</span> + containerIdStr + <span class="string">&quot; succeeded &quot;</span>);</span><br><span class="line">    dispatcher.getEventHandler().handle(</span><br><span class="line">        <span class="keyword">new</span> ContainerEvent(containerID,</span><br><span class="line">            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> Container 的运行环境已经准备好，接下来就是真正在 NM 上真正启动 Container 的过程，具体启动是调用 ContainerExecutor#launchContainer() 方法。运行 Container 是由插拔式组件 ContainerExecutor 完成，YARN 中提供了三种 ContainerExecutor 实现，一种是 DefaultContainerExecutor，一种是 LinuxContainerExecutor，另一种是 DockerContainerExecutor，由参数 yarn.nodemanager.container-executor.class 控制其具体使用方式。</p>
<h2 id="2-4-Container资源清理"><a href="#2-4-Container资源清理" class="headerlink" title="2.4 Container资源清理"></a>2.4 Container资源清理</h2><p>Container 资源清理是指 Container 运行完成后（可能成功或者失败），NM 需回收它占用的资源，这些资源主要是 Container 运行时使用的临时文件，主要来源是 ResourceLocalizationService 和 ContianerExecutor 两个服务/组件，其中 ResourceLocalizationService 将数据 HDFS 文件下载到本地，ContainerExecutor 为 Container 创建私有工作目录，并保存一些临时文件（比如 Container 进程 pid 文件）。因此，Container 资源清理过程主要是通知这两个组件删除临时目录。</p>
<p>从 ContainerLaunch#call() 方法结束处，当 Container 成功运行完成后，会向调度器发送 ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS 事件。该事件的注册状态转换如下，将 Container 状态 从 RUNNING 转换为 EXITED_WITH_SUCCESS，并触发状态机 ExitedWithSuccessTransition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">    <span class="comment">// From RUNNING State</span></span><br><span class="line">    .addTransition(ContainerState.RUNNING,</span><br><span class="line">        ContainerState.EXITED_WITH_SUCCESS,</span><br><span class="line">        ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS,</span><br><span class="line">        <span class="keyword">new</span> ExitedWithSuccessTransition(<span class="keyword">true</span>))</span><br></pre></td></tr></table></figure>

<p>ExitedWithSuccessTransition 状态过程会发送 ContainersLauncherEventType.CLEANUP_CONTAINER 事件，该事件发送了两个事件：</p>
<ul>
<li>向 ContainerLauncher 发送 ContainersLauncherEventType.CLEANUP_CONTAINER 清理事件；</li>
<li>向 ResourceLocalizationService 发送 LocalizationEventType.CLEANUP_CONTAINER_RESOURCES 清理事件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitedWithSuccessTransition</span> <span class="keyword">extends</span> <span class="title">ContainerTransition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> clCleanupRequired;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExitedWithSuccessTransition</span><span class="params">(<span class="keyword">boolean</span> clCleanupRequired)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.clCleanupRequired = clCleanupRequired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transition</span><span class="params">(ContainerImpl container, ContainerEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Set exit code to 0 on success        </span></span><br><span class="line">      container.exitCode = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Add containerWorkDir to the deletion service.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (clCleanupRequired) &#123;</span><br><span class="line">          <span class="comment">// 向 ContainerLauncher 发送 ContainersLauncherEventType.CLEANUP_CONTAINER 清理事件</span></span><br><span class="line">        container.dispatcher.getEventHandler().handle(</span><br><span class="line">            <span class="keyword">new</span> ContainersLauncherEvent(container,</span><br><span class="line">                ContainersLauncherEventType.CLEANUP_CONTAINER));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向 ResourceLocalizationService 发送 LocalizationEventType.CLEANUP_CONTAINER_RESOURCES 清理事件</span></span><br><span class="line">      container.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先来看看 ContainerLauncher 清理临时目录的过程。ContainersLauncherEventType.CLEANUP_CONTAINER 事件的处理逻辑最终会进入到 ContainersLauncher 的 handle() 方法，将 Container 从正在运行的 Container 列表中移除，并调用 ContainerLaunch#cleanupContainer() 方法清除 Container 占用的临时目录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ContainersLauncherEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> ContainersLauncher launches containers one by one!!</span></span><br><span class="line">    Container container = event.getContainer();</span><br><span class="line">    ContainerId containerId = container.getContainerId();</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> LAUNCH_CONTAINER:  <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> RECOVER_CONTAINER: <span class="comment">// 省略</span></span><br><span class="line">      <span class="keyword">case</span> CLEANUP_CONTAINER:</span><br><span class="line">        <span class="comment">// 将 Container 从正在运行 Container 列表中移除</span></span><br><span class="line">        ContainerLaunch launcher = running.remove(containerId);</span><br><span class="line">        <span class="keyword">if</span> (launcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Container not launched. So nothing needs to be done.</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cleanup a container whether it is running/killed/completed, so that</span></span><br><span class="line">        <span class="comment">// no sub-processes are alive.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 清理 Container 占用的临时目录</span></span><br><span class="line">          launcher.cleanupContainer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          LOG.warn(<span class="string">&quot;Got exception while cleaning container &quot;</span> + containerId</span><br><span class="line">              + <span class="string">&quot;. Ignoring.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>再来看看 ResourceLocalizationService 清除 Container 用户工作目录和 NM 私有目录下的 Container 目录。根据发送的发送 LocalizationEventType.CLEANUP_CONTAINER_RESOURCES 清理事件，可以进入到对应的清理逻辑 handleCleanupContainerResources()，执行具体的清理逻辑。该逻辑将会删除用户工作 <code>$&#123;yarn.nodemanager.local-dirs&#125;/usercache/&lt;user&gt;/appcache/$&#123;appid&#125;/$&#123;containerid&#125;</code> 的数据（即从 HDFS 下载的数据）和 <code>$&#123;yarn.nodemanager.local-dirs&#125;/nmPrivate/$&#123;appid&#125;/$&#123;containerid&#125;</code> 私有目录数据，这两个目标都存放了 Tokens 文件和 Shell 运行脚本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(LocalizationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INIT_APPLICATION_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> INIT_CONTAINER_RESOURCES:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CONTAINER_RESOURCES_LOCALIZED:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CACHE_CLEANUP:  <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">case</span> CLEANUP_CONTAINER_RESOURCES:</span><br><span class="line">      handleCleanupContainerResources((ContainerLocalizationCleanupEvent)event);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DESTROY_APPLICATION_RESOURCES: <span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> YarnRuntimeException(<span class="string">&quot;Unknown localization event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，Container 资源清理流程已完成。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li> 董西成. 《Hadoop技术内幕 · 深入解析 YARN 架构设计与实现原理》</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gaopenghigh/article/details/45507765">YARN Container 启动流程分析</a></li>
</ul>

    </div>

    
    
    

    <div>
      
      <div>
	 
		<div style="text-align:center;color:#bfbfbf;font-size:16px;"> 
			<span>-------- 本文结束 </span> <i class="fa fa-paw"></i> <span> 感谢阅读 --------</span>
		</div> 
	
</div>
      
    </div>
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    请我喝杯咖啡~
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="笨小康 微信打赏">
        <p>微信打赏</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="笨小康 支付宝打赏">
        <p>支付宝打赏</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag"><i class="fa fa-tag"></i> 大数据</a>
              <a href="/tags/YARN/" rel="tag"><i class="fa fa-tag"></i> YARN</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/07/YARN-ApplicationMaster%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="YARN ApplicationMaster启动原理与源码分析">
      <i class="fa fa-chevron-left"></i> YARN ApplicationMaster启动原理与源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/08/Markdown%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" rel="next" title="Markdown语法手册">
      Markdown语法手册 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  




          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Container%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-text">1. Container启动流程介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Container%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">2. Container启动源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-AM%E8%B0%83%E7%94%A8api%E8%AF%B7%E6%B1%82%E5%90%AF%E5%8A%A8Container"><span class="nav-text">2.1 AM调用api请求启动Container</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Container%E8%B5%84%E6%BA%90%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="nav-text">2.2 Container资源本地化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%90%E8%A1%8CContainer"><span class="nav-text">2.3 启动和运行Container</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Container%E8%B5%84%E6%BA%90%E6%B8%85%E7%90%86"><span class="nav-text">2.4 Container资源清理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">笨小康</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">笨小康</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
